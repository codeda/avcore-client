(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("rxjs"), require("rxjs/operators"), require("socket.io-client"));
	else if(typeof define === 'function' && define.amd)
		define(["rxjs", "rxjs/operators", "socket.io-client"], factory);
	else if(typeof exports === 'object')
		exports["rx_socketio_client"] = factory(require("rxjs"), require("rxjs/operators"), require("socket.io-client"));
	else
		root["rx_socketio_client"] = factory(root["rxjs"], root["rxjs"]["operators"], root["io"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_rxjs__, __WEBPACK_EXTERNAL_MODULE_rxjs_operators__, __WEBPACK_EXTERNAL_MODULE_socket_io_client__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/awaitqueue/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/awaitqueue/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AwaitQueue {\n    constructor({ ClosedErrorClass, StoppedErrorClass } = {\n        ClosedErrorClass: Error,\n        StoppedErrorClass: Error\n    }) {\n        // Closed flag.\n        this._closed = false;\n        // Queue of pending tasks.\n        this._pendingTasks = [];\n        // Error class used when rejecting a task due to AwaitQueue being closed.\n        this._ClosedErrorClass = Error;\n        // Error class used when rejecting a task due to AwaitQueue being stopped.\n        this._StoppedErrorClass = Error;\n        this._ClosedErrorClass = ClosedErrorClass;\n        this._StoppedErrorClass = StoppedErrorClass;\n    }\n    /**\n     * Closes the AwaitQueue. Pending tasks will be rejected with ClosedErrorClass\n     * error.\n     */\n    close() {\n        this._closed = true;\n    }\n    /**\n     * Accepts a task as argument and enqueues it after pending tasks. Once\n     * processed, the push() method resolves (or rejects) with the result\n     * returned by the given task.\n     *\n     * The given task must return a Promise or directly a value.\n     */\n    push(task) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof task !== 'function')\n                throw new TypeError('given task is not a function');\n            return new Promise((resolve, reject) => {\n                const pendingTask = {\n                    execute: task,\n                    resolve,\n                    reject,\n                    stopped: false\n                };\n                // Append task to the queue.\n                this._pendingTasks.push(pendingTask);\n                // And run it if this is the only task in the queue.\n                if (this._pendingTasks.length === 1)\n                    this._next();\n            });\n        });\n    }\n    stop() {\n        for (const pendingTask of this._pendingTasks) {\n            pendingTask.stopped = true;\n            pendingTask.reject(new this._StoppedErrorClass('AwaitQueue stopped'));\n        }\n        // Enpty the pending tasks array.\n        this._pendingTasks.length = 0;\n    }\n    _next() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Take the first pending task.\n            const pendingTask = this._pendingTasks[0];\n            if (!pendingTask)\n                return;\n            // Execute it.\n            yield this._executeTask(pendingTask);\n            // Remove the first pending task (the completed one) from the queue.\n            this._pendingTasks.shift();\n            // And continue.\n            this._next();\n        });\n    }\n    _executeTask(pendingTask) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._closed) {\n                pendingTask.reject(new this._ClosedErrorClass('AwaitQueue closed'));\n                return;\n            }\n            // If stop() was called for this task, ignore it.\n            if (pendingTask.stopped)\n                return;\n            try {\n                const result = yield pendingTask.execute();\n                if (this._closed) {\n                    pendingTask.reject(new this._ClosedErrorClass('AwaitQueue closed'));\n                    return;\n                }\n                // If stop() was called for this task, ignore it.\n                if (pendingTask.stopped)\n                    return;\n                // Resolve the task with the returned result (if any).\n                pendingTask.resolve(result);\n            }\n            catch (error) {\n                if (this._closed) {\n                    pendingTask.reject(new this._ClosedErrorClass('AwaitQueue closed'));\n                    return;\n                }\n                // If stop() was called for this task, ignore it.\n                if (pendingTask.stopped)\n                    return;\n                // Reject the task with its own error.\n                pendingTask.reject(error);\n            }\n        });\n    }\n}\nexports.AwaitQueue = AwaitQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXdhaXRxdWV1ZS9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvYXdhaXRxdWV1ZS9saWIvaW5kZXguanM/ZTA0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQXdhaXRRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoeyBDbG9zZWRFcnJvckNsYXNzLCBTdG9wcGVkRXJyb3JDbGFzcyB9ID0ge1xuICAgICAgICBDbG9zZWRFcnJvckNsYXNzOiBFcnJvcixcbiAgICAgICAgU3RvcHBlZEVycm9yQ2xhc3M6IEVycm9yXG4gICAgfSkge1xuICAgICAgICAvLyBDbG9zZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIFF1ZXVlIG9mIHBlbmRpbmcgdGFza3MuXG4gICAgICAgIHRoaXMuX3BlbmRpbmdUYXNrcyA9IFtdO1xuICAgICAgICAvLyBFcnJvciBjbGFzcyB1c2VkIHdoZW4gcmVqZWN0aW5nIGEgdGFzayBkdWUgdG8gQXdhaXRRdWV1ZSBiZWluZyBjbG9zZWQuXG4gICAgICAgIHRoaXMuX0Nsb3NlZEVycm9yQ2xhc3MgPSBFcnJvcjtcbiAgICAgICAgLy8gRXJyb3IgY2xhc3MgdXNlZCB3aGVuIHJlamVjdGluZyBhIHRhc2sgZHVlIHRvIEF3YWl0UXVldWUgYmVpbmcgc3RvcHBlZC5cbiAgICAgICAgdGhpcy5fU3RvcHBlZEVycm9yQ2xhc3MgPSBFcnJvcjtcbiAgICAgICAgdGhpcy5fQ2xvc2VkRXJyb3JDbGFzcyA9IENsb3NlZEVycm9yQ2xhc3M7XG4gICAgICAgIHRoaXMuX1N0b3BwZWRFcnJvckNsYXNzID0gU3RvcHBlZEVycm9yQ2xhc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgQXdhaXRRdWV1ZS4gUGVuZGluZyB0YXNrcyB3aWxsIGJlIHJlamVjdGVkIHdpdGggQ2xvc2VkRXJyb3JDbGFzc1xuICAgICAqIGVycm9yLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIGEgdGFzayBhcyBhcmd1bWVudCBhbmQgZW5xdWV1ZXMgaXQgYWZ0ZXIgcGVuZGluZyB0YXNrcy4gT25jZVxuICAgICAqIHByb2Nlc3NlZCwgdGhlIHB1c2goKSBtZXRob2QgcmVzb2x2ZXMgKG9yIHJlamVjdHMpIHdpdGggdGhlIHJlc3VsdFxuICAgICAqIHJldHVybmVkIGJ5IHRoZSBnaXZlbiB0YXNrLlxuICAgICAqXG4gICAgICogVGhlIGdpdmVuIHRhc2sgbXVzdCByZXR1cm4gYSBQcm9taXNlIG9yIGRpcmVjdGx5IGEgdmFsdWUuXG4gICAgICovXG4gICAgcHVzaCh0YXNrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhc2sgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2l2ZW4gdGFzayBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nVGFzayA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZTogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRhc2sgdG8gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdUYXNrcy5wdXNoKHBlbmRpbmdUYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBBbmQgcnVuIGl0IGlmIHRoaXMgaXMgdGhlIG9ubHkgdGFzayBpbiB0aGUgcXVldWUuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdUYXNrcy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBwZW5kaW5nVGFzayBvZiB0aGlzLl9wZW5kaW5nVGFza3MpIHtcbiAgICAgICAgICAgIHBlbmRpbmdUYXNrLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcGVuZGluZ1Rhc2sucmVqZWN0KG5ldyB0aGlzLl9TdG9wcGVkRXJyb3JDbGFzcygnQXdhaXRRdWV1ZSBzdG9wcGVkJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVucHR5IHRoZSBwZW5kaW5nIHRhc2tzIGFycmF5LlxuICAgICAgICB0aGlzLl9wZW5kaW5nVGFza3MubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgX25leHQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUYWtlIHRoZSBmaXJzdCBwZW5kaW5nIHRhc2suXG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nVGFzayA9IHRoaXMuX3BlbmRpbmdUYXNrc1swXTtcbiAgICAgICAgICAgIGlmICghcGVuZGluZ1Rhc2spXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gRXhlY3V0ZSBpdC5cbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX2V4ZWN1dGVUYXNrKHBlbmRpbmdUYXNrKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgcGVuZGluZyB0YXNrICh0aGUgY29tcGxldGVkIG9uZSkgZnJvbSB0aGUgcXVldWUuXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nVGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgIC8vIEFuZCBjb250aW51ZS5cbiAgICAgICAgICAgIHRoaXMuX25leHQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9leGVjdXRlVGFzayhwZW5kaW5nVGFzaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdUYXNrLnJlamVjdChuZXcgdGhpcy5fQ2xvc2VkRXJyb3JDbGFzcygnQXdhaXRRdWV1ZSBjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgc3RvcCgpIHdhcyBjYWxsZWQgZm9yIHRoaXMgdGFzaywgaWdub3JlIGl0LlxuICAgICAgICAgICAgaWYgKHBlbmRpbmdUYXNrLnN0b3BwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBwZW5kaW5nVGFzay5leGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nVGFzay5yZWplY3QobmV3IHRoaXMuX0Nsb3NlZEVycm9yQ2xhc3MoJ0F3YWl0UXVldWUgY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHN0b3AoKSB3YXMgY2FsbGVkIGZvciB0aGlzIHRhc2ssIGlnbm9yZSBpdC5cbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ1Rhc2suc3RvcHBlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIHRhc2sgd2l0aCB0aGUgcmV0dXJuZWQgcmVzdWx0IChpZiBhbnkpLlxuICAgICAgICAgICAgICAgIHBlbmRpbmdUYXNrLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1Rhc2sucmVqZWN0KG5ldyB0aGlzLl9DbG9zZWRFcnJvckNsYXNzKCdBd2FpdFF1ZXVlIGNsb3NlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBzdG9wKCkgd2FzIGNhbGxlZCBmb3IgdGhpcyB0YXNrLCBpZ25vcmUgaXQuXG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdUYXNrLnN0b3BwZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBSZWplY3QgdGhlIHRhc2sgd2l0aCBpdHMgb3duIGVycm9yLlxuICAgICAgICAgICAgICAgIHBlbmRpbmdUYXNrLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQXdhaXRRdWV1ZSA9IEF3YWl0UXVldWU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/awaitqueue/lib/index.js\n");

/***/ }),

/***/ "./node_modules/bowser/es5.js":
/*!************************************!*\
  !*** ./node_modules/bowser/es5.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(e,t){ true?module.exports=t():undefined}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=90)}({17:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||\"\"},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||\"\"},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case\"NT\":return\"NT\";case\"XP\":return\"XP\";case\"NT 5.0\":return\"2000\";case\"NT 5.1\":return\"XP\";case\"NT 5.2\":return\"2003\";case\"NT 6.0\":return\"Vista\";case\"NT 6.1\":return\"7\";case\"NT 6.2\":return\"8\";case\"NT 6.3\":return\"8.1\";case\"NT 10.0\":return\"10\";default:return}},e.getMacOSVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return\"Leopard\";case 6:return\"Snow Leopard\";case 7:return\"Lion\";case 8:return\"Mountain Lion\";case 9:return\"Mavericks\";case 10:return\"Yosemite\";case 11:return\"El Capitan\";case 12:return\"Sierra\";case 13:return\"High Sierra\";case 14:return\"Mojave\";case 15:return\"Catalina\";default:return}},e.getAndroidVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?\"Cupcake\":1===t[0]&&t[1]>=6?\"Donut\":2===t[0]&&t[1]<2?\"Eclair\":2===t[0]&&2===t[1]?\"Froyo\":2===t[0]&&t[1]>2?\"Gingerbread\":3===t[0]?\"Honeycomb\":4===t[0]&&t[1]<1?\"Ice Cream Sandwich\":4===t[0]&&t[1]<4?\"Jelly Bean\":4===t[0]&&t[1]>=4?\"KitKat\":5===t[0]?\"Lollipop\":6===t[0]?\"Marshmallow\":7===t[0]?\"Nougat\":8===t[0]?\"Oreo\":9===t[0]?\"Pie\":void 0},e.getVersionPrecision=function(e){return e.split(\".\").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),o=Math.max(i,s),a=0,u=e.map([t,r],(function(t){var r=o-e.getVersionPrecision(t),n=t+new Array(r+1).join(\".0\");return e.map(n.split(\".\"),(function(e){return new Array(20-e.length).join(\"0\")+e})).reverse()}));for(n&&(a=o-Math.min(i,s)),o-=1;o>=a;){if(u[0][o]>u[1][o])return 1;if(u[0][o]===u[1][o]){if(o===a)return 0;o-=1}else if(u[0][o]<u[1][o])return-1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),o=1;o<i;o++)s[o-1]=arguments[o];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var a=function(){var e=s[t];\"object\"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){n[t]=e[t]}))};for(t=0,r=s.length;t<r;t+=1)a();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||\"\"},e}();t.default=i,e.exports=t.default},18:function(e,t,r){\"use strict\";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={\"Amazon Silk\":\"amazon_silk\",\"Android Browser\":\"android\",Bada:\"bada\",BlackBerry:\"blackberry\",Chrome:\"chrome\",Chromium:\"chromium\",Electron:\"electron\",Epiphany:\"epiphany\",Firefox:\"firefox\",Focus:\"focus\",Generic:\"generic\",\"Google Search\":\"google_search\",Googlebot:\"googlebot\",\"Internet Explorer\":\"ie\",\"K-Meleon\":\"k_meleon\",Maxthon:\"maxthon\",\"Microsoft Edge\":\"edge\",\"MZ Browser\":\"mz\",\"NAVER Whale Browser\":\"naver\",Opera:\"opera\",\"Opera Coast\":\"opera_coast\",PhantomJS:\"phantomjs\",Puffin:\"puffin\",QupZilla:\"qupzilla\",QQ:\"qq\",QQLite:\"qqlite\",Safari:\"safari\",Sailfish:\"sailfish\",\"Samsung Internet for Android\":\"samsung_internet\",SeaMonkey:\"seamonkey\",Sleipnir:\"sleipnir\",Swing:\"swing\",Tizen:\"tizen\",\"UC Browser\":\"uc\",Vivaldi:\"vivaldi\",\"WebOS Browser\":\"webos\",WeChat:\"wechat\",\"Yandex Browser\":\"yandex\",Roku:\"roku\"};t.BROWSER_MAP={amazon_silk:\"Amazon Silk\",android:\"Android Browser\",bada:\"Bada\",blackberry:\"BlackBerry\",chrome:\"Chrome\",chromium:\"Chromium\",electron:\"Electron\",epiphany:\"Epiphany\",firefox:\"Firefox\",focus:\"Focus\",generic:\"Generic\",googlebot:\"Googlebot\",google_search:\"Google Search\",ie:\"Internet Explorer\",k_meleon:\"K-Meleon\",maxthon:\"Maxthon\",edge:\"Microsoft Edge\",mz:\"MZ Browser\",naver:\"NAVER Whale Browser\",opera:\"Opera\",opera_coast:\"Opera Coast\",phantomjs:\"PhantomJS\",puffin:\"Puffin\",qupzilla:\"QupZilla\",qq:\"QQ Browser\",qqlite:\"QQ Browser Lite\",safari:\"Safari\",sailfish:\"Sailfish\",samsung_internet:\"Samsung Internet for Android\",seamonkey:\"SeaMonkey\",sleipnir:\"Sleipnir\",swing:\"Swing\",tizen:\"Tizen\",uc:\"UC Browser\",vivaldi:\"Vivaldi\",webos:\"WebOS Browser\",wechat:\"WeChat\",yandex:\"Yandex Browser\"};t.PLATFORMS_MAP={tablet:\"tablet\",mobile:\"mobile\",desktop:\"desktop\",tv:\"tv\"};t.OS_MAP={WindowsPhone:\"Windows Phone\",Windows:\"Windows\",MacOS:\"macOS\",iOS:\"iOS\",Android:\"Android\",WebOS:\"WebOS\",BlackBerry:\"BlackBerry\",Bada:\"Bada\",Tizen:\"Tizen\",Linux:\"Linux\",ChromeOS:\"Chrome OS\",PlayStation4:\"PlayStation 4\",Roku:\"Roku\"};t.ENGINE_MAP={EdgeHTML:\"EdgeHTML\",Blink:\"Blink\",Trident:\"Trident\",Presto:\"Presto\",Gecko:\"Gecko\",WebKit:\"WebKit\"}},90:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function o(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var a=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),\"string\"!=typeof e)throw new Error(\"UserAgent should be a string\");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:\"BROWSER_MAP\",get:function(){return s.BROWSER_MAP}},{key:\"ENGINE_MAP\",get:function(){return s.ENGINE_MAP}},{key:\"OS_MAP\",get:function(){return s.OS_MAP}},{key:\"PLATFORMS_MAP\",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&o(t.prototype,r),n&&o(t,n),e}();t.default=a,e.exports=t.default},91:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),o=u(r(95)),a=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||\"\"===e)throw new Error(\"UserAgent parameter can't be empty\");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=a.default.find(n.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||\"\":this.getBrowser().name||\"\"},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=a.default.find(i.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||\"\":t||\"\"},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||\"\":t||\"\"},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=a.default.find(s.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||\"\":this.getEngine().name||\"\"},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=a.default.find(o.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return a.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach((function(t){var o=e[t];\"string\"==typeof o?(i[t]=o,s+=1):\"object\"==typeof o&&(r[t]=o,n+=1)})),n>0){var o=Object.keys(r),u=a.default.find(o,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=a.default.find(o,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=a.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=a.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if(\"string\"==typeof i)return\">\"===e[0]||\"<\"===e[0]?(r=e.substr(1),\"=\"===e[1]?(n=!0,r=e.substr(2)):t=[],\">\"===e[0]?t.push(1):t.push(-1)):\"=\"===e[0]?r=e.substr(1):\"~\"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(a.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e){return this.isBrowser(e)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\\/(\\d+(\\.?_?\\d+)+)/i,o=[{test:[/googlebot/i],describe:function(e){var t={name:\"Googlebot\"},r=i.default.getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\\/|opios/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(/(?:opr|opios)[\\s/](\\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:\"Samsung Internet for Android\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:\"NAVER Whale Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\\s/](\\d+(?:\\.\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:\"MZ Browser\"},r=i.default.getFirstMatch(/(?:MZBrowser)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:\"Focus\"},r=i.default.getFirstMatch(/(?:focus)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:\"Swing\"},r=i.default.getFirstMatch(/(?:swing)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:\"Opera Coast\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:\"Yandex Browser\"},r=i.default.getFirstMatch(/(?:yabrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:\"UC Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:\"Maxthon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:\"Epiphany\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:\"Puffin\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:\"Sleipnir\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:\"K-Meleon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:\"WeChat\"},r=i.default.getFirstMatch(/(?:micromessenger)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?\"QQ Browser Lite\":\"QQ Browser\"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:\"Internet Explorer\"},r=i.default.getFirstMatch(/(?:msie |rv:)(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\\sedg\\//i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getFirstMatch(/\\sedg\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:\"Vivaldi\"},r=i.default.getFirstMatch(/vivaldi\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:\"SeaMonkey\"},r=i.default.getFirstMatch(/seamonkey\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:\"Sailfish\"},r=i.default.getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:\"Amazon Silk\"},r=i.default.getFirstMatch(/silk\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:\"PhantomJS\"},r=i.default.getFirstMatch(/phantomjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:\"SlimerJS\"},r=i.default.getFirstMatch(/slimerjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t={name:\"BlackBerry\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:\"WebOS Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:\"Bada\"},r=i.default.getFirstMatch(/dolfin\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:\"Tizen\"},r=i.default.getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:\"QupZilla\"},r=i.default.getFirstMatch(/(?:qupzilla)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:\"Firefox\"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:\"Electron\"},r=i.default.getFirstMatch(/(?:electron)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:\"Chromium\"},r=i.default.getFirstMatch(/(?:chromium)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:\"Chrome\"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:\"Google Search\"},r=i.default.getFirstMatch(/(?:GSA)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:\"Android Browser\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:\"PlayStation 4\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:\"Safari\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search(\"\\\\(\")?/^(.*)\\/(.*)[ \\t]\\((.*)/:/^(.*)\\/(.*) /;return{name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=o,e.exports=t.default},93:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var o=[{test:[/Roku\\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\\/DVP-(\\d+\\.\\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i,e),r=i.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?) Version\\//],describe:function(e){var t=i.default.getSecondMatch(/(Version\\/)(\\d[\\d.]+)/,e);return{name:s.OS_MAP.iOS,version:t}}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\\d+(\\.?_?\\d+)+)/i,e).replace(/[_\\s]/g,\".\"),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i,e).replace(/[_\\s]/g,\".\");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\\s/-](\\d+(\\.\\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\\/(\\d+(\\.\\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\\d+\\/(\\d+([_\\s]\\d+)*)/i,e)||i.default.getFirstMatch(/\\bbb(\\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=o,e.exports=t.default},94:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var o=[{test:[/googlebot/i],describe:function(){return{type:\"bot\",vendor:\"Google\"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&\"Nova\",r={type:s.PLATFORMS_MAP.mobile,vendor:\"Huawei\"};return t&&(r.model=t),r}},{test:[/nexus\\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Nexus\"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/Macintosh(.*?) FxiOS(.*?) Version\\//],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\",model:\"Kindle Fire HD 7\"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:\"Apple\",model:t}}},{test:[/nexus\\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Nexus\"}}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"blackberry\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"BlackBerry\"}}},{test:function(e){return\"bada\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"windows phone\"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Microsoft\"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(\".\")[0]);return\"android\"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return\"android\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"macos\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:\"Apple\"}}},{test:function(e){return\"windows\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"linux\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"playstation 4\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return\"roku\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=o,e.exports=t.default},95:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var o=[{test:function(e){return\"microsoft edge\"===e.getBrowserName(!0)},describe:function(e){if(/\\sedg\\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\\/(\\d+(\\.?_?\\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\\/537\\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=o,e.exports=t.default}})}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYm93c2VyL2VzNS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3J4X3NvY2tldGlvX2NsaWVudC8uL25vZGVfbW9kdWxlcy9ib3dzZXIvZXM1LmpzPzMzN2YiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5ib3dzZXI9dCgpOmUuYm93c2VyPXQoKX0odGhpcywoZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gcihuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIGk9dFtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsciksaS5sPSEwLGkuZXhwb3J0c31yZXR1cm4gci5tPWUsci5jPXQsci5kPWZ1bmN0aW9uKGUsdCxuKXtyLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxyLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1yKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoci5yKG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgaSBpbiBlKXIuZChuLGksZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxpKSk7cmV0dXJuIG59LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsXCJhXCIsdCksdH0sci5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxyLnA9XCJcIixyKHIucz05MCl9KHsxNzpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG49cigxOCksaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIGUuZ2V0Rmlyc3RNYXRjaD1mdW5jdGlvbihlLHQpe3ZhciByPXQubWF0Y2goZSk7cmV0dXJuIHImJnIubGVuZ3RoPjAmJnJbMV18fFwiXCJ9LGUuZ2V0U2Vjb25kTWF0Y2g9ZnVuY3Rpb24oZSx0KXt2YXIgcj10Lm1hdGNoKGUpO3JldHVybiByJiZyLmxlbmd0aD4xJiZyWzJdfHxcIlwifSxlLm1hdGNoQW5kUmV0dXJuQ29uc3Q9ZnVuY3Rpb24oZSx0LHIpe2lmKGUudGVzdCh0KSlyZXR1cm4gcn0sZS5nZXRXaW5kb3dzVmVyc2lvbk5hbWU9ZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2VcIk5UXCI6cmV0dXJuXCJOVFwiO2Nhc2VcIlhQXCI6cmV0dXJuXCJYUFwiO2Nhc2VcIk5UIDUuMFwiOnJldHVyblwiMjAwMFwiO2Nhc2VcIk5UIDUuMVwiOnJldHVyblwiWFBcIjtjYXNlXCJOVCA1LjJcIjpyZXR1cm5cIjIwMDNcIjtjYXNlXCJOVCA2LjBcIjpyZXR1cm5cIlZpc3RhXCI7Y2FzZVwiTlQgNi4xXCI6cmV0dXJuXCI3XCI7Y2FzZVwiTlQgNi4yXCI6cmV0dXJuXCI4XCI7Y2FzZVwiTlQgNi4zXCI6cmV0dXJuXCI4LjFcIjtjYXNlXCJOVCAxMC4wXCI6cmV0dXJuXCIxMFwiO2RlZmF1bHQ6cmV0dXJufX0sZS5nZXRNYWNPU1ZlcnNpb25OYW1lPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCIuXCIpLnNwbGljZSgwLDIpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfHwwfSkpO2lmKHQucHVzaCgwKSwxMD09PXRbMF0pc3dpdGNoKHRbMV0pe2Nhc2UgNTpyZXR1cm5cIkxlb3BhcmRcIjtjYXNlIDY6cmV0dXJuXCJTbm93IExlb3BhcmRcIjtjYXNlIDc6cmV0dXJuXCJMaW9uXCI7Y2FzZSA4OnJldHVyblwiTW91bnRhaW4gTGlvblwiO2Nhc2UgOTpyZXR1cm5cIk1hdmVyaWNrc1wiO2Nhc2UgMTA6cmV0dXJuXCJZb3NlbWl0ZVwiO2Nhc2UgMTE6cmV0dXJuXCJFbCBDYXBpdGFuXCI7Y2FzZSAxMjpyZXR1cm5cIlNpZXJyYVwiO2Nhc2UgMTM6cmV0dXJuXCJIaWdoIFNpZXJyYVwiO2Nhc2UgMTQ6cmV0dXJuXCJNb2phdmVcIjtjYXNlIDE1OnJldHVyblwiQ2F0YWxpbmFcIjtkZWZhdWx0OnJldHVybn19LGUuZ2V0QW5kcm9pZFZlcnNpb25OYW1lPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCIuXCIpLnNwbGljZSgwLDIpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfHwwfSkpO2lmKHQucHVzaCgwKSwhKDE9PT10WzBdJiZ0WzFdPDUpKXJldHVybiAxPT09dFswXSYmdFsxXTw2P1wiQ3VwY2FrZVwiOjE9PT10WzBdJiZ0WzFdPj02P1wiRG9udXRcIjoyPT09dFswXSYmdFsxXTwyP1wiRWNsYWlyXCI6Mj09PXRbMF0mJjI9PT10WzFdP1wiRnJveW9cIjoyPT09dFswXSYmdFsxXT4yP1wiR2luZ2VyYnJlYWRcIjozPT09dFswXT9cIkhvbmV5Y29tYlwiOjQ9PT10WzBdJiZ0WzFdPDE/XCJJY2UgQ3JlYW0gU2FuZHdpY2hcIjo0PT09dFswXSYmdFsxXTw0P1wiSmVsbHkgQmVhblwiOjQ9PT10WzBdJiZ0WzFdPj00P1wiS2l0S2F0XCI6NT09PXRbMF0/XCJMb2xsaXBvcFwiOjY9PT10WzBdP1wiTWFyc2htYWxsb3dcIjo3PT09dFswXT9cIk5vdWdhdFwiOjg9PT10WzBdP1wiT3Jlb1wiOjk9PT10WzBdP1wiUGllXCI6dm9pZCAwfSxlLmdldFZlcnNpb25QcmVjaXNpb249ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3BsaXQoXCIuXCIpLmxlbmd0aH0sZS5jb21wYXJlVmVyc2lvbnM9ZnVuY3Rpb24odCxyLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgaT1lLmdldFZlcnNpb25QcmVjaXNpb24odCkscz1lLmdldFZlcnNpb25QcmVjaXNpb24ociksbz1NYXRoLm1heChpLHMpLGE9MCx1PWUubWFwKFt0LHJdLChmdW5jdGlvbih0KXt2YXIgcj1vLWUuZ2V0VmVyc2lvblByZWNpc2lvbih0KSxuPXQrbmV3IEFycmF5KHIrMSkuam9pbihcIi4wXCIpO3JldHVybiBlLm1hcChuLnNwbGl0KFwiLlwiKSwoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBBcnJheSgyMC1lLmxlbmd0aCkuam9pbihcIjBcIikrZX0pKS5yZXZlcnNlKCl9KSk7Zm9yKG4mJihhPW8tTWF0aC5taW4oaSxzKSksby09MTtvPj1hOyl7aWYodVswXVtvXT51WzFdW29dKXJldHVybiAxO2lmKHVbMF1bb109PT11WzFdW29dKXtpZihvPT09YSlyZXR1cm4gMDtvLT0xfWVsc2UgaWYodVswXVtvXTx1WzFdW29dKXJldHVybi0xfX0sZS5tYXA9ZnVuY3Rpb24oZSx0KXt2YXIgcixuPVtdO2lmKEFycmF5LnByb3RvdHlwZS5tYXApcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChlLHQpO2ZvcihyPTA7cjxlLmxlbmd0aDtyKz0xKW4ucHVzaCh0KGVbcl0pKTtyZXR1cm4gbn0sZS5maW5kPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbjtpZihBcnJheS5wcm90b3R5cGUuZmluZClyZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChlLHQpO2ZvcihyPTAsbj1lLmxlbmd0aDtyPG47cis9MSl7dmFyIGk9ZVtyXTtpZih0KGkscikpcmV0dXJuIGl9fSxlLmFzc2lnbj1mdW5jdGlvbihlKXtmb3IodmFyIHQscixuPWUsaT1hcmd1bWVudHMubGVuZ3RoLHM9bmV3IEFycmF5KGk+MT9pLTE6MCksbz0xO288aTtvKyspc1tvLTFdPWFyZ3VtZW50c1tvXTtpZihPYmplY3QuYXNzaWduKXJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCxbZV0uY29uY2F0KHMpKTt2YXIgYT1mdW5jdGlvbigpe3ZhciBlPXNbdF07XCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lJiZPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtuW3RdPWVbdF19KSl9O2Zvcih0PTAscj1zLmxlbmd0aDt0PHI7dCs9MSlhKCk7cmV0dXJuIGV9LGUuZ2V0QnJvd3NlckFsaWFzPWZ1bmN0aW9uKGUpe3JldHVybiBuLkJST1dTRVJfQUxJQVNFU19NQVBbZV19LGUuZ2V0QnJvd3NlclR5cGVCeUFsaWFzPWZ1bmN0aW9uKGUpe3JldHVybiBuLkJST1dTRVJfTUFQW2VdfHxcIlwifSxlfSgpO3QuZGVmYXVsdD1pLGUuZXhwb3J0cz10LmRlZmF1bHR9LDE4OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5FTkdJTkVfTUFQPXQuT1NfTUFQPXQuUExBVEZPUk1TX01BUD10LkJST1dTRVJfTUFQPXQuQlJPV1NFUl9BTElBU0VTX01BUD12b2lkIDA7dC5CUk9XU0VSX0FMSUFTRVNfTUFQPXtcIkFtYXpvbiBTaWxrXCI6XCJhbWF6b25fc2lsa1wiLFwiQW5kcm9pZCBCcm93c2VyXCI6XCJhbmRyb2lkXCIsQmFkYTpcImJhZGFcIixCbGFja0JlcnJ5OlwiYmxhY2tiZXJyeVwiLENocm9tZTpcImNocm9tZVwiLENocm9taXVtOlwiY2hyb21pdW1cIixFbGVjdHJvbjpcImVsZWN0cm9uXCIsRXBpcGhhbnk6XCJlcGlwaGFueVwiLEZpcmVmb3g6XCJmaXJlZm94XCIsRm9jdXM6XCJmb2N1c1wiLEdlbmVyaWM6XCJnZW5lcmljXCIsXCJHb29nbGUgU2VhcmNoXCI6XCJnb29nbGVfc2VhcmNoXCIsR29vZ2xlYm90OlwiZ29vZ2xlYm90XCIsXCJJbnRlcm5ldCBFeHBsb3JlclwiOlwiaWVcIixcIkstTWVsZW9uXCI6XCJrX21lbGVvblwiLE1heHRob246XCJtYXh0aG9uXCIsXCJNaWNyb3NvZnQgRWRnZVwiOlwiZWRnZVwiLFwiTVogQnJvd3NlclwiOlwibXpcIixcIk5BVkVSIFdoYWxlIEJyb3dzZXJcIjpcIm5hdmVyXCIsT3BlcmE6XCJvcGVyYVwiLFwiT3BlcmEgQ29hc3RcIjpcIm9wZXJhX2NvYXN0XCIsUGhhbnRvbUpTOlwicGhhbnRvbWpzXCIsUHVmZmluOlwicHVmZmluXCIsUXVwWmlsbGE6XCJxdXB6aWxsYVwiLFFROlwicXFcIixRUUxpdGU6XCJxcWxpdGVcIixTYWZhcmk6XCJzYWZhcmlcIixTYWlsZmlzaDpcInNhaWxmaXNoXCIsXCJTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkXCI6XCJzYW1zdW5nX2ludGVybmV0XCIsU2VhTW9ua2V5Olwic2VhbW9ua2V5XCIsU2xlaXBuaXI6XCJzbGVpcG5pclwiLFN3aW5nOlwic3dpbmdcIixUaXplbjpcInRpemVuXCIsXCJVQyBCcm93c2VyXCI6XCJ1Y1wiLFZpdmFsZGk6XCJ2aXZhbGRpXCIsXCJXZWJPUyBCcm93c2VyXCI6XCJ3ZWJvc1wiLFdlQ2hhdDpcIndlY2hhdFwiLFwiWWFuZGV4IEJyb3dzZXJcIjpcInlhbmRleFwiLFJva3U6XCJyb2t1XCJ9O3QuQlJPV1NFUl9NQVA9e2FtYXpvbl9zaWxrOlwiQW1hem9uIFNpbGtcIixhbmRyb2lkOlwiQW5kcm9pZCBCcm93c2VyXCIsYmFkYTpcIkJhZGFcIixibGFja2JlcnJ5OlwiQmxhY2tCZXJyeVwiLGNocm9tZTpcIkNocm9tZVwiLGNocm9taXVtOlwiQ2hyb21pdW1cIixlbGVjdHJvbjpcIkVsZWN0cm9uXCIsZXBpcGhhbnk6XCJFcGlwaGFueVwiLGZpcmVmb3g6XCJGaXJlZm94XCIsZm9jdXM6XCJGb2N1c1wiLGdlbmVyaWM6XCJHZW5lcmljXCIsZ29vZ2xlYm90OlwiR29vZ2xlYm90XCIsZ29vZ2xlX3NlYXJjaDpcIkdvb2dsZSBTZWFyY2hcIixpZTpcIkludGVybmV0IEV4cGxvcmVyXCIsa19tZWxlb246XCJLLU1lbGVvblwiLG1heHRob246XCJNYXh0aG9uXCIsZWRnZTpcIk1pY3Jvc29mdCBFZGdlXCIsbXo6XCJNWiBCcm93c2VyXCIsbmF2ZXI6XCJOQVZFUiBXaGFsZSBCcm93c2VyXCIsb3BlcmE6XCJPcGVyYVwiLG9wZXJhX2NvYXN0OlwiT3BlcmEgQ29hc3RcIixwaGFudG9tanM6XCJQaGFudG9tSlNcIixwdWZmaW46XCJQdWZmaW5cIixxdXB6aWxsYTpcIlF1cFppbGxhXCIscXE6XCJRUSBCcm93c2VyXCIscXFsaXRlOlwiUVEgQnJvd3NlciBMaXRlXCIsc2FmYXJpOlwiU2FmYXJpXCIsc2FpbGZpc2g6XCJTYWlsZmlzaFwiLHNhbXN1bmdfaW50ZXJuZXQ6XCJTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkXCIsc2VhbW9ua2V5OlwiU2VhTW9ua2V5XCIsc2xlaXBuaXI6XCJTbGVpcG5pclwiLHN3aW5nOlwiU3dpbmdcIix0aXplbjpcIlRpemVuXCIsdWM6XCJVQyBCcm93c2VyXCIsdml2YWxkaTpcIlZpdmFsZGlcIix3ZWJvczpcIldlYk9TIEJyb3dzZXJcIix3ZWNoYXQ6XCJXZUNoYXRcIix5YW5kZXg6XCJZYW5kZXggQnJvd3NlclwifTt0LlBMQVRGT1JNU19NQVA9e3RhYmxldDpcInRhYmxldFwiLG1vYmlsZTpcIm1vYmlsZVwiLGRlc2t0b3A6XCJkZXNrdG9wXCIsdHY6XCJ0dlwifTt0Lk9TX01BUD17V2luZG93c1Bob25lOlwiV2luZG93cyBQaG9uZVwiLFdpbmRvd3M6XCJXaW5kb3dzXCIsTWFjT1M6XCJtYWNPU1wiLGlPUzpcImlPU1wiLEFuZHJvaWQ6XCJBbmRyb2lkXCIsV2ViT1M6XCJXZWJPU1wiLEJsYWNrQmVycnk6XCJCbGFja0JlcnJ5XCIsQmFkYTpcIkJhZGFcIixUaXplbjpcIlRpemVuXCIsTGludXg6XCJMaW51eFwiLENocm9tZU9TOlwiQ2hyb21lIE9TXCIsUGxheVN0YXRpb240OlwiUGxheVN0YXRpb24gNFwiLFJva3U6XCJSb2t1XCJ9O3QuRU5HSU5FX01BUD17RWRnZUhUTUw6XCJFZGdlSFRNTFwiLEJsaW5rOlwiQmxpbmtcIixUcmlkZW50OlwiVHJpZGVudFwiLFByZXN0bzpcIlByZXN0b1wiLEdlY2tvOlwiR2Vja29cIixXZWJLaXQ6XCJXZWJLaXRcIn19LDkwOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoOTEpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTtmdW5jdGlvbiBvKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX12YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9dmFyIHQscixuO3JldHVybiBlLmdldFBhcnNlcj1mdW5jdGlvbihlLHQpe2lmKHZvaWQgMD09PXQmJih0PSExKSxcInN0cmluZ1wiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJVc2VyQWdlbnQgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO3JldHVybiBuZXcgaS5kZWZhdWx0KGUsdCl9LGUucGFyc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBpLmRlZmF1bHQoZSkuZ2V0UmVzdWx0KCl9LHQ9ZSxuPVt7a2V5OlwiQlJPV1NFUl9NQVBcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5CUk9XU0VSX01BUH19LHtrZXk6XCJFTkdJTkVfTUFQXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuRU5HSU5FX01BUH19LHtrZXk6XCJPU19NQVBcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5PU19NQVB9fSx7a2V5OlwiUExBVEZPUk1TX01BUFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBzLlBMQVRGT1JNU19NQVB9fV0sKHI9bnVsbCkmJm8odC5wcm90b3R5cGUsciksbiYmbyh0LG4pLGV9KCk7dC5kZWZhdWx0PWEsZS5leHBvcnRzPXQuZGVmYXVsdH0sOTE6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuPXUocig5MikpLGk9dShyKDkzKSkscz11KHIoOTQpKSxvPXUocig5NSkpLGE9dShyKDE3KSk7ZnVuY3Rpb24gdShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19dmFyIGQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9ITEpLG51bGw9PWV8fFwiXCI9PT1lKXRocm93IG5ldyBFcnJvcihcIlVzZXJBZ2VudCBwYXJhbWV0ZXIgY2FuJ3QgYmUgZW1wdHlcIik7dGhpcy5fdWE9ZSx0aGlzLnBhcnNlZFJlc3VsdD17fSwhMCE9PXQmJnRoaXMucGFyc2UoKX12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5nZXRVQT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl91YX0sdC50ZXN0PWZ1bmN0aW9uKGUpe3JldHVybiBlLnRlc3QodGhpcy5fdWEpfSx0LnBhcnNlQnJvd3Nlcj1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcj17fTt2YXIgdD1hLmRlZmF1bHQuZmluZChuLmRlZmF1bHQsKGZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGVzdClyZXR1cm4gdC50ZXN0KGUpO2lmKHQudGVzdCBpbnN0YW5jZW9mIEFycmF5KXJldHVybiB0LnRlc3Quc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIGUudGVzdCh0KX0pKTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyJ3MgdGVzdCBmdW5jdGlvbiBpcyBub3QgdmFsaWRcIil9KSk7cmV0dXJuIHQmJih0aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyPXQuZGVzY3JpYmUodGhpcy5nZXRVQSgpKSksdGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcn0sdC5nZXRCcm93c2VyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyc2VkUmVzdWx0LmJyb3dzZXI/dGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcjp0aGlzLnBhcnNlQnJvd3NlcigpfSx0LmdldEJyb3dzZXJOYW1lPWZ1bmN0aW9uKGUpe3JldHVybiBlP1N0cmluZyh0aGlzLmdldEJyb3dzZXIoKS5uYW1lKS50b0xvd2VyQ2FzZSgpfHxcIlwiOnRoaXMuZ2V0QnJvd3NlcigpLm5hbWV8fFwiXCJ9LHQuZ2V0QnJvd3NlclZlcnNpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRCcm93c2VyKCkudmVyc2lvbn0sdC5nZXRPUz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlZFJlc3VsdC5vcz90aGlzLnBhcnNlZFJlc3VsdC5vczp0aGlzLnBhcnNlT1MoKX0sdC5wYXJzZU9TPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnBhcnNlZFJlc3VsdC5vcz17fTt2YXIgdD1hLmRlZmF1bHQuZmluZChpLmRlZmF1bHQsKGZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGVzdClyZXR1cm4gdC50ZXN0KGUpO2lmKHQudGVzdCBpbnN0YW5jZW9mIEFycmF5KXJldHVybiB0LnRlc3Quc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIGUudGVzdCh0KX0pKTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyJ3MgdGVzdCBmdW5jdGlvbiBpcyBub3QgdmFsaWRcIil9KSk7cmV0dXJuIHQmJih0aGlzLnBhcnNlZFJlc3VsdC5vcz10LmRlc2NyaWJlKHRoaXMuZ2V0VUEoKSkpLHRoaXMucGFyc2VkUmVzdWx0Lm9zfSx0LmdldE9TTmFtZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmdldE9TKCkubmFtZTtyZXR1cm4gZT9TdHJpbmcodCkudG9Mb3dlckNhc2UoKXx8XCJcIjp0fHxcIlwifSx0LmdldE9TVmVyc2lvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldE9TKCkudmVyc2lvbn0sdC5nZXRQbGF0Zm9ybT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybT90aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybTp0aGlzLnBhcnNlUGxhdGZvcm0oKX0sdC5nZXRQbGF0Zm9ybVR5cGU9ZnVuY3Rpb24oZSl7dm9pZCAwPT09ZSYmKGU9ITEpO3ZhciB0PXRoaXMuZ2V0UGxhdGZvcm0oKS50eXBlO3JldHVybiBlP1N0cmluZyh0KS50b0xvd2VyQ2FzZSgpfHxcIlwiOnR8fFwiXCJ9LHQucGFyc2VQbGF0Zm9ybT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm09e307dmFyIHQ9YS5kZWZhdWx0LmZpbmQocy5kZWZhdWx0LChmdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRlc3QpcmV0dXJuIHQudGVzdChlKTtpZih0LnRlc3QgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm4gdC50ZXN0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnRlc3QodCl9KSk7dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpfSkpO3JldHVybiB0JiYodGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm09dC5kZXNjcmliZSh0aGlzLmdldFVBKCkpKSx0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybX0sdC5nZXRFbmdpbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lP3RoaXMucGFyc2VkUmVzdWx0LmVuZ2luZTp0aGlzLnBhcnNlRW5naW5lKCl9LHQuZ2V0RW5naW5lTmFtZT1mdW5jdGlvbihlKXtyZXR1cm4gZT9TdHJpbmcodGhpcy5nZXRFbmdpbmUoKS5uYW1lKS50b0xvd2VyQ2FzZSgpfHxcIlwiOnRoaXMuZ2V0RW5naW5lKCkubmFtZXx8XCJcIn0sdC5wYXJzZUVuZ2luZT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lPXt9O3ZhciB0PWEuZGVmYXVsdC5maW5kKG8uZGVmYXVsdCwoZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC50ZXN0KXJldHVybiB0LnRlc3QoZSk7aWYodC50ZXN0IGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuIHQudGVzdC5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gZS50ZXN0KHQpfSkpO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXIncyB0ZXN0IGZ1bmN0aW9uIGlzIG5vdCB2YWxpZFwiKX0pKTtyZXR1cm4gdCYmKHRoaXMucGFyc2VkUmVzdWx0LmVuZ2luZT10LmRlc2NyaWJlKHRoaXMuZ2V0VUEoKSkpLHRoaXMucGFyc2VkUmVzdWx0LmVuZ2luZX0sdC5wYXJzZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlQnJvd3NlcigpLHRoaXMucGFyc2VPUygpLHRoaXMucGFyc2VQbGF0Zm9ybSgpLHRoaXMucGFyc2VFbmdpbmUoKSx0aGlzfSx0LmdldFJlc3VsdD1mdW5jdGlvbigpe3JldHVybiBhLmRlZmF1bHQuYXNzaWduKHt9LHRoaXMucGFyc2VkUmVzdWx0KX0sdC5zYXRpc2ZpZXM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPXt9LG49MCxpPXt9LHM9MDtpZihPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbz1lW3RdO1wic3RyaW5nXCI9PXR5cGVvZiBvPyhpW3RdPW8scys9MSk6XCJvYmplY3RcIj09dHlwZW9mIG8mJihyW3RdPW8sbis9MSl9KSksbj4wKXt2YXIgbz1PYmplY3Qua2V5cyhyKSx1PWEuZGVmYXVsdC5maW5kKG8sKGZ1bmN0aW9uKGUpe3JldHVybiB0LmlzT1MoZSl9KSk7aWYodSl7dmFyIGQ9dGhpcy5zYXRpc2ZpZXMoclt1XSk7aWYodm9pZCAwIT09ZClyZXR1cm4gZH12YXIgYz1hLmRlZmF1bHQuZmluZChvLChmdW5jdGlvbihlKXtyZXR1cm4gdC5pc1BsYXRmb3JtKGUpfSkpO2lmKGMpe3ZhciBmPXRoaXMuc2F0aXNmaWVzKHJbY10pO2lmKHZvaWQgMCE9PWYpcmV0dXJuIGZ9fWlmKHM+MCl7dmFyIGw9T2JqZWN0LmtleXMoaSksaD1hLmRlZmF1bHQuZmluZChsLChmdW5jdGlvbihlKXtyZXR1cm4gdC5pc0Jyb3dzZXIoZSwhMCl9KSk7aWYodm9pZCAwIT09aClyZXR1cm4gdGhpcy5jb21wYXJlVmVyc2lvbihpW2hdKX19LHQuaXNCcm93c2VyPWZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9ITEpO3ZhciByPXRoaXMuZ2V0QnJvd3Nlck5hbWUoKS50b0xvd2VyQ2FzZSgpLG49ZS50b0xvd2VyQ2FzZSgpLGk9YS5kZWZhdWx0LmdldEJyb3dzZXJUeXBlQnlBbGlhcyhuKTtyZXR1cm4gdCYmaSYmKG49aS50b0xvd2VyQ2FzZSgpKSxuPT09cn0sdC5jb21wYXJlVmVyc2lvbj1mdW5jdGlvbihlKXt2YXIgdD1bMF0scj1lLG49ITEsaT10aGlzLmdldEJyb3dzZXJWZXJzaW9uKCk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGkpcmV0dXJuXCI+XCI9PT1lWzBdfHxcIjxcIj09PWVbMF0/KHI9ZS5zdWJzdHIoMSksXCI9XCI9PT1lWzFdPyhuPSEwLHI9ZS5zdWJzdHIoMikpOnQ9W10sXCI+XCI9PT1lWzBdP3QucHVzaCgxKTp0LnB1c2goLTEpKTpcIj1cIj09PWVbMF0/cj1lLnN1YnN0cigxKTpcIn5cIj09PWVbMF0mJihuPSEwLHI9ZS5zdWJzdHIoMSkpLHQuaW5kZXhPZihhLmRlZmF1bHQuY29tcGFyZVZlcnNpb25zKGkscixuKSk+LTF9LHQuaXNPUz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nZXRPU05hbWUoITApPT09U3RyaW5nKGUpLnRvTG93ZXJDYXNlKCl9LHQuaXNQbGF0Zm9ybT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nZXRQbGF0Zm9ybVR5cGUoITApPT09U3RyaW5nKGUpLnRvTG93ZXJDYXNlKCl9LHQuaXNFbmdpbmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZ2V0RW5naW5lTmFtZSghMCk9PT1TdHJpbmcoZSkudG9Mb3dlckNhc2UoKX0sdC5pcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5pc0Jyb3dzZXIoZSl8fHRoaXMuaXNPUyhlKXx8dGhpcy5pc1BsYXRmb3JtKGUpfSx0LnNvbWU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdm9pZCAwPT09ZSYmKGU9W10pLGUuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIHQuaXMoZSl9KSl9LGV9KCk7dC5kZWZhdWx0PWQsZS5leHBvcnRzPXQuZGVmYXVsdH0sOTI6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGk9KG49cigxNykpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTt2YXIgcz0vdmVyc2lvblxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxvPVt7dGVzdDpbL2dvb2dsZWJvdC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkdvb2dsZWJvdFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9nb29nbGVib3RcXC8oXFxkKyhcXC5cXGQrKSkvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9vcGVyYS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk9wZXJhXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Om9wZXJhKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9vcHJcXC98b3Bpb3MvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJPcGVyYVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpvcHJ8b3Bpb3MpW1xccy9dKFxcUyspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvU2Ftc3VuZ0Jyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OlNhbXN1bmdCcm93c2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9XaGFsZS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk5BVkVSIFdoYWxlIEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86d2hhbGUpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvTVpCcm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTVogQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpNWkJyb3dzZXIpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvZm9jdXMvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJGb2N1c1wifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpmb2N1cylbXFxzL10oXFxkKyg/OlxcLlxcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zd2luZy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlN3aW5nXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnN3aW5nKVtcXHMvXShcXGQrKD86XFwuXFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2NvYXN0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiT3BlcmEgQ29hc3RcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86Y29hc3QpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3lhYnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIllhbmRleCBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnlhYnJvd3NlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvdWNicm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiVUMgQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzp1Y2Jyb3dzZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL01heHRob258bXhpb3MvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNYXh0aG9uXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Ok1heHRob258bXhpb3MpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2VwaXBoYW55L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiRXBpcGhhbnlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86ZXBpcGhhbnkpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3B1ZmZpbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlB1ZmZpblwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpwdWZmaW4pW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NsZWlwbmlyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2xlaXBuaXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86c2xlaXBuaXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2stbWVsZW9uL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiSy1NZWxlb25cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86ay1tZWxlb24pW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL21pY3JvbWVzc2VuZ2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiV2VDaGF0XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Om1pY3JvbWVzc2VuZ2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9xcWJyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6L3FxYnJvd3NlcmxpdGUvaS50ZXN0KGUpP1wiUVEgQnJvd3NlciBMaXRlXCI6XCJRUSBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnFxYnJvd3NlcmxpdGV8cXFicm93c2VyKVsvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9tc2llfHRyaWRlbnQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJJbnRlcm5ldCBFeHBsb3JlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzptc2llIHxydjopKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL1xcc2VkZ1xcLy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk1pY3Jvc29mdCBFZGdlXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1xcc2VkZ1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9lZGcoW2VhXXxpb3MpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTWljcm9zb2Z0IEVkZ2VcIn0scj1pLmRlZmF1bHQuZ2V0U2Vjb25kTWF0Y2goL2VkZyhbZWFdfGlvcylcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvdml2YWxkaS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlZpdmFsZGlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdml2YWxkaVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zZWFtb25rZXkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTZWFNb25rZXlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2VhbW9ua2V5XFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NhaWxmaXNoL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2FpbGZpc2hcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2FpbGZpc2hcXHM/YnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zaWxrL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQW1hem9uIFNpbGtcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2lsa1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9waGFudG9tL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiUGhhbnRvbUpTXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3BoYW50b21qc1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zbGltZXJqcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNsaW1lckpTXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3NsaW1lcmpzXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2JsYWNrYmVycnl8XFxiYmJcXGQrL2ksL3JpbVxcc3RhYmxldC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkJsYWNrQmVycnlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvYmxhY2tiZXJyeVtcXGRdK1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy8od2VifGhwdylbbzBdcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIldlYk9TIEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdyg/OmViKT9bbzBdc2Jyb3dzZXJcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvYmFkYS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkJhZGFcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvZG9sZmluXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3RpemVuL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiVGl6ZW5cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86dGl6ZW5cXHM/KT9icm93c2VyXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3F1cHppbGxhL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiUXVwWmlsbGFcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86cXVwemlsbGEpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiRmlyZWZveFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpmaXJlZm94fGljZXdlYXNlbHxmeGlvcylbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvZWxlY3Ryb24vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJFbGVjdHJvblwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzplbGVjdHJvbilcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvY2hyb21pdW0vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJDaHJvbWl1bVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWl1bSlbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvY2hyb21lfGNyaW9zfGNybW8vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJDaHJvbWVcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21lfGNyaW9zfGNybW8pXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL0dTQS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkdvb2dsZSBTZWFyY2hcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86R1NBKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9IWUudGVzdCgvbGlrZSBhbmRyb2lkL2kpLHI9ZS50ZXN0KC9hbmRyb2lkL2kpO3JldHVybiB0JiZyfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkFuZHJvaWQgQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvcGxheXN0YXRpb24gNC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlBsYXlTdGF0aW9uIDRcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NhZmFyaXxhcHBsZXdlYmtpdC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNhZmFyaVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvLiovaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9LTEhPT1lLnNlYXJjaChcIlxcXFwoXCIpPy9eKC4qKVxcLyguKilbIFxcdF1cXCgoLiopLzovXiguKilcXC8oLiopIC87cmV0dXJue25hbWU6aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2godCxlKSx2ZXJzaW9uOmkuZGVmYXVsdC5nZXRTZWNvbmRNYXRjaCh0LGUpfX19XTt0LmRlZmF1bHQ9byxlLmV4cG9ydHM9dC5kZWZhdWx0fSw5MzpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG4saT0obj1yKDE3KSkmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59LHM9cigxOCk7dmFyIG89W3t0ZXN0OlsvUm9rdVxcL0RWUC9dLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9Sb2t1XFwvRFZQLShcXGQrXFwuXFxkKykvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5Sb2t1LHZlcnNpb246dH19fSx7dGVzdDpbL3dpbmRvd3MgcGhvbmUvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3dpbmRvd3MgcGhvbmUgKD86b3MpP1xccz8oXFxkKyhcXC5cXGQrKSopL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuV2luZG93c1Bob25lLHZlcnNpb246dH19fSx7dGVzdDpbL3dpbmRvd3MgL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9XaW5kb3dzICgoTlR8WFApKCBcXGRcXGQ/LlxcZCk/KS9pLGUpLHI9aS5kZWZhdWx0LmdldFdpbmRvd3NWZXJzaW9uTmFtZSh0KTtyZXR1cm57bmFtZTpzLk9TX01BUC5XaW5kb3dzLHZlcnNpb246dCx2ZXJzaW9uTmFtZTpyfX19LHt0ZXN0OlsvTWFjaW50b3NoKC4qPykgRnhpT1MoLio/KSBWZXJzaW9uXFwvL10sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldFNlY29uZE1hdGNoKC8oVmVyc2lvblxcLykoXFxkW1xcZC5dKykvLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLmlPUyx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy9tYWNpbnRvc2gvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL21hYyBvcyB4IChcXGQrKFxcLj9fP1xcZCspKykvaSxlKS5yZXBsYWNlKC9bX1xcc10vZyxcIi5cIikscj1pLmRlZmF1bHQuZ2V0TWFjT1NWZXJzaW9uTmFtZSh0KSxuPXtuYW1lOnMuT1NfTUFQLk1hY09TLHZlcnNpb246dH07cmV0dXJuIHImJihuLnZlcnNpb25OYW1lPXIpLG59fSx7dGVzdDpbLyhpcG9kfGlwaG9uZXxpcGFkKS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvb3MgKFxcZCsoW19cXHNdXFxkKykqKSBsaWtlIG1hYyBvcyB4L2ksZSkucmVwbGFjZSgvW19cXHNdL2csXCIuXCIpO3JldHVybntuYW1lOnMuT1NfTUFQLmlPUyx2ZXJzaW9uOnR9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9IWUudGVzdCgvbGlrZSBhbmRyb2lkL2kpLHI9ZS50ZXN0KC9hbmRyb2lkL2kpO3JldHVybiB0JiZyfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvYW5kcm9pZFtcXHMvLV0oXFxkKyhcXC5cXGQrKSopL2ksZSkscj1pLmRlZmF1bHQuZ2V0QW5kcm9pZFZlcnNpb25OYW1lKHQpLG49e25hbWU6cy5PU19NQVAuQW5kcm9pZCx2ZXJzaW9uOnR9O3JldHVybiByJiYobi52ZXJzaW9uTmFtZT1yKSxufX0se3Rlc3Q6Wy8od2VifGhwdylbbzBdcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86d2VifGhwdylbbzBdc1xcLyhcXGQrKFxcLlxcZCspKikvaSxlKSxyPXtuYW1lOnMuT1NfTUFQLldlYk9TfTtyZXR1cm4gdCYmdC5sZW5ndGgmJihyLnZlcnNpb249dCkscn19LHt0ZXN0OlsvYmxhY2tiZXJyeXxcXGJiYlxcZCsvaSwvcmltXFxzdGFibGV0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9yaW1cXHN0YWJsZXRcXHNvc1xccyhcXGQrKFxcLlxcZCspKikvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2JsYWNrYmVycnlcXGQrXFwvKFxcZCsoW19cXHNdXFxkKykqKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvXFxiYmIoXFxkKykvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5CbGFja0JlcnJ5LHZlcnNpb246dH19fSx7dGVzdDpbL2JhZGEvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2JhZGFcXC8oXFxkKyhcXC5cXGQrKSopL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuQmFkYSx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy90aXplbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdGl6ZW5bL1xcc10oXFxkKyhcXC5cXGQrKSopL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuVGl6ZW4sdmVyc2lvbjp0fX19LHt0ZXN0OlsvbGludXgvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57bmFtZTpzLk9TX01BUC5MaW51eH19fSx7dGVzdDpbL0NyT1MvXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybntuYW1lOnMuT1NfTUFQLkNocm9tZU9TfX19LHt0ZXN0OlsvUGxheVN0YXRpb24gNC9dLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9QbGF5U3RhdGlvbiA0Wy9cXHNdKFxcZCsoXFwuXFxkKykqKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLlBsYXlTdGF0aW9uNCx2ZXJzaW9uOnR9fX1dO3QuZGVmYXVsdD1vLGUuZXhwb3J0cz10LmRlZmF1bHR9LDk0OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoMTcpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTt2YXIgbz1be3Rlc3Q6Wy9nb29nbGVib3QvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcImJvdFwiLHZlbmRvcjpcIkdvb2dsZVwifX19LHt0ZXN0OlsvaHVhd2VpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oY2FuLWwwMSkvaSxlKSYmXCJOb3ZhXCIscj17dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIkh1YXdlaVwifTtyZXR1cm4gdCYmKHIubW9kZWw9dCkscn19LHt0ZXN0OlsvbmV4dXNcXHMqKD86N3w4fDl8MTApLiovaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIk5leHVzXCJ9fX0se3Rlc3Q6Wy9pcGFkL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJBcHBsZVwiLG1vZGVsOlwiaVBhZFwifX19LHt0ZXN0OlsvTWFjaW50b3NoKC4qPykgRnhpT1MoLio/KSBWZXJzaW9uXFwvL10sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIkFwcGxlXCIsbW9kZWw6XCJpUGFkXCJ9fX0se3Rlc3Q6Wy9rZnR0IGJ1aWxkL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJBbWF6b25cIixtb2RlbDpcIktpbmRsZSBGaXJlIEhEIDdcIn19fSx7dGVzdDpbL3NpbGsvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIkFtYXpvblwifX19LHt0ZXN0OlsvdGFibGV0KD8hIHBjKS9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXR9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50ZXN0KC9pcG9kfGlwaG9uZS9pKSxyPWUudGVzdCgvbGlrZSAoaXBvZHxpcGhvbmUpL2kpO3JldHVybiB0JiYhcn0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyhpcG9kfGlwaG9uZSkvaSxlKTtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIkFwcGxlXCIsbW9kZWw6dH19fSx7dGVzdDpbL25leHVzXFxzKlswLTZdLiovaSwvZ2FsYXh5IG5leHVzL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZSx2ZW5kb3I6XCJOZXh1c1wifX19LHt0ZXN0OlsvW14tXW1vYmkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlfX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwiYmxhY2tiZXJyeVwiPT09ZS5nZXRCcm93c2VyTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZSx2ZW5kb3I6XCJCbGFja0JlcnJ5XCJ9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJiYWRhXCI9PT1lLmdldEJyb3dzZXJOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlfX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwid2luZG93cyBwaG9uZVwiPT09ZS5nZXRCcm93c2VyTmFtZSgpfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGUsdmVuZG9yOlwiTWljcm9zb2Z0XCJ9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9TnVtYmVyKFN0cmluZyhlLmdldE9TVmVyc2lvbigpKS5zcGxpdChcIi5cIilbMF0pO3JldHVyblwiYW5kcm9pZFwiPT09ZS5nZXRPU05hbWUoITApJiZ0Pj0zfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXR9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJhbmRyb2lkXCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZX19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cIm1hY29zXCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLmRlc2t0b3AsdmVuZG9yOlwiQXBwbGVcIn19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cIndpbmRvd3NcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAuZGVza3RvcH19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cImxpbnV4XCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLmRlc2t0b3B9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJwbGF5c3RhdGlvbiA0XCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnR2fX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwicm9rdVwiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50dn19fV07dC5kZWZhdWx0PW8sZS5leHBvcnRzPXQuZGVmYXVsdH0sOTU6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGk9KG49cigxNykpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSxzPXIoMTgpO3ZhciBvPVt7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cIm1pY3Jvc29mdCBlZGdlXCI9PT1lLmdldEJyb3dzZXJOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7aWYoL1xcc2VkZ1xcLy9pLnRlc3QoZSkpcmV0dXJue25hbWU6cy5FTkdJTkVfTUFQLkJsaW5rfTt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvZWRnZVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm57bmFtZTpzLkVOR0lORV9NQVAuRWRnZUhUTUwsdmVyc2lvbjp0fX19LHt0ZXN0OlsvdHJpZGVudC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLkVOR0lORV9NQVAuVHJpZGVudH0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdHJpZGVudFxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudGVzdCgvcHJlc3RvL2kpfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLkVOR0lORV9NQVAuUHJlc3RvfSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9wcmVzdG9cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PWUudGVzdCgvZ2Vja28vaSkscj1lLnRlc3QoL2xpa2UgZ2Vja28vaSk7cmV0dXJuIHQmJiFyfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLkVOR0lORV9NQVAuR2Vja299LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2dlY2tvXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbLyhhcHBsZSk/d2Via2l0XFwvNTM3XFwuMzYvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57bmFtZTpzLkVOR0lORV9NQVAuQmxpbmt9fX0se3Rlc3Q6Wy8oYXBwbGUpP3dlYmtpdC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLkVOR0lORV9NQVAuV2ViS2l0fSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC93ZWJraXRcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19XTt0LmRlZmF1bHQ9byxlLmV4cG9ydHM9dC5kZWZhdWx0fX0pfSkpOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bowser/es5.js\n");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanM/MzRlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICcjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJyxcbiAgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLFxuICAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsXG4gICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJyxcbiAgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLFxuICAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsXG4gICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JyxcbiAgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLFxuICAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsXG4gICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJyxcbiAgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "./node_modules/debug/src/debug.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/debug.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcz85NmZlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0cy5pbnN0YW5jZXMgPSBbXTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgdmFyIHByZXZUaW1lO1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICBleHBvcnRzLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuICByZXR1cm4gZGVidWc7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICB2YXIgaW5kZXggPSBleHBvcnRzLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgZXhwb3J0cy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgaTtcbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cG9ydHMuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZXhwb3J0cy5pbnN0YW5jZXNbaV07XG4gICAgaW5zdGFuY2UuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/debug/src/debug.js\n");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3J4X3NvY2tldGlvX2NsaWVudC8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzP2ZhYTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/events/events.js\n");

/***/ }),

/***/ "./node_modules/h264-profile-level-id/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/h264-profile-level-id/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/h264-profile-level-id/node_modules/debug/src/browser.js\")('h264-profile-level-id');\n\n/* eslint-disable no-console */\ndebug.log = console.info.bind(console);\n/* eslint-enable no-console */\n\nconst ProfileConstrainedBaseline = 1;\nconst ProfileBaseline = 2;\nconst ProfileMain = 3;\nconst ProfileConstrainedHigh = 4;\nconst ProfileHigh = 5;\n\nexports.ProfileConstrainedBaseline = ProfileConstrainedBaseline;\nexports.ProfileBaseline = ProfileBaseline;\nexports.ProfileMain = ProfileMain;\nexports.ProfileConstrainedHigh = ProfileConstrainedHigh;\nexports.ProfileHigh = ProfileHigh;\n\n// All values are equal to ten times the level number, except level 1b which is\n// special.\nconst Level1_b = 0;\nconst Level1 = 10;\nconst Level1_1 = 11;\nconst Level1_2 = 12;\nconst Level1_3 = 13;\nconst Level2 = 20;\nconst Level2_1 = 21;\nconst Level2_2 = 22;\nconst Level3 = 30;\nconst Level3_1 = 31;\nconst Level3_2 = 32;\nconst Level4 = 40;\nconst Level4_1 = 41;\nconst Level4_2 = 42;\nconst Level5 = 50;\nconst Level5_1 = 51;\nconst Level5_2 = 52;\n\nexports.Level1_b = Level1_b;\nexports.Level1 = Level1;\nexports.Level1_1 = Level1_1;\nexports.Level1_2 = Level1_2;\nexports.Level1_3 = Level1_3;\nexports.Level2 = Level2;\nexports.Level2_1 = Level2_1;\nexports.Level2_2 = Level2_2;\nexports.Level3 = Level3;\nexports.Level3_1 = Level3_1;\nexports.Level3_2 = Level3_2;\nexports.Level4 = Level4;\nexports.Level4_1 = Level4_1;\nexports.Level4_2 = Level4_2;\nexports.Level5 = Level5;\nexports.Level5_1 = Level5_1;\nexports.Level5_2 = Level5_2;\n\nclass ProfileLevelId\n{\n\tconstructor(profile, level)\n\t{\n\t\tthis.profile = profile;\n\t\tthis.level = level;\n\t}\n}\n\nexports.ProfileLevelId = ProfileLevelId;\n\n// Default ProfileLevelId.\n//\n// TODO: The default should really be profile Baseline and level 1 according to\n// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not\n// break backwards compatibility with older versions of WebRTC where external\n// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1\n// instead. This workaround will only be done in an interim period to allow\n// external clients to update their code.\n//\n// http://crbug/webrtc/6337.\nconst DefaultProfileLevelId =\n\tnew ProfileLevelId(ProfileConstrainedBaseline, Level3_1);\n\n// For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3\n// flag specifies if level 1b or level 1.1 is used.\nconst ConstraintSet3Flag = 0x10;\n\n// Class for matching bit patterns such as \"x1xx0000\" where 'x' is allowed to be\n// either 0 or 1.\nclass BitPattern\n{\n\tconstructor(str)\n\t{\n\t\tthis._mask = ~byteMaskString('x', str);\n\t\tthis._maskedValue = byteMaskString('1', str);\n\t}\n\n\tisMatch(value)\n\t{\n\t\treturn this._maskedValue === (value & this._mask);\n\t}\n}\n\n// Class for converting between profile_idc/profile_iop to Profile.\nclass ProfilePattern\n{\n\tconstructor(profile_idc, profile_iop, profile)\n\t{\n\t\tthis.profile_idc = profile_idc;\n\t\tthis.profile_iop = profile_iop;\n\t\tthis.profile = profile;\n\t}\n}\n\n// This is from https://tools.ietf.org/html/rfc6184#section-8.1.\nconst ProfilePatterns =\n[\n\tnew ProfilePattern(0x42, new BitPattern('x1xx0000'), ProfileConstrainedBaseline),\n\tnew ProfilePattern(0x4D, new BitPattern('1xxx0000'), ProfileConstrainedBaseline),\n\tnew ProfilePattern(0x58, new BitPattern('11xx0000'), ProfileConstrainedBaseline),\n\tnew ProfilePattern(0x42, new BitPattern('x0xx0000'), ProfileBaseline),\n\tnew ProfilePattern(0x58, new BitPattern('10xx0000'), ProfileBaseline),\n\tnew ProfilePattern(0x4D, new BitPattern('0x0x0000'), ProfileMain),\n\tnew ProfilePattern(0x64, new BitPattern('00000000'), ProfileHigh),\n\tnew ProfilePattern(0x64, new BitPattern('00001100'), ProfileConstrainedHigh)\n];\n\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes.\n * Nothing will be returned if the string is not a recognized H264 profile\n * level id.\n *\n * @param {String} str - profile-level-id value as a string of 3 hex bytes.\n *\n * @returns {ProfileLevelId}\n */\nexports.parseProfileLevelId = function(str)\n{\n\t// The string should consist of 3 bytes in hexadecimal format.\n\tif (typeof str !== 'string' || str.length !== 6)\n\t\treturn null;\n\n\tconst profile_level_id_numeric = parseInt(str, 16);\n\n\tif (profile_level_id_numeric === 0)\n\t\treturn null;\n\n\t// Separate into three bytes.\n\tconst level_idc = profile_level_id_numeric & 0xFF;\n\tconst profile_iop = (profile_level_id_numeric >> 8) & 0xFF;\n\tconst profile_idc = (profile_level_id_numeric >> 16) & 0xFF;\n\n\t// Parse level based on level_idc and constraint set 3 flag.\n\tlet level;\n\n\tswitch (level_idc)\n\t{\n\t\tcase Level1_1:\n\t\t{\n\t\t\tlevel = (profile_iop & ConstraintSet3Flag) !== 0 ? Level1_b : Level1_1;\n\t\t\tbreak;\n\t\t}\n\t\tcase Level1:\n\t\tcase Level1_2:\n\t\tcase Level1_3:\n\t\tcase Level2:\n\t\tcase Level2_1:\n\t\tcase Level2_2:\n\t\tcase Level3:\n\t\tcase Level3_1:\n\t\tcase Level3_2:\n\t\tcase Level4:\n\t\tcase Level4_1:\n\t\tcase Level4_2:\n\t\tcase Level5:\n\t\tcase Level5_1:\n\t\tcase Level5_2:\n\t\t{\n\t\t\tlevel = level_idc;\n\t\t\tbreak;\n\t\t}\n\t\t// Unrecognized level_idc.\n\t\tdefault:\n\t\t{\n\t\t\tdebug('parseProfileLevelId() | unrecognized level_idc:%s', level_idc);\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// Parse profile_idc/profile_iop into a Profile enum.\n\tfor (const pattern of ProfilePatterns)\n\t{\n\t\tif (\n\t\t\tprofile_idc === pattern.profile_idc &&\n\t\t\tpattern.profile_iop.isMatch(profile_iop)\n\t\t)\n\t\t{\n\t\t\treturn new ProfileLevelId(pattern.profile, level);\n\t\t}\n\t}\n\n\tdebug('parseProfileLevelId() | unrecognized profile_idc/profile_iop combination');\n\n\treturn null;\n};\n\n/**\n * Returns canonical string representation as three hex bytes of the profile\n * level id, or returns nothing for invalid profile level ids.\n *\n * @param {ProfileLevelId} profile_level_id\n *\n * @returns {String}\n */\nexports.profileLevelIdToString = function(profile_level_id)\n{\n\t// Handle special case level == 1b.\n\tif (profile_level_id.level == Level1_b)\n\t{\n\t\tswitch (profile_level_id.profile)\n\t\t{\n\t\t\tcase ProfileConstrainedBaseline:\n\t\t\t{\n\t\t\t\treturn '42f00b';\n\t\t\t}\n\t\t\tcase ProfileBaseline:\n\t\t\t{\n\t\t\t\treturn '42100b';\n\t\t\t}\n\t\t\tcase ProfileMain:\n\t\t\t{\n\t\t\t\treturn '4d100b';\n\t\t\t}\n\t\t\t// Level 1_b is not allowed for other profiles.\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tdebug(\n\t\t\t\t\t'profileLevelIdToString() | Level 1_b not is allowed for profile:%s',\n\t\t\t\t\tprofile_level_id.profile);\n\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\tlet profile_idc_iop_string;\n\n\tswitch (profile_level_id.profile)\n\t{\n\t\tcase ProfileConstrainedBaseline:\n\t\t{\n\t\t\tprofile_idc_iop_string = '42e0';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileBaseline:\n\t\t{\n\t\t\tprofile_idc_iop_string = '4200';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileMain:\n\t\t{\n\t\t\tprofile_idc_iop_string = '4d00';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileConstrainedHigh:\n\t\t{\n\t\t\tprofile_idc_iop_string = '640c';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileHigh:\n\t\t{\n\t\t\tprofile_idc_iop_string = '6400';\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t{\n\t\t\tdebug(\n\t\t\t\t'profileLevelIdToString() | unrecognized profile:%s',\n\t\t\t\tprofile_level_id.profile);\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tlet levelStr = (profile_level_id.level).toString(16);\n\n\tif (levelStr.length === 1)\n\t\tlevelStr = `0${levelStr}`;\n\n\treturn `${profile_idc_iop_string}${levelStr}`;\n};\n\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes\n * contained in an SDP key-value map. A default profile level id will be\n * returned if the profile-level-id key is missing. Nothing will be returned if\n * the key is present but the string is invalid.\n *\n * @param {Object} [params={}] - Codec parameters object.\n *\n * @returns {ProfileLevelId}\n */\nexports.parseSdpProfileLevelId = function(params = {})\n{\n\tconst profile_level_id = params['profile-level-id'];\n\n\treturn !profile_level_id\n\t\t? DefaultProfileLevelId\n\t\t: exports.parseProfileLevelId(profile_level_id);\n};\n\n/**\n * Returns true if the parameters have the same H264 profile, i.e. the same\n * H264 profile (Baseline, High, etc).\n *\n * @param {Object} [params1={}] - Codec parameters object.\n * @param {Object} [params2={}] - Codec parameters object.\n *\n * @returns {Boolean}\n */\nexports.isSameProfile = function(params1 = {}, params2 = {})\n{\n\tconst profile_level_id_1 = exports.parseSdpProfileLevelId(params1);\n\tconst profile_level_id_2 = exports.parseSdpProfileLevelId(params2);\n\n\t// Compare H264 profiles, but not levels.\n\treturn Boolean(\n\t\tprofile_level_id_1 &&\n\t\tprofile_level_id_2 &&\n\t\tprofile_level_id_1.profile === profile_level_id_2.profile\n\t);\n};\n\n/**\n * Generate codec parameters that will be used as answer in an SDP negotiation\n * based on local supported parameters and remote offered parameters. Both\n * local_supported_params and remote_offered_params represent sendrecv media\n * descriptions, i.e they are a mix of both encode and decode capabilities. In\n * theory, when the profile in local_supported_params represent a strict superset\n * of the profile in remote_offered_params, we could limit the profile in the\n * answer to the profile in remote_offered_params.\n *\n * However, to simplify the code, each supported H264 profile should be listed\n * explicitly in the list of local supported codecs, even if they are redundant.\n * Then each local codec in the list should be tested one at a time against the\n * remote codec, and only when the profiles are equal should this function be\n * called. Therefore, this function does not need to handle profile intersection,\n * and the profile of local_supported_params and remote_offered_params must be\n * equal before calling this function. The parameters that are used when\n * negotiating are the level part of profile-level-id and level-asymmetry-allowed.\n *\n * @param {Object} [local_supported_params={}]\n * @param {Object} [remote_offered_params={}]\n *\n * @returns {String} Canonical string representation as three hex bytes of the\n *   profile level id, or null if no one of the params have profile-level-id.\n *\n * @throws {TypeError} If Profile mismatch or invalid params.\n */\nexports.generateProfileLevelIdForAnswer = function(\n\tlocal_supported_params = {},\n\tremote_offered_params = {}\n)\n{\n\t// If both local and remote params do not contain profile-level-id, they are\n\t// both using the default profile. In this case, don't return anything.\n\tif (\n\t\t!local_supported_params['profile-level-id'] &&\n\t\t!remote_offered_params['profile-level-id']\n\t)\n\t{\n\t\tdebug(\n\t\t\t'generateProfileLevelIdForAnswer() | no profile-level-id in local and remote params');\n\n\t\treturn null;\n\t}\n\n\t// Parse profile-level-ids.\n\tconst local_profile_level_id =\n\t\texports.parseSdpProfileLevelId(local_supported_params);\n\tconst remote_profile_level_id =\n\t\texports.parseSdpProfileLevelId(remote_offered_params);\n\n\t// The local and remote codec must have valid and equal H264 Profiles.\n\tif (!local_profile_level_id)\n\t\tthrow new TypeError('invalid local_profile_level_id');\n\n\tif (!remote_profile_level_id)\n\t\tthrow new TypeError('invalid remote_profile_level_id');\n\n\tif (local_profile_level_id.profile !== remote_profile_level_id.profile)\n\t\tthrow new TypeError('H264 Profile mismatch');\n\n\t// Parse level information.\n\tconst level_asymmetry_allowed = (\n\t\tisLevelAsymmetryAllowed(local_supported_params) &&\n\t\tisLevelAsymmetryAllowed(remote_offered_params)\n\t);\n\n\tconst local_level = local_profile_level_id.level;\n\tconst remote_level = remote_profile_level_id.level;\n\tconst min_level = minLevel(local_level, remote_level);\n\n\t// Determine answer level. When level asymmetry is not allowed, level upgrade\n\t// is not allowed, i.e., the level in the answer must be equal to or lower\n\t// than the level in the offer.\n\tconst answer_level = level_asymmetry_allowed ? local_level : min_level;\n\n\tdebug(\n\t\t'generateProfileLevelIdForAnswer() | result: [profile:%s, level:%s]',\n\t\tlocal_profile_level_id.profile, answer_level);\n\n\t// Return the resulting profile-level-id for the answer parameters.\n\treturn exports.profileLevelIdToString(\n\t\tnew ProfileLevelId(local_profile_level_id.profile, answer_level));\n};\n\n// Convert a string of 8 characters into a byte where the positions containing\n// character c will have their bit set. For example, c = 'x', str = \"x1xx0000\"\n// will return 0b10110000.\nfunction byteMaskString(c, str)\n{\n\treturn (\n\t\t((str[0] === c) << 7) | ((str[1] === c) << 6) | ((str[2] === c) << 5) |\n\t\t((str[3] === c) << 4)\t| ((str[4] === c) << 3)\t| ((str[5] === c) << 2)\t|\n\t\t((str[6] === c) << 1)\t| ((str[7] === c) << 0)\n\t);\n}\n\n// Compare H264 levels and handle the level 1b case.\nfunction isLessLevel(a, b)\n{\n\tif (a === Level1_b)\n\t\treturn b !== Level1 && b !== Level1_b;\n\n\tif (b === Level1_b)\n\t\treturn a !== Level1;\n\n\treturn a < b;\n}\n\nfunction minLevel(a, b)\n{\n\treturn isLessLevel(a, b) ? a : b;\n}\n\nfunction isLevelAsymmetryAllowed(params = {})\n{\n\tconst level_asymmetry_allowed = params['level-asymmetry-allowed'];\n\n\treturn (\n\t\tlevel_asymmetry_allowed === 1 ||\n\t\tlevel_asymmetry_allowed === '1'\n\t);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaDI2NC1wcm9maWxlLWxldmVsLWlkL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2gyNjQtcHJvZmlsZS1sZXZlbC1pZC9pbmRleC5qcz85ZWI3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnaDI2NC1wcm9maWxlLWxldmVsLWlkJyk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbmRlYnVnLmxvZyA9IGNvbnNvbGUuaW5mby5iaW5kKGNvbnNvbGUpO1xuLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cbmNvbnN0IFByb2ZpbGVDb25zdHJhaW5lZEJhc2VsaW5lID0gMTtcbmNvbnN0IFByb2ZpbGVCYXNlbGluZSA9IDI7XG5jb25zdCBQcm9maWxlTWFpbiA9IDM7XG5jb25zdCBQcm9maWxlQ29uc3RyYWluZWRIaWdoID0gNDtcbmNvbnN0IFByb2ZpbGVIaWdoID0gNTtcblxuZXhwb3J0cy5Qcm9maWxlQ29uc3RyYWluZWRCYXNlbGluZSA9IFByb2ZpbGVDb25zdHJhaW5lZEJhc2VsaW5lO1xuZXhwb3J0cy5Qcm9maWxlQmFzZWxpbmUgPSBQcm9maWxlQmFzZWxpbmU7XG5leHBvcnRzLlByb2ZpbGVNYWluID0gUHJvZmlsZU1haW47XG5leHBvcnRzLlByb2ZpbGVDb25zdHJhaW5lZEhpZ2ggPSBQcm9maWxlQ29uc3RyYWluZWRIaWdoO1xuZXhwb3J0cy5Qcm9maWxlSGlnaCA9IFByb2ZpbGVIaWdoO1xuXG4vLyBBbGwgdmFsdWVzIGFyZSBlcXVhbCB0byB0ZW4gdGltZXMgdGhlIGxldmVsIG51bWJlciwgZXhjZXB0IGxldmVsIDFiIHdoaWNoIGlzXG4vLyBzcGVjaWFsLlxuY29uc3QgTGV2ZWwxX2IgPSAwO1xuY29uc3QgTGV2ZWwxID0gMTA7XG5jb25zdCBMZXZlbDFfMSA9IDExO1xuY29uc3QgTGV2ZWwxXzIgPSAxMjtcbmNvbnN0IExldmVsMV8zID0gMTM7XG5jb25zdCBMZXZlbDIgPSAyMDtcbmNvbnN0IExldmVsMl8xID0gMjE7XG5jb25zdCBMZXZlbDJfMiA9IDIyO1xuY29uc3QgTGV2ZWwzID0gMzA7XG5jb25zdCBMZXZlbDNfMSA9IDMxO1xuY29uc3QgTGV2ZWwzXzIgPSAzMjtcbmNvbnN0IExldmVsNCA9IDQwO1xuY29uc3QgTGV2ZWw0XzEgPSA0MTtcbmNvbnN0IExldmVsNF8yID0gNDI7XG5jb25zdCBMZXZlbDUgPSA1MDtcbmNvbnN0IExldmVsNV8xID0gNTE7XG5jb25zdCBMZXZlbDVfMiA9IDUyO1xuXG5leHBvcnRzLkxldmVsMV9iID0gTGV2ZWwxX2I7XG5leHBvcnRzLkxldmVsMSA9IExldmVsMTtcbmV4cG9ydHMuTGV2ZWwxXzEgPSBMZXZlbDFfMTtcbmV4cG9ydHMuTGV2ZWwxXzIgPSBMZXZlbDFfMjtcbmV4cG9ydHMuTGV2ZWwxXzMgPSBMZXZlbDFfMztcbmV4cG9ydHMuTGV2ZWwyID0gTGV2ZWwyO1xuZXhwb3J0cy5MZXZlbDJfMSA9IExldmVsMl8xO1xuZXhwb3J0cy5MZXZlbDJfMiA9IExldmVsMl8yO1xuZXhwb3J0cy5MZXZlbDMgPSBMZXZlbDM7XG5leHBvcnRzLkxldmVsM18xID0gTGV2ZWwzXzE7XG5leHBvcnRzLkxldmVsM18yID0gTGV2ZWwzXzI7XG5leHBvcnRzLkxldmVsNCA9IExldmVsNDtcbmV4cG9ydHMuTGV2ZWw0XzEgPSBMZXZlbDRfMTtcbmV4cG9ydHMuTGV2ZWw0XzIgPSBMZXZlbDRfMjtcbmV4cG9ydHMuTGV2ZWw1ID0gTGV2ZWw1O1xuZXhwb3J0cy5MZXZlbDVfMSA9IExldmVsNV8xO1xuZXhwb3J0cy5MZXZlbDVfMiA9IExldmVsNV8yO1xuXG5jbGFzcyBQcm9maWxlTGV2ZWxJZFxue1xuXHRjb25zdHJ1Y3Rvcihwcm9maWxlLCBsZXZlbClcblx0e1xuXHRcdHRoaXMucHJvZmlsZSA9IHByb2ZpbGU7XG5cdFx0dGhpcy5sZXZlbCA9IGxldmVsO1xuXHR9XG59XG5cbmV4cG9ydHMuUHJvZmlsZUxldmVsSWQgPSBQcm9maWxlTGV2ZWxJZDtcblxuLy8gRGVmYXVsdCBQcm9maWxlTGV2ZWxJZC5cbi8vXG4vLyBUT0RPOiBUaGUgZGVmYXVsdCBzaG91bGQgcmVhbGx5IGJlIHByb2ZpbGUgQmFzZWxpbmUgYW5kIGxldmVsIDEgYWNjb3JkaW5nIHRvXG4vLyB0aGUgc3BlYzogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYxODQjc2VjdGlvbi04LjEuIEluIG9yZGVyIHRvIG5vdFxuLy8gYnJlYWsgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBXZWJSVEMgd2hlcmUgZXh0ZXJuYWxcbi8vIGNvZGVjcyBkb24ndCBoYXZlIGFueSBwYXJhbWV0ZXJzLCB1c2UgcHJvZmlsZSBDb25zdHJhaW5lZEJhc2VsaW5lIGxldmVsIDNfMVxuLy8gaW5zdGVhZC4gVGhpcyB3b3JrYXJvdW5kIHdpbGwgb25seSBiZSBkb25lIGluIGFuIGludGVyaW0gcGVyaW9kIHRvIGFsbG93XG4vLyBleHRlcm5hbCBjbGllbnRzIHRvIHVwZGF0ZSB0aGVpciBjb2RlLlxuLy9cbi8vIGh0dHA6Ly9jcmJ1Zy93ZWJydGMvNjMzNy5cbmNvbnN0IERlZmF1bHRQcm9maWxlTGV2ZWxJZCA9XG5cdG5ldyBQcm9maWxlTGV2ZWxJZChQcm9maWxlQ29uc3RyYWluZWRCYXNlbGluZSwgTGV2ZWwzXzEpO1xuXG4vLyBGb3IgbGV2ZWxfaWRjPTExIGFuZCBwcm9maWxlX2lkYz0weDQyLCAweDRELCBvciAweDU4LCB0aGUgY29uc3RyYWludCBzZXQzXG4vLyBmbGFnIHNwZWNpZmllcyBpZiBsZXZlbCAxYiBvciBsZXZlbCAxLjEgaXMgdXNlZC5cbmNvbnN0IENvbnN0cmFpbnRTZXQzRmxhZyA9IDB4MTA7XG5cbi8vIENsYXNzIGZvciBtYXRjaGluZyBiaXQgcGF0dGVybnMgc3VjaCBhcyBcIngxeHgwMDAwXCIgd2hlcmUgJ3gnIGlzIGFsbG93ZWQgdG8gYmVcbi8vIGVpdGhlciAwIG9yIDEuXG5jbGFzcyBCaXRQYXR0ZXJuXG57XG5cdGNvbnN0cnVjdG9yKHN0cilcblx0e1xuXHRcdHRoaXMuX21hc2sgPSB+Ynl0ZU1hc2tTdHJpbmcoJ3gnLCBzdHIpO1xuXHRcdHRoaXMuX21hc2tlZFZhbHVlID0gYnl0ZU1hc2tTdHJpbmcoJzEnLCBzdHIpO1xuXHR9XG5cblx0aXNNYXRjaCh2YWx1ZSlcblx0e1xuXHRcdHJldHVybiB0aGlzLl9tYXNrZWRWYWx1ZSA9PT0gKHZhbHVlICYgdGhpcy5fbWFzayk7XG5cdH1cbn1cblxuLy8gQ2xhc3MgZm9yIGNvbnZlcnRpbmcgYmV0d2VlbiBwcm9maWxlX2lkYy9wcm9maWxlX2lvcCB0byBQcm9maWxlLlxuY2xhc3MgUHJvZmlsZVBhdHRlcm5cbntcblx0Y29uc3RydWN0b3IocHJvZmlsZV9pZGMsIHByb2ZpbGVfaW9wLCBwcm9maWxlKVxuXHR7XG5cdFx0dGhpcy5wcm9maWxlX2lkYyA9IHByb2ZpbGVfaWRjO1xuXHRcdHRoaXMucHJvZmlsZV9pb3AgPSBwcm9maWxlX2lvcDtcblx0XHR0aGlzLnByb2ZpbGUgPSBwcm9maWxlO1xuXHR9XG59XG5cbi8vIFRoaXMgaXMgZnJvbSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjE4NCNzZWN0aW9uLTguMS5cbmNvbnN0IFByb2ZpbGVQYXR0ZXJucyA9XG5bXG5cdG5ldyBQcm9maWxlUGF0dGVybigweDQyLCBuZXcgQml0UGF0dGVybigneDF4eDAwMDAnKSwgUHJvZmlsZUNvbnN0cmFpbmVkQmFzZWxpbmUpLFxuXHRuZXcgUHJvZmlsZVBhdHRlcm4oMHg0RCwgbmV3IEJpdFBhdHRlcm4oJzF4eHgwMDAwJyksIFByb2ZpbGVDb25zdHJhaW5lZEJhc2VsaW5lKSxcblx0bmV3IFByb2ZpbGVQYXR0ZXJuKDB4NTgsIG5ldyBCaXRQYXR0ZXJuKCcxMXh4MDAwMCcpLCBQcm9maWxlQ29uc3RyYWluZWRCYXNlbGluZSksXG5cdG5ldyBQcm9maWxlUGF0dGVybigweDQyLCBuZXcgQml0UGF0dGVybigneDB4eDAwMDAnKSwgUHJvZmlsZUJhc2VsaW5lKSxcblx0bmV3IFByb2ZpbGVQYXR0ZXJuKDB4NTgsIG5ldyBCaXRQYXR0ZXJuKCcxMHh4MDAwMCcpLCBQcm9maWxlQmFzZWxpbmUpLFxuXHRuZXcgUHJvZmlsZVBhdHRlcm4oMHg0RCwgbmV3IEJpdFBhdHRlcm4oJzB4MHgwMDAwJyksIFByb2ZpbGVNYWluKSxcblx0bmV3IFByb2ZpbGVQYXR0ZXJuKDB4NjQsIG5ldyBCaXRQYXR0ZXJuKCcwMDAwMDAwMCcpLCBQcm9maWxlSGlnaCksXG5cdG5ldyBQcm9maWxlUGF0dGVybigweDY0LCBuZXcgQml0UGF0dGVybignMDAwMDExMDAnKSwgUHJvZmlsZUNvbnN0cmFpbmVkSGlnaClcbl07XG5cbi8qKlxuICogUGFyc2UgcHJvZmlsZSBsZXZlbCBpZCB0aGF0IGlzIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9mIDMgaGV4IGJ5dGVzLlxuICogTm90aGluZyB3aWxsIGJlIHJldHVybmVkIGlmIHRoZSBzdHJpbmcgaXMgbm90IGEgcmVjb2duaXplZCBIMjY0IHByb2ZpbGVcbiAqIGxldmVsIGlkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBwcm9maWxlLWxldmVsLWlkIHZhbHVlIGFzIGEgc3RyaW5nIG9mIDMgaGV4IGJ5dGVzLlxuICpcbiAqIEByZXR1cm5zIHtQcm9maWxlTGV2ZWxJZH1cbiAqL1xuZXhwb3J0cy5wYXJzZVByb2ZpbGVMZXZlbElkID0gZnVuY3Rpb24oc3RyKVxue1xuXHQvLyBUaGUgc3RyaW5nIHNob3VsZCBjb25zaXN0IG9mIDMgYnl0ZXMgaW4gaGV4YWRlY2ltYWwgZm9ybWF0LlxuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgfHwgc3RyLmxlbmd0aCAhPT0gNilcblx0XHRyZXR1cm4gbnVsbDtcblxuXHRjb25zdCBwcm9maWxlX2xldmVsX2lkX251bWVyaWMgPSBwYXJzZUludChzdHIsIDE2KTtcblxuXHRpZiAocHJvZmlsZV9sZXZlbF9pZF9udW1lcmljID09PSAwKVxuXHRcdHJldHVybiBudWxsO1xuXG5cdC8vIFNlcGFyYXRlIGludG8gdGhyZWUgYnl0ZXMuXG5cdGNvbnN0IGxldmVsX2lkYyA9IHByb2ZpbGVfbGV2ZWxfaWRfbnVtZXJpYyAmIDB4RkY7XG5cdGNvbnN0IHByb2ZpbGVfaW9wID0gKHByb2ZpbGVfbGV2ZWxfaWRfbnVtZXJpYyA+PiA4KSAmIDB4RkY7XG5cdGNvbnN0IHByb2ZpbGVfaWRjID0gKHByb2ZpbGVfbGV2ZWxfaWRfbnVtZXJpYyA+PiAxNikgJiAweEZGO1xuXG5cdC8vIFBhcnNlIGxldmVsIGJhc2VkIG9uIGxldmVsX2lkYyBhbmQgY29uc3RyYWludCBzZXQgMyBmbGFnLlxuXHRsZXQgbGV2ZWw7XG5cblx0c3dpdGNoIChsZXZlbF9pZGMpXG5cdHtcblx0XHRjYXNlIExldmVsMV8xOlxuXHRcdHtcblx0XHRcdGxldmVsID0gKHByb2ZpbGVfaW9wICYgQ29uc3RyYWludFNldDNGbGFnKSAhPT0gMCA/IExldmVsMV9iIDogTGV2ZWwxXzE7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Y2FzZSBMZXZlbDE6XG5cdFx0Y2FzZSBMZXZlbDFfMjpcblx0XHRjYXNlIExldmVsMV8zOlxuXHRcdGNhc2UgTGV2ZWwyOlxuXHRcdGNhc2UgTGV2ZWwyXzE6XG5cdFx0Y2FzZSBMZXZlbDJfMjpcblx0XHRjYXNlIExldmVsMzpcblx0XHRjYXNlIExldmVsM18xOlxuXHRcdGNhc2UgTGV2ZWwzXzI6XG5cdFx0Y2FzZSBMZXZlbDQ6XG5cdFx0Y2FzZSBMZXZlbDRfMTpcblx0XHRjYXNlIExldmVsNF8yOlxuXHRcdGNhc2UgTGV2ZWw1OlxuXHRcdGNhc2UgTGV2ZWw1XzE6XG5cdFx0Y2FzZSBMZXZlbDVfMjpcblx0XHR7XG5cdFx0XHRsZXZlbCA9IGxldmVsX2lkYztcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHQvLyBVbnJlY29nbml6ZWQgbGV2ZWxfaWRjLlxuXHRcdGRlZmF1bHQ6XG5cdFx0e1xuXHRcdFx0ZGVidWcoJ3BhcnNlUHJvZmlsZUxldmVsSWQoKSB8IHVucmVjb2duaXplZCBsZXZlbF9pZGM6JXMnLCBsZXZlbF9pZGMpO1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvLyBQYXJzZSBwcm9maWxlX2lkYy9wcm9maWxlX2lvcCBpbnRvIGEgUHJvZmlsZSBlbnVtLlxuXHRmb3IgKGNvbnN0IHBhdHRlcm4gb2YgUHJvZmlsZVBhdHRlcm5zKVxuXHR7XG5cdFx0aWYgKFxuXHRcdFx0cHJvZmlsZV9pZGMgPT09IHBhdHRlcm4ucHJvZmlsZV9pZGMgJiZcblx0XHRcdHBhdHRlcm4ucHJvZmlsZV9pb3AuaXNNYXRjaChwcm9maWxlX2lvcClcblx0XHQpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9maWxlTGV2ZWxJZChwYXR0ZXJuLnByb2ZpbGUsIGxldmVsKTtcblx0XHR9XG5cdH1cblxuXHRkZWJ1ZygncGFyc2VQcm9maWxlTGV2ZWxJZCgpIHwgdW5yZWNvZ25pemVkIHByb2ZpbGVfaWRjL3Byb2ZpbGVfaW9wIGNvbWJpbmF0aW9uJyk7XG5cblx0cmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgY2Fub25pY2FsIHN0cmluZyByZXByZXNlbnRhdGlvbiBhcyB0aHJlZSBoZXggYnl0ZXMgb2YgdGhlIHByb2ZpbGVcbiAqIGxldmVsIGlkLCBvciByZXR1cm5zIG5vdGhpbmcgZm9yIGludmFsaWQgcHJvZmlsZSBsZXZlbCBpZHMuXG4gKlxuICogQHBhcmFtIHtQcm9maWxlTGV2ZWxJZH0gcHJvZmlsZV9sZXZlbF9pZFxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMucHJvZmlsZUxldmVsSWRUb1N0cmluZyA9IGZ1bmN0aW9uKHByb2ZpbGVfbGV2ZWxfaWQpXG57XG5cdC8vIEhhbmRsZSBzcGVjaWFsIGNhc2UgbGV2ZWwgPT0gMWIuXG5cdGlmIChwcm9maWxlX2xldmVsX2lkLmxldmVsID09IExldmVsMV9iKVxuXHR7XG5cdFx0c3dpdGNoIChwcm9maWxlX2xldmVsX2lkLnByb2ZpbGUpXG5cdFx0e1xuXHRcdFx0Y2FzZSBQcm9maWxlQ29uc3RyYWluZWRCYXNlbGluZTpcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuICc0MmYwMGInO1xuXHRcdFx0fVxuXHRcdFx0Y2FzZSBQcm9maWxlQmFzZWxpbmU6XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiAnNDIxMDBiJztcblx0XHRcdH1cblx0XHRcdGNhc2UgUHJvZmlsZU1haW46XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiAnNGQxMDBiJztcblx0XHRcdH1cblx0XHRcdC8vIExldmVsIDFfYiBpcyBub3QgYWxsb3dlZCBmb3Igb3RoZXIgcHJvZmlsZXMuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0e1xuXHRcdFx0XHRkZWJ1Zyhcblx0XHRcdFx0XHQncHJvZmlsZUxldmVsSWRUb1N0cmluZygpIHwgTGV2ZWwgMV9iIG5vdCBpcyBhbGxvd2VkIGZvciBwcm9maWxlOiVzJyxcblx0XHRcdFx0XHRwcm9maWxlX2xldmVsX2lkLnByb2ZpbGUpO1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGxldCBwcm9maWxlX2lkY19pb3Bfc3RyaW5nO1xuXG5cdHN3aXRjaCAocHJvZmlsZV9sZXZlbF9pZC5wcm9maWxlKVxuXHR7XG5cdFx0Y2FzZSBQcm9maWxlQ29uc3RyYWluZWRCYXNlbGluZTpcblx0XHR7XG5cdFx0XHRwcm9maWxlX2lkY19pb3Bfc3RyaW5nID0gJzQyZTAnO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGNhc2UgUHJvZmlsZUJhc2VsaW5lOlxuXHRcdHtcblx0XHRcdHByb2ZpbGVfaWRjX2lvcF9zdHJpbmcgPSAnNDIwMCc7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Y2FzZSBQcm9maWxlTWFpbjpcblx0XHR7XG5cdFx0XHRwcm9maWxlX2lkY19pb3Bfc3RyaW5nID0gJzRkMDAnO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGNhc2UgUHJvZmlsZUNvbnN0cmFpbmVkSGlnaDpcblx0XHR7XG5cdFx0XHRwcm9maWxlX2lkY19pb3Bfc3RyaW5nID0gJzY0MGMnO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGNhc2UgUHJvZmlsZUhpZ2g6XG5cdFx0e1xuXHRcdFx0cHJvZmlsZV9pZGNfaW9wX3N0cmluZyA9ICc2NDAwJztcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRkZWZhdWx0OlxuXHRcdHtcblx0XHRcdGRlYnVnKFxuXHRcdFx0XHQncHJvZmlsZUxldmVsSWRUb1N0cmluZygpIHwgdW5yZWNvZ25pemVkIHByb2ZpbGU6JXMnLFxuXHRcdFx0XHRwcm9maWxlX2xldmVsX2lkLnByb2ZpbGUpO1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRsZXQgbGV2ZWxTdHIgPSAocHJvZmlsZV9sZXZlbF9pZC5sZXZlbCkudG9TdHJpbmcoMTYpO1xuXG5cdGlmIChsZXZlbFN0ci5sZW5ndGggPT09IDEpXG5cdFx0bGV2ZWxTdHIgPSBgMCR7bGV2ZWxTdHJ9YDtcblxuXHRyZXR1cm4gYCR7cHJvZmlsZV9pZGNfaW9wX3N0cmluZ30ke2xldmVsU3RyfWA7XG59O1xuXG4vKipcbiAqIFBhcnNlIHByb2ZpbGUgbGV2ZWwgaWQgdGhhdCBpcyByZXByZXNlbnRlZCBhcyBhIHN0cmluZyBvZiAzIGhleCBieXRlc1xuICogY29udGFpbmVkIGluIGFuIFNEUCBrZXktdmFsdWUgbWFwLiBBIGRlZmF1bHQgcHJvZmlsZSBsZXZlbCBpZCB3aWxsIGJlXG4gKiByZXR1cm5lZCBpZiB0aGUgcHJvZmlsZS1sZXZlbC1pZCBrZXkgaXMgbWlzc2luZy4gTm90aGluZyB3aWxsIGJlIHJldHVybmVkIGlmXG4gKiB0aGUga2V5IGlzIHByZXNlbnQgYnV0IHRoZSBzdHJpbmcgaXMgaW52YWxpZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcz17fV0gLSBDb2RlYyBwYXJhbWV0ZXJzIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyB7UHJvZmlsZUxldmVsSWR9XG4gKi9cbmV4cG9ydHMucGFyc2VTZHBQcm9maWxlTGV2ZWxJZCA9IGZ1bmN0aW9uKHBhcmFtcyA9IHt9KVxue1xuXHRjb25zdCBwcm9maWxlX2xldmVsX2lkID0gcGFyYW1zWydwcm9maWxlLWxldmVsLWlkJ107XG5cblx0cmV0dXJuICFwcm9maWxlX2xldmVsX2lkXG5cdFx0PyBEZWZhdWx0UHJvZmlsZUxldmVsSWRcblx0XHQ6IGV4cG9ydHMucGFyc2VQcm9maWxlTGV2ZWxJZChwcm9maWxlX2xldmVsX2lkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXJhbWV0ZXJzIGhhdmUgdGhlIHNhbWUgSDI2NCBwcm9maWxlLCBpLmUuIHRoZSBzYW1lXG4gKiBIMjY0IHByb2ZpbGUgKEJhc2VsaW5lLCBIaWdoLCBldGMpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zMT17fV0gLSBDb2RlYyBwYXJhbWV0ZXJzIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zMj17fV0gLSBDb2RlYyBwYXJhbWV0ZXJzIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1NhbWVQcm9maWxlID0gZnVuY3Rpb24ocGFyYW1zMSA9IHt9LCBwYXJhbXMyID0ge30pXG57XG5cdGNvbnN0IHByb2ZpbGVfbGV2ZWxfaWRfMSA9IGV4cG9ydHMucGFyc2VTZHBQcm9maWxlTGV2ZWxJZChwYXJhbXMxKTtcblx0Y29uc3QgcHJvZmlsZV9sZXZlbF9pZF8yID0gZXhwb3J0cy5wYXJzZVNkcFByb2ZpbGVMZXZlbElkKHBhcmFtczIpO1xuXG5cdC8vIENvbXBhcmUgSDI2NCBwcm9maWxlcywgYnV0IG5vdCBsZXZlbHMuXG5cdHJldHVybiBCb29sZWFuKFxuXHRcdHByb2ZpbGVfbGV2ZWxfaWRfMSAmJlxuXHRcdHByb2ZpbGVfbGV2ZWxfaWRfMiAmJlxuXHRcdHByb2ZpbGVfbGV2ZWxfaWRfMS5wcm9maWxlID09PSBwcm9maWxlX2xldmVsX2lkXzIucHJvZmlsZVxuXHQpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBjb2RlYyBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGFuc3dlciBpbiBhbiBTRFAgbmVnb3RpYXRpb25cbiAqIGJhc2VkIG9uIGxvY2FsIHN1cHBvcnRlZCBwYXJhbWV0ZXJzIGFuZCByZW1vdGUgb2ZmZXJlZCBwYXJhbWV0ZXJzLiBCb3RoXG4gKiBsb2NhbF9zdXBwb3J0ZWRfcGFyYW1zIGFuZCByZW1vdGVfb2ZmZXJlZF9wYXJhbXMgcmVwcmVzZW50IHNlbmRyZWN2IG1lZGlhXG4gKiBkZXNjcmlwdGlvbnMsIGkuZSB0aGV5IGFyZSBhIG1peCBvZiBib3RoIGVuY29kZSBhbmQgZGVjb2RlIGNhcGFiaWxpdGllcy4gSW5cbiAqIHRoZW9yeSwgd2hlbiB0aGUgcHJvZmlsZSBpbiBsb2NhbF9zdXBwb3J0ZWRfcGFyYW1zIHJlcHJlc2VudCBhIHN0cmljdCBzdXBlcnNldFxuICogb2YgdGhlIHByb2ZpbGUgaW4gcmVtb3RlX29mZmVyZWRfcGFyYW1zLCB3ZSBjb3VsZCBsaW1pdCB0aGUgcHJvZmlsZSBpbiB0aGVcbiAqIGFuc3dlciB0byB0aGUgcHJvZmlsZSBpbiByZW1vdGVfb2ZmZXJlZF9wYXJhbXMuXG4gKlxuICogSG93ZXZlciwgdG8gc2ltcGxpZnkgdGhlIGNvZGUsIGVhY2ggc3VwcG9ydGVkIEgyNjQgcHJvZmlsZSBzaG91bGQgYmUgbGlzdGVkXG4gKiBleHBsaWNpdGx5IGluIHRoZSBsaXN0IG9mIGxvY2FsIHN1cHBvcnRlZCBjb2RlY3MsIGV2ZW4gaWYgdGhleSBhcmUgcmVkdW5kYW50LlxuICogVGhlbiBlYWNoIGxvY2FsIGNvZGVjIGluIHRoZSBsaXN0IHNob3VsZCBiZSB0ZXN0ZWQgb25lIGF0IGEgdGltZSBhZ2FpbnN0IHRoZVxuICogcmVtb3RlIGNvZGVjLCBhbmQgb25seSB3aGVuIHRoZSBwcm9maWxlcyBhcmUgZXF1YWwgc2hvdWxkIHRoaXMgZnVuY3Rpb24gYmVcbiAqIGNhbGxlZC4gVGhlcmVmb3JlLCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IG5lZWQgdG8gaGFuZGxlIHByb2ZpbGUgaW50ZXJzZWN0aW9uLFxuICogYW5kIHRoZSBwcm9maWxlIG9mIGxvY2FsX3N1cHBvcnRlZF9wYXJhbXMgYW5kIHJlbW90ZV9vZmZlcmVkX3BhcmFtcyBtdXN0IGJlXG4gKiBlcXVhbCBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLiBUaGUgcGFyYW1ldGVycyB0aGF0IGFyZSB1c2VkIHdoZW5cbiAqIG5lZ290aWF0aW5nIGFyZSB0aGUgbGV2ZWwgcGFydCBvZiBwcm9maWxlLWxldmVsLWlkIGFuZCBsZXZlbC1hc3ltbWV0cnktYWxsb3dlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2xvY2FsX3N1cHBvcnRlZF9wYXJhbXM9e31dXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlbW90ZV9vZmZlcmVkX3BhcmFtcz17fV1cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDYW5vbmljYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGFzIHRocmVlIGhleCBieXRlcyBvZiB0aGVcbiAqICAgcHJvZmlsZSBsZXZlbCBpZCwgb3IgbnVsbCBpZiBubyBvbmUgb2YgdGhlIHBhcmFtcyBoYXZlIHByb2ZpbGUtbGV2ZWwtaWQuXG4gKlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBQcm9maWxlIG1pc21hdGNoIG9yIGludmFsaWQgcGFyYW1zLlxuICovXG5leHBvcnRzLmdlbmVyYXRlUHJvZmlsZUxldmVsSWRGb3JBbnN3ZXIgPSBmdW5jdGlvbihcblx0bG9jYWxfc3VwcG9ydGVkX3BhcmFtcyA9IHt9LFxuXHRyZW1vdGVfb2ZmZXJlZF9wYXJhbXMgPSB7fVxuKVxue1xuXHQvLyBJZiBib3RoIGxvY2FsIGFuZCByZW1vdGUgcGFyYW1zIGRvIG5vdCBjb250YWluIHByb2ZpbGUtbGV2ZWwtaWQsIHRoZXkgYXJlXG5cdC8vIGJvdGggdXNpbmcgdGhlIGRlZmF1bHQgcHJvZmlsZS4gSW4gdGhpcyBjYXNlLCBkb24ndCByZXR1cm4gYW55dGhpbmcuXG5cdGlmIChcblx0XHQhbG9jYWxfc3VwcG9ydGVkX3BhcmFtc1sncHJvZmlsZS1sZXZlbC1pZCddICYmXG5cdFx0IXJlbW90ZV9vZmZlcmVkX3BhcmFtc1sncHJvZmlsZS1sZXZlbC1pZCddXG5cdClcblx0e1xuXHRcdGRlYnVnKFxuXHRcdFx0J2dlbmVyYXRlUHJvZmlsZUxldmVsSWRGb3JBbnN3ZXIoKSB8IG5vIHByb2ZpbGUtbGV2ZWwtaWQgaW4gbG9jYWwgYW5kIHJlbW90ZSBwYXJhbXMnKTtcblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gUGFyc2UgcHJvZmlsZS1sZXZlbC1pZHMuXG5cdGNvbnN0IGxvY2FsX3Byb2ZpbGVfbGV2ZWxfaWQgPVxuXHRcdGV4cG9ydHMucGFyc2VTZHBQcm9maWxlTGV2ZWxJZChsb2NhbF9zdXBwb3J0ZWRfcGFyYW1zKTtcblx0Y29uc3QgcmVtb3RlX3Byb2ZpbGVfbGV2ZWxfaWQgPVxuXHRcdGV4cG9ydHMucGFyc2VTZHBQcm9maWxlTGV2ZWxJZChyZW1vdGVfb2ZmZXJlZF9wYXJhbXMpO1xuXG5cdC8vIFRoZSBsb2NhbCBhbmQgcmVtb3RlIGNvZGVjIG11c3QgaGF2ZSB2YWxpZCBhbmQgZXF1YWwgSDI2NCBQcm9maWxlcy5cblx0aWYgKCFsb2NhbF9wcm9maWxlX2xldmVsX2lkKVxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgbG9jYWxfcHJvZmlsZV9sZXZlbF9pZCcpO1xuXG5cdGlmICghcmVtb3RlX3Byb2ZpbGVfbGV2ZWxfaWQpXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCByZW1vdGVfcHJvZmlsZV9sZXZlbF9pZCcpO1xuXG5cdGlmIChsb2NhbF9wcm9maWxlX2xldmVsX2lkLnByb2ZpbGUgIT09IHJlbW90ZV9wcm9maWxlX2xldmVsX2lkLnByb2ZpbGUpXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignSDI2NCBQcm9maWxlIG1pc21hdGNoJyk7XG5cblx0Ly8gUGFyc2UgbGV2ZWwgaW5mb3JtYXRpb24uXG5cdGNvbnN0IGxldmVsX2FzeW1tZXRyeV9hbGxvd2VkID0gKFxuXHRcdGlzTGV2ZWxBc3ltbWV0cnlBbGxvd2VkKGxvY2FsX3N1cHBvcnRlZF9wYXJhbXMpICYmXG5cdFx0aXNMZXZlbEFzeW1tZXRyeUFsbG93ZWQocmVtb3RlX29mZmVyZWRfcGFyYW1zKVxuXHQpO1xuXG5cdGNvbnN0IGxvY2FsX2xldmVsID0gbG9jYWxfcHJvZmlsZV9sZXZlbF9pZC5sZXZlbDtcblx0Y29uc3QgcmVtb3RlX2xldmVsID0gcmVtb3RlX3Byb2ZpbGVfbGV2ZWxfaWQubGV2ZWw7XG5cdGNvbnN0IG1pbl9sZXZlbCA9IG1pbkxldmVsKGxvY2FsX2xldmVsLCByZW1vdGVfbGV2ZWwpO1xuXG5cdC8vIERldGVybWluZSBhbnN3ZXIgbGV2ZWwuIFdoZW4gbGV2ZWwgYXN5bW1ldHJ5IGlzIG5vdCBhbGxvd2VkLCBsZXZlbCB1cGdyYWRlXG5cdC8vIGlzIG5vdCBhbGxvd2VkLCBpLmUuLCB0aGUgbGV2ZWwgaW4gdGhlIGFuc3dlciBtdXN0IGJlIGVxdWFsIHRvIG9yIGxvd2VyXG5cdC8vIHRoYW4gdGhlIGxldmVsIGluIHRoZSBvZmZlci5cblx0Y29uc3QgYW5zd2VyX2xldmVsID0gbGV2ZWxfYXN5bW1ldHJ5X2FsbG93ZWQgPyBsb2NhbF9sZXZlbCA6IG1pbl9sZXZlbDtcblxuXHRkZWJ1Zyhcblx0XHQnZ2VuZXJhdGVQcm9maWxlTGV2ZWxJZEZvckFuc3dlcigpIHwgcmVzdWx0OiBbcHJvZmlsZTolcywgbGV2ZWw6JXNdJyxcblx0XHRsb2NhbF9wcm9maWxlX2xldmVsX2lkLnByb2ZpbGUsIGFuc3dlcl9sZXZlbCk7XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgcHJvZmlsZS1sZXZlbC1pZCBmb3IgdGhlIGFuc3dlciBwYXJhbWV0ZXJzLlxuXHRyZXR1cm4gZXhwb3J0cy5wcm9maWxlTGV2ZWxJZFRvU3RyaW5nKFxuXHRcdG5ldyBQcm9maWxlTGV2ZWxJZChsb2NhbF9wcm9maWxlX2xldmVsX2lkLnByb2ZpbGUsIGFuc3dlcl9sZXZlbCkpO1xufTtcblxuLy8gQ29udmVydCBhIHN0cmluZyBvZiA4IGNoYXJhY3RlcnMgaW50byBhIGJ5dGUgd2hlcmUgdGhlIHBvc2l0aW9ucyBjb250YWluaW5nXG4vLyBjaGFyYWN0ZXIgYyB3aWxsIGhhdmUgdGhlaXIgYml0IHNldC4gRm9yIGV4YW1wbGUsIGMgPSAneCcsIHN0ciA9IFwieDF4eDAwMDBcIlxuLy8gd2lsbCByZXR1cm4gMGIxMDExMDAwMC5cbmZ1bmN0aW9uIGJ5dGVNYXNrU3RyaW5nKGMsIHN0cilcbntcblx0cmV0dXJuIChcblx0XHQoKHN0clswXSA9PT0gYykgPDwgNykgfCAoKHN0clsxXSA9PT0gYykgPDwgNikgfCAoKHN0clsyXSA9PT0gYykgPDwgNSkgfFxuXHRcdCgoc3RyWzNdID09PSBjKSA8PCA0KVx0fCAoKHN0cls0XSA9PT0gYykgPDwgMylcdHwgKChzdHJbNV0gPT09IGMpIDw8IDIpXHR8XG5cdFx0KChzdHJbNl0gPT09IGMpIDw8IDEpXHR8ICgoc3RyWzddID09PSBjKSA8PCAwKVxuXHQpO1xufVxuXG4vLyBDb21wYXJlIEgyNjQgbGV2ZWxzIGFuZCBoYW5kbGUgdGhlIGxldmVsIDFiIGNhc2UuXG5mdW5jdGlvbiBpc0xlc3NMZXZlbChhLCBiKVxue1xuXHRpZiAoYSA9PT0gTGV2ZWwxX2IpXG5cdFx0cmV0dXJuIGIgIT09IExldmVsMSAmJiBiICE9PSBMZXZlbDFfYjtcblxuXHRpZiAoYiA9PT0gTGV2ZWwxX2IpXG5cdFx0cmV0dXJuIGEgIT09IExldmVsMTtcblxuXHRyZXR1cm4gYSA8IGI7XG59XG5cbmZ1bmN0aW9uIG1pbkxldmVsKGEsIGIpXG57XG5cdHJldHVybiBpc0xlc3NMZXZlbChhLCBiKSA/IGEgOiBiO1xufVxuXG5mdW5jdGlvbiBpc0xldmVsQXN5bW1ldHJ5QWxsb3dlZChwYXJhbXMgPSB7fSlcbntcblx0Y29uc3QgbGV2ZWxfYXN5bW1ldHJ5X2FsbG93ZWQgPSBwYXJhbXNbJ2xldmVsLWFzeW1tZXRyeS1hbGxvd2VkJ107XG5cblx0cmV0dXJuIChcblx0XHRsZXZlbF9hc3ltbWV0cnlfYWxsb3dlZCA9PT0gMSB8fFxuXHRcdGxldmVsX2FzeW1tZXRyeV9hbGxvd2VkID09PSAnMSdcblx0KTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/h264-profile-level-id/index.js\n");

/***/ }),

/***/ "./node_modules/h264-profile-level-id/node_modules/debug/src/browser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/h264-profile-level-id/node_modules/debug/src/browser.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/h264-profile-level-id/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaDI2NC1wcm9maWxlLWxldmVsLWlkL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3J4X3NvY2tldGlvX2NsaWVudC8uL25vZGVfbW9kdWxlcy9oMjY0LXByb2ZpbGUtbGV2ZWwtaWQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzPzU0ODciXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcblx0Ly8gVGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcblx0Ly8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcblx0cmV0dXJuIHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJlxuXHRcdGNvbnNvbGUubG9nICYmXG5cdFx0Y29uc29sZS5sb2coLi4uYXJncyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/h264-profile-level-id/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "./node_modules/h264-profile-level-id/node_modules/debug/src/common.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/h264-profile-level-id/node_modules/debug/src/common.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/h264-profile-level-id/node_modules/ms/index.js\");\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaDI2NC1wcm9maWxlLWxldmVsLWlkL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2gyNjQtcHJvZmlsZS1sZXZlbC1pZC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcz8wNWIxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cblx0Ki9cblx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzID0gW107XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdC8vIERlYnVnLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuXHRcdC8vIGRlYnVnLnJhd0xvZyA9IHJhd0xvZztcblxuXHRcdC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnN0IGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgaW5zdGFuY2UgPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXNbaV07XG5cdFx0XHRpbnN0YW5jZS5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/h264-profile-level-id/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "./node_modules/h264-profile-level-id/node_modules/ms/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/h264-profile-level-id/node_modules/ms/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaDI2NC1wcm9maWxlLWxldmVsLWlkL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3J4X3NvY2tldGlvX2NsaWVudC8uL25vZGVfbW9kdWxlcy9oMjY0LXByb2ZpbGUtbGV2ZWwtaWQvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzPzhkNjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/h264-profile-level-id/node_modules/ms/index.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Consumer.js":
/*!*******************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Consumer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\nconst logger = new Logger_1.Logger('Consumer');\nclass Consumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    /**\n     * @emits transportclose\n     * @emits trackended\n     * @emits @getstats\n     * @emits @close\n     */\n    constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData }) {\n        super();\n        // Closed flag.\n        this._closed = false;\n        logger.debug('constructor()');\n        this._id = id;\n        this._localId = localId;\n        this._producerId = producerId;\n        this._rtpReceiver = rtpReceiver;\n        this._track = track;\n        this._rtpParameters = rtpParameters;\n        this._paused = !track.enabled;\n        this._appData = appData;\n        this._onTrackEnded = this._onTrackEnded.bind(this);\n        this._handleTrack();\n    }\n    /**\n     * Consumer id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Local id.\n     */\n    get localId() {\n        return this._localId;\n    }\n    /**\n     * Associated Producer id.\n     */\n    get producerId() {\n        return this._producerId;\n    }\n    /**\n     * Whether the Consumer is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * Media kind.\n     */\n    get kind() {\n        return this._track.kind;\n    }\n    /**\n     * Associated RTCRtpReceiver.\n     */\n    get rtpReceiver() {\n        return this._rtpReceiver;\n    }\n    /**\n     * The associated track.\n     */\n    get track() {\n        return this._track;\n    }\n    /**\n     * RTP parameters.\n     */\n    get rtpParameters() {\n        return this._rtpParameters;\n    }\n    /**\n     * Whether the Consumer is paused.\n     */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * Invalid setter.\n     */\n    set appData(appData) {\n        throw new Error('cannot override appData object');\n    }\n    /**\n     * Closes the Consumer.\n     */\n    close() {\n        if (this._closed)\n            return;\n        logger.debug('close()');\n        this._closed = true;\n        this._destroyTrack();\n        this.emit('@close');\n    }\n    /**\n     * Transport was closed.\n     */\n    transportClosed() {\n        if (this._closed)\n            return;\n        logger.debug('transportClosed()');\n        this._closed = true;\n        this._destroyTrack();\n        this.safeEmit('transportclose');\n    }\n    /**\n     * Get associated RTCRtpReceiver stats.\n     */\n    async getStats() {\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        return this.safeEmitAsPromise('@getstats');\n    }\n    /**\n     * Pauses receiving media.\n     */\n    pause() {\n        logger.debug('pause()');\n        if (this._closed) {\n            logger.error('pause() | Consumer closed');\n            return;\n        }\n        this._paused = true;\n        this._track.enabled = false;\n    }\n    /**\n     * Resumes receiving media.\n     */\n    resume() {\n        logger.debug('resume()');\n        if (this._closed) {\n            logger.error('resume() | Consumer closed');\n            return;\n        }\n        this._paused = false;\n        this._track.enabled = true;\n    }\n    _onTrackEnded() {\n        logger.debug('track \"ended\" event');\n        this.safeEmit('trackended');\n    }\n    _handleTrack() {\n        this._track.addEventListener('ended', this._onTrackEnded);\n    }\n    _destroyTrack() {\n        try {\n            this._track.removeEventListener('ended', this._onTrackEnded);\n            this._track.stop();\n        }\n        catch (error) { }\n    }\n}\nexports.Consumer = Consumer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvQ29uc3VtZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvQ29uc3VtZXIuanM/YjE5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY29uc3QgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL0VuaGFuY2VkRXZlbnRFbWl0dGVyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdDb25zdW1lcicpO1xuY2xhc3MgQ29uc3VtZXIgZXh0ZW5kcyBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xLkVuaGFuY2VkRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBAZW1pdHMgdHJhbnNwb3J0Y2xvc2VcbiAgICAgKiBAZW1pdHMgdHJhY2tlbmRlZFxuICAgICAqIEBlbWl0cyBAZ2V0c3RhdHNcbiAgICAgKiBAZW1pdHMgQGNsb3NlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBpZCwgbG9jYWxJZCwgcHJvZHVjZXJJZCwgcnRwUmVjZWl2ZXIsIHRyYWNrLCBydHBQYXJhbWV0ZXJzLCBhcHBEYXRhIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gQ2xvc2VkIGZsYWcuXG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCknKTtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgdGhpcy5fbG9jYWxJZCA9IGxvY2FsSWQ7XG4gICAgICAgIHRoaXMuX3Byb2R1Y2VySWQgPSBwcm9kdWNlcklkO1xuICAgICAgICB0aGlzLl9ydHBSZWNlaXZlciA9IHJ0cFJlY2VpdmVyO1xuICAgICAgICB0aGlzLl90cmFjayA9IHRyYWNrO1xuICAgICAgICB0aGlzLl9ydHBQYXJhbWV0ZXJzID0gcnRwUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fcGF1c2VkID0gIXRyYWNrLmVuYWJsZWQ7XG4gICAgICAgIHRoaXMuX2FwcERhdGEgPSBhcHBEYXRhO1xuICAgICAgICB0aGlzLl9vblRyYWNrRW5kZWQgPSB0aGlzLl9vblRyYWNrRW5kZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlVHJhY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3VtZXIgaWQuXG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvY2FsIGlkLlxuICAgICAqL1xuICAgIGdldCBsb2NhbElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlZCBQcm9kdWNlciBpZC5cbiAgICAgKi9cbiAgICBnZXQgcHJvZHVjZXJJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2R1Y2VySWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIENvbnN1bWVyIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZWRpYSBraW5kLlxuICAgICAqL1xuICAgIGdldCBraW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2sua2luZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlZCBSVENSdHBSZWNlaXZlci5cbiAgICAgKi9cbiAgICBnZXQgcnRwUmVjZWl2ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydHBSZWNlaXZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFzc29jaWF0ZWQgdHJhY2suXG4gICAgICovXG4gICAgZ2V0IHRyYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJUUCBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGdldCBydHBQYXJhbWV0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnRwUGFyYW1ldGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgQ29uc3VtZXIgaXMgcGF1c2VkLlxuICAgICAqL1xuICAgIGdldCBwYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcCBjdXN0b20gZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgYXBwRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcERhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmFsaWQgc2V0dGVyLlxuICAgICAqL1xuICAgIHNldCBhcHBEYXRhKGFwcERhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgb3ZlcnJpZGUgYXBwRGF0YSBvYmplY3QnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBDb25zdW1lci5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lUcmFjaygpO1xuICAgICAgICB0aGlzLmVtaXQoJ0BjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgd2FzIGNsb3NlZC5cbiAgICAgKi9cbiAgICB0cmFuc3BvcnRDbG9zZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndHJhbnNwb3J0Q2xvc2VkKCknKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGVzdHJveVRyYWNrKCk7XG4gICAgICAgIHRoaXMuc2FmZUVtaXQoJ3RyYW5zcG9ydGNsb3NlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhc3NvY2lhdGVkIFJUQ1J0cFJlY2VpdmVyIHN0YXRzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoJ0BnZXRzdGF0cycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgcmVjZWl2aW5nIG1lZGlhLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdwYXVzZSgpIHwgQ29uc3VtZXIgY2xvc2VkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIHJlY2VpdmluZyBtZWRpYS5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdyZXN1bWUoKSB8IENvbnN1bWVyIGNsb3NlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgX29uVHJhY2tFbmRlZCgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd0cmFjayBcImVuZGVkXCIgZXZlbnQnKTtcbiAgICAgICAgdGhpcy5zYWZlRW1pdCgndHJhY2tlbmRlZCcpO1xuICAgIH1cbiAgICBfaGFuZGxlVHJhY2soKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5fb25UcmFja0VuZGVkKTtcbiAgICB9XG4gICAgX2Rlc3Ryb3lUcmFjaygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5fb25UcmFja0VuZGVkKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/Consumer.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/DataConsumer.js":
/*!***********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/DataConsumer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\nconst logger = new Logger_1.Logger('DataConsumer');\nclass DataConsumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    /**\n     * @emits transportclose\n     * @emits open\n     * @emits error - (error: Error)\n     * @emits close\n     * @emits message - (message: any)\n     * @emits @close\n     */\n    constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData }) {\n        super();\n        // Closed flag.\n        this._closed = false;\n        logger.debug('constructor()');\n        this._id = id;\n        this._dataProducerId = dataProducerId;\n        this._dataChannel = dataChannel;\n        this._sctpStreamParameters = sctpStreamParameters;\n        this._appData = appData;\n        this._handleDataChannel();\n    }\n    /**\n     * DataConsumer id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Associated DataProducer id.\n     */\n    get dataProducerId() {\n        return this._dataProducerId;\n    }\n    /**\n     * Whether the DataConsumer is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * SCTP stream parameters.\n     */\n    get sctpStreamParameters() {\n        return this._sctpStreamParameters;\n    }\n    /**\n     * DataChannel readyState.\n     */\n    get readyState() {\n        return this._dataChannel.readyState;\n    }\n    /**\n     * DataChannel label.\n     */\n    get label() {\n        return this._dataChannel.label;\n    }\n    /**\n     * DataChannel protocol.\n     */\n    get protocol() {\n        return this._dataChannel.protocol;\n    }\n    /**\n     * DataChannel binaryType.\n     */\n    get binaryType() {\n        return this._dataChannel.binaryType;\n    }\n    /**\n     * Set DataChannel binaryType.\n     */\n    set binaryType(binaryType) {\n        this._dataChannel.binaryType = binaryType;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * Invalid setter.\n     */\n    set appData(appData) {\n        throw new Error('cannot override appData object');\n    }\n    /**\n     * Closes the DataConsumer.\n     */\n    close() {\n        if (this._closed)\n            return;\n        logger.debug('close()');\n        this._closed = true;\n        this._dataChannel.close();\n        this.emit('@close');\n    }\n    /**\n     * Transport was closed.\n     */\n    transportClosed() {\n        if (this._closed)\n            return;\n        logger.debug('transportClosed()');\n        this._closed = true;\n        this._dataChannel.close();\n        this.safeEmit('transportclose');\n    }\n    _handleDataChannel() {\n        this._dataChannel.addEventListener('open', () => {\n            if (this._closed)\n                return;\n            logger.debug('DataChannel \"open\" event');\n            this.safeEmit('open');\n        });\n        this._dataChannel.addEventListener('error', (event) => {\n            if (this._closed)\n                return;\n            let { error } = event;\n            if (!error)\n                error = new Error('unknown DataChannel error');\n            if (error.errorDetail === 'sctp-failure') {\n                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);\n            }\n            else {\n                logger.error('DataChannel \"error\" event: %o', error);\n            }\n            this.safeEmit('error', error);\n        });\n        this._dataChannel.addEventListener('close', () => {\n            if (this._closed)\n                return;\n            logger.warn('DataChannel \"close\" event');\n            this._closed = true;\n            this.emit('@close');\n            this.safeEmit('close');\n        });\n        this._dataChannel.addEventListener('message', (event) => {\n            if (this._closed)\n                return;\n            this.safeEmit('message', event.data);\n        });\n    }\n}\nexports.DataConsumer = DataConsumer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvRGF0YUNvbnN1bWVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0RhdGFDb25zdW1lci5qcz84NTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jb25zdCBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4vRW5oYW5jZWRFdmVudEVtaXR0ZXJcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdEYXRhQ29uc3VtZXInKTtcbmNsYXNzIERhdGFDb25zdW1lciBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEBlbWl0cyB0cmFuc3BvcnRjbG9zZVxuICAgICAqIEBlbWl0cyBvcGVuXG4gICAgICogQGVtaXRzIGVycm9yIC0gKGVycm9yOiBFcnJvcilcbiAgICAgKiBAZW1pdHMgY2xvc2VcbiAgICAgKiBAZW1pdHMgbWVzc2FnZSAtIChtZXNzYWdlOiBhbnkpXG4gICAgICogQGVtaXRzIEBjbG9zZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgaWQsIGRhdGFQcm9kdWNlcklkLCBkYXRhQ2hhbm5lbCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGFwcERhdGEgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDbG9zZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKScpO1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9kYXRhUHJvZHVjZXJJZCA9IGRhdGFQcm9kdWNlcklkO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbCA9IGRhdGFDaGFubmVsO1xuICAgICAgICB0aGlzLl9zY3RwU3RyZWFtUGFyYW1ldGVycyA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9hcHBEYXRhID0gYXBwRGF0YTtcbiAgICAgICAgdGhpcy5faGFuZGxlRGF0YUNoYW5uZWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YUNvbnN1bWVyIGlkLlxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVkIERhdGFQcm9kdWNlciBpZC5cbiAgICAgKi9cbiAgICBnZXQgZGF0YVByb2R1Y2VySWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhUHJvZHVjZXJJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgRGF0YUNvbnN1bWVyIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTQ1RQIHN0cmVhbSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGdldCBzY3RwU3RyZWFtUGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhQ2hhbm5lbCByZWFkeVN0YXRlLlxuICAgICAqL1xuICAgIGdldCByZWFkeVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNoYW5uZWwucmVhZHlTdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YUNoYW5uZWwgbGFiZWwuXG4gICAgICovXG4gICAgZ2V0IGxhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNoYW5uZWwubGFiZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDaGFubmVsIHByb3RvY29sLlxuICAgICAqL1xuICAgIGdldCBwcm90b2NvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLnByb3RvY29sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhQ2hhbm5lbCBiaW5hcnlUeXBlLlxuICAgICAqL1xuICAgIGdldCBiaW5hcnlUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNoYW5uZWwuYmluYXJ5VHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IERhdGFDaGFubmVsIGJpbmFyeVR5cGUuXG4gICAgICovXG4gICAgc2V0IGJpbmFyeVR5cGUoYmluYXJ5VHlwZSkge1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5iaW5hcnlUeXBlID0gYmluYXJ5VHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwIGN1c3RvbSBkYXRhLlxuICAgICAqL1xuICAgIGdldCBhcHBEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwRGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52YWxpZCBzZXR0ZXIuXG4gICAgICovXG4gICAgc2V0IGFwcERhdGEoYXBwRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBvdmVycmlkZSBhcHBEYXRhIG9iamVjdCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIERhdGFDb25zdW1lci5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCB3YXMgY2xvc2VkLlxuICAgICAqL1xuICAgIHRyYW5zcG9ydENsb3NlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd0cmFuc3BvcnRDbG9zZWQoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5jbG9zZSgpO1xuICAgICAgICB0aGlzLnNhZmVFbWl0KCd0cmFuc3BvcnRjbG9zZScpO1xuICAgIH1cbiAgICBfaGFuZGxlRGF0YUNoYW5uZWwoKSB7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnRGF0YUNoYW5uZWwgXCJvcGVuXCIgZXZlbnQnKTtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ29wZW4nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB7IGVycm9yIH0gPSBldmVudDtcbiAgICAgICAgICAgIGlmICghZXJyb3IpXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ3Vua25vd24gRGF0YUNoYW5uZWwgZXJyb3InKTtcbiAgICAgICAgICAgIGlmIChlcnJvci5lcnJvckRldGFpbCA9PT0gJ3NjdHAtZmFpbHVyZScpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0RhdGFDaGFubmVsIFNDVFAgZXJyb3IgW3NjdHBDYXVzZUNvZGU6JXNdOiAlcycsIGVycm9yLnNjdHBDYXVzZUNvZGUsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdEYXRhQ2hhbm5lbCBcImVycm9yXCIgZXZlbnQ6ICVvJywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0RhdGFDaGFubmVsIFwiY2xvc2VcIiBldmVudCcpO1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdtZXNzYWdlJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0YUNvbnN1bWVyID0gRGF0YUNvbnN1bWVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/DataConsumer.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/DataProducer.js":
/*!***********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/DataProducer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\nconst logger = new Logger_1.Logger('DataProducer');\nclass DataProducer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    /**\n     * @emits transportclose\n     * @emits open\n     * @emits error - (error: Error)\n     * @emits close\n     * @emits bufferedamountlow\n     * @emits @close\n     */\n    constructor({ id, dataChannel, sctpStreamParameters, appData }) {\n        super();\n        // Closed flag.\n        this._closed = false;\n        logger.debug('constructor()');\n        this._id = id;\n        this._dataChannel = dataChannel;\n        this._sctpStreamParameters = sctpStreamParameters;\n        this._appData = appData;\n        this._handleDataChannel();\n    }\n    /**\n     * DataProducer id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Whether the DataProducer is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * SCTP stream parameters.\n     */\n    get sctpStreamParameters() {\n        return this._sctpStreamParameters;\n    }\n    /**\n     * DataChannel readyState.\n     */\n    get readyState() {\n        return this._dataChannel.readyState;\n    }\n    /**\n     * DataChannel label.\n     */\n    get label() {\n        return this._dataChannel.label;\n    }\n    /**\n     * DataChannel protocol.\n     */\n    get protocol() {\n        return this._dataChannel.protocol;\n    }\n    /**\n     * DataChannel bufferedAmount.\n     */\n    get bufferedAmount() {\n        return this._dataChannel.bufferedAmount;\n    }\n    /**\n     * DataChannel bufferedAmountLowThreshold.\n     */\n    get bufferedAmountLowThreshold() {\n        return this._dataChannel.bufferedAmountLowThreshold;\n    }\n    /**\n     * Set DataChannel bufferedAmountLowThreshold.\n     */\n    set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {\n        this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * Invalid setter.\n     */\n    set appData(appData) {\n        throw new Error('cannot override appData object');\n    }\n    /**\n     * Closes the DataProducer.\n     */\n    close() {\n        if (this._closed)\n            return;\n        logger.debug('close()');\n        this._closed = true;\n        this._dataChannel.close();\n        this.emit('@close');\n    }\n    /**\n     * Transport was closed.\n     */\n    transportClosed() {\n        if (this._closed)\n            return;\n        logger.debug('transportClosed()');\n        this._closed = true;\n        this._dataChannel.close();\n        this.safeEmit('transportclose');\n    }\n    /**\n     * Send a message.\n     *\n     * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.\n     */\n    send(data) {\n        logger.debug('send()');\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        this._dataChannel.send(data);\n    }\n    _handleDataChannel() {\n        this._dataChannel.addEventListener('open', () => {\n            if (this._closed)\n                return;\n            logger.debug('DataChannel \"open\" event');\n            this.safeEmit('open');\n        });\n        this._dataChannel.addEventListener('error', (event) => {\n            if (this._closed)\n                return;\n            let { error } = event;\n            if (!error)\n                error = new Error('unknown DataChannel error');\n            if (error.errorDetail === 'sctp-failure') {\n                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);\n            }\n            else {\n                logger.error('DataChannel \"error\" event: %o', error);\n            }\n            this.safeEmit('error', error);\n        });\n        this._dataChannel.addEventListener('close', () => {\n            if (this._closed)\n                return;\n            logger.warn('DataChannel \"close\" event');\n            this._closed = true;\n            this.emit('@close');\n            this.safeEmit('close');\n        });\n        this._dataChannel.addEventListener('message', () => {\n            if (this._closed)\n                return;\n            logger.warn('DataChannel \"message\" event in a DataProducer, message discarded');\n        });\n        this._dataChannel.addEventListener('bufferedamountlow', () => {\n            if (this._closed)\n                return;\n            this.safeEmit('bufferedamountlow');\n        });\n    }\n}\nexports.DataProducer = DataProducer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvRGF0YVByb2R1Y2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0RhdGFQcm9kdWNlci5qcz81MjU4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jb25zdCBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4vRW5oYW5jZWRFdmVudEVtaXR0ZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0RhdGFQcm9kdWNlcicpO1xuY2xhc3MgRGF0YVByb2R1Y2VyIGV4dGVuZHMgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMS5FbmhhbmNlZEV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogQGVtaXRzIHRyYW5zcG9ydGNsb3NlXG4gICAgICogQGVtaXRzIG9wZW5cbiAgICAgKiBAZW1pdHMgZXJyb3IgLSAoZXJyb3I6IEVycm9yKVxuICAgICAqIEBlbWl0cyBjbG9zZVxuICAgICAqIEBlbWl0cyBidWZmZXJlZGFtb3VudGxvd1xuICAgICAqIEBlbWl0cyBAY2xvc2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGlkLCBkYXRhQ2hhbm5lbCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGFwcERhdGEgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDbG9zZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKScpO1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbCA9IGRhdGFDaGFubmVsO1xuICAgICAgICB0aGlzLl9zY3RwU3RyZWFtUGFyYW1ldGVycyA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9hcHBEYXRhID0gYXBwRGF0YTtcbiAgICAgICAgdGhpcy5faGFuZGxlRGF0YUNoYW5uZWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YVByb2R1Y2VyIGlkLlxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBEYXRhUHJvZHVjZXIgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNDVFAgc3RyZWFtIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgZ2V0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDaGFubmVsIHJlYWR5U3RhdGUuXG4gICAgICovXG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ2hhbm5lbC5yZWFkeVN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhQ2hhbm5lbCBsYWJlbC5cbiAgICAgKi9cbiAgICBnZXQgbGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ2hhbm5lbC5sYWJlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YUNoYW5uZWwgcHJvdG9jb2wuXG4gICAgICovXG4gICAgZ2V0IHByb3RvY29sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNoYW5uZWwucHJvdG9jb2w7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDaGFubmVsIGJ1ZmZlcmVkQW1vdW50LlxuICAgICAqL1xuICAgIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLmJ1ZmZlcmVkQW1vdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhQ2hhbm5lbCBidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZC5cbiAgICAgKi9cbiAgICBnZXQgYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IERhdGFDaGFubmVsIGJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkLlxuICAgICAqL1xuICAgIHNldCBidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZChidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCkge1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IGJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHAgY3VzdG9tIGRhdGEuXG4gICAgICovXG4gICAgZ2V0IGFwcERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBEYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkIHNldHRlci5cbiAgICAgKi9cbiAgICBzZXQgYXBwRGF0YShhcHBEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IG92ZXJyaWRlIGFwcERhdGEgb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgRGF0YVByb2R1Y2VyLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdAY2xvc2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IHdhcyBjbG9zZWQuXG4gICAgICovXG4gICAgdHJhbnNwb3J0Q2xvc2VkKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3RyYW5zcG9ydENsb3NlZCgpJyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuc2FmZUVtaXQoJ3RyYW5zcG9ydGNsb3NlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QmxvYnxBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IGRhdGEuXG4gICAgICovXG4gICAgc2VuZChkYXRhKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5zZW5kKGRhdGEpO1xuICAgIH1cbiAgICBfaGFuZGxlRGF0YUNoYW5uZWwoKSB7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnRGF0YUNoYW5uZWwgXCJvcGVuXCIgZXZlbnQnKTtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ29wZW4nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB7IGVycm9yIH0gPSBldmVudDtcbiAgICAgICAgICAgIGlmICghZXJyb3IpXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ3Vua25vd24gRGF0YUNoYW5uZWwgZXJyb3InKTtcbiAgICAgICAgICAgIGlmIChlcnJvci5lcnJvckRldGFpbCA9PT0gJ3NjdHAtZmFpbHVyZScpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0RhdGFDaGFubmVsIFNDVFAgZXJyb3IgW3NjdHBDYXVzZUNvZGU6JXNdOiAlcycsIGVycm9yLnNjdHBDYXVzZUNvZGUsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdEYXRhQ2hhbm5lbCBcImVycm9yXCIgZXZlbnQ6ICVvJywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0RhdGFDaGFubmVsIFwiY2xvc2VcIiBldmVudCcpO1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0RhdGFDaGFubmVsIFwibWVzc2FnZVwiIGV2ZW50IGluIGEgRGF0YVByb2R1Y2VyLCBtZXNzYWdlIGRpc2NhcmRlZCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignYnVmZmVyZWRhbW91bnRsb3cnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ2J1ZmZlcmVkYW1vdW50bG93Jyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0YVByb2R1Y2VyID0gRGF0YVByb2R1Y2VyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/DataProducer.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Device.js":
/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Device.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* global RTCRtpTransceiver */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bowser = __webpack_require__(/*! bowser */ \"./node_modules/bowser/es5.js\");\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\nconst ortc = __webpack_require__(/*! ./ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\nconst Transport_1 = __webpack_require__(/*! ./Transport */ \"./node_modules/mediasoup-client/lib/Transport.js\");\nconst Chrome74_1 = __webpack_require__(/*! ./handlers/Chrome74 */ \"./node_modules/mediasoup-client/lib/handlers/Chrome74.js\");\nconst Chrome70_1 = __webpack_require__(/*! ./handlers/Chrome70 */ \"./node_modules/mediasoup-client/lib/handlers/Chrome70.js\");\nconst Chrome67_1 = __webpack_require__(/*! ./handlers/Chrome67 */ \"./node_modules/mediasoup-client/lib/handlers/Chrome67.js\");\nconst Chrome55_1 = __webpack_require__(/*! ./handlers/Chrome55 */ \"./node_modules/mediasoup-client/lib/handlers/Chrome55.js\");\nconst Firefox60_1 = __webpack_require__(/*! ./handlers/Firefox60 */ \"./node_modules/mediasoup-client/lib/handlers/Firefox60.js\");\nconst Safari12_1 = __webpack_require__(/*! ./handlers/Safari12 */ \"./node_modules/mediasoup-client/lib/handlers/Safari12.js\");\nconst Safari11_1 = __webpack_require__(/*! ./handlers/Safari11 */ \"./node_modules/mediasoup-client/lib/handlers/Safari11.js\");\nconst Edge11_1 = __webpack_require__(/*! ./handlers/Edge11 */ \"./node_modules/mediasoup-client/lib/handlers/Edge11.js\");\nconst ReactNative_1 = __webpack_require__(/*! ./handlers/ReactNative */ \"./node_modules/mediasoup-client/lib/handlers/ReactNative.js\");\nconst logger = new Logger_1.Logger('Device');\nfunction detectDevice() {\n    // React-Native.\n    // NOTE: react-native-webrtc >= 1.75.0 is required.\n    if (typeof navigator === 'object' && navigator.product === 'ReactNative') {\n        if (typeof RTCPeerConnection === 'undefined') {\n            logger.warn('this._detectDevice() | unsupported ReactNative without RTCPeerConnection');\n            return undefined;\n        }\n        logger.debug('this._detectDevice() | ReactNative handler chosen');\n        return 'ReactNative';\n    }\n    // Browser.\n    else if (typeof navigator === 'object' && typeof navigator.userAgent === 'string') {\n        const ua = navigator.userAgent;\n        const browser = bowser.getParser(ua);\n        const engine = browser.getEngine();\n        // Chrome and Chromium.\n        if (browser.satisfies({ chrome: '>=74', chromium: '>=74' })) {\n            return 'Chrome74';\n        }\n        else if (browser.satisfies({ chrome: '>=70', chromium: '>=70' })) {\n            return 'Chrome70';\n        }\n        else if (browser.satisfies({ chrome: '>=67', chromium: '>=67' })) {\n            return 'Chrome67';\n        }\n        else if (browser.satisfies({ chrome: '>=55', chromium: '>=55' })) {\n            return 'Chrome55';\n        }\n        // Firefox.\n        else if (browser.satisfies({ firefox: '>=60' })) {\n            return 'Firefox60';\n        }\n        // Safari with Unified-Plan support enabled.\n        else if (browser.satisfies({ safari: '>=12.0' }) &&\n            typeof RTCRtpTransceiver !== 'undefined' &&\n            RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {\n            return 'Safari12';\n        }\n        // Safari with Plab-B support.\n        else if (browser.satisfies({ safari: '>=11' })) {\n            return 'Safari11';\n        }\n        // Old Edge with ORTC support.\n        else if (browser.satisfies({ 'microsoft edge': '>=11' }) &&\n            browser.satisfies({ 'microsoft edge': '<=18' })) {\n            return 'Edge11';\n        }\n        // Best effort for Chromium based browsers.\n        else if (engine.name && engine.name.toLowerCase() === 'blink') {\n            const match = ua.match(/(?:(?:Chrome|Chromium))[ /](\\w+)/i);\n            if (match) {\n                const version = Number(match[1]);\n                if (version >= 74) {\n                    return 'Chrome74';\n                }\n                else if (version >= 70) {\n                    return 'Chrome70';\n                }\n                else if (version >= 67) {\n                    return 'Chrome67';\n                }\n                else {\n                    return 'Chrome55';\n                }\n            }\n            else {\n                return 'Chrome74';\n            }\n        }\n        // Unsupported browser.\n        else {\n            logger.warn('this._detectDevice() | browser not supported [name:%s, version:%s]', browser.getBrowserName(), browser.getBrowserVersion());\n            return undefined;\n        }\n    }\n    // Unknown device.\n    else {\n        logger.warn('this._detectDevice() | unknown device');\n        return undefined;\n    }\n}\nexports.detectDevice = detectDevice;\nclass Device {\n    /**\n     * Create a new Device to connect to mediasoup server.\n     *\n     * @throws {UnsupportedError} if device is not supported.\n     */\n    constructor({ handlerName, handlerFactory, Handler } = {}) {\n        // Loaded flag.\n        this._loaded = false;\n        logger.debug('constructor()');\n        // Handle deprecated option.\n        if (Handler) {\n            logger.warn('constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead');\n            if (typeof Handler === 'string')\n                handlerName = Handler;\n            else\n                throw new TypeError('non string Handler option no longer supported, use handlerFactory instead');\n        }\n        if (handlerName && handlerFactory) {\n            throw new TypeError('just one of handlerName or handlerInterface can be given');\n        }\n        if (handlerFactory) {\n            this._handlerFactory = handlerFactory;\n        }\n        else {\n            if (handlerName) {\n                logger.debug('constructor() | handler given: %s', handlerName);\n            }\n            else {\n                handlerName = detectDevice();\n                if (handlerName)\n                    logger.debug('constructor() | detected handler: %s', handlerName);\n                else\n                    throw new errors_1.UnsupportedError('device not supported');\n            }\n            switch (handlerName) {\n                case 'Chrome74':\n                    this._handlerFactory = Chrome74_1.Chrome74.createFactory();\n                    break;\n                case 'Chrome70':\n                    this._handlerFactory = Chrome70_1.Chrome70.createFactory();\n                    break;\n                case 'Chrome67':\n                    this._handlerFactory = Chrome67_1.Chrome67.createFactory();\n                    break;\n                case 'Chrome55':\n                    this._handlerFactory = Chrome55_1.Chrome55.createFactory();\n                    break;\n                case 'Firefox60':\n                    this._handlerFactory = Firefox60_1.Firefox60.createFactory();\n                    break;\n                case 'Safari12':\n                    this._handlerFactory = Safari12_1.Safari12.createFactory();\n                    break;\n                case 'Safari11':\n                    this._handlerFactory = Safari11_1.Safari11.createFactory();\n                    break;\n                case 'Edge11':\n                    this._handlerFactory = Edge11_1.Edge11.createFactory();\n                    break;\n                case 'ReactNative':\n                    this._handlerFactory = ReactNative_1.ReactNative.createFactory();\n                    break;\n                default:\n                    throw new TypeError(`unknown handlerName \"${handlerName}\"`);\n            }\n        }\n        // Create a temporal handler to get its name.\n        const handler = this._handlerFactory();\n        this._handlerName = handler.name;\n        handler.close();\n        this._extendedRtpCapabilities = undefined;\n        this._recvRtpCapabilities = undefined;\n        this._canProduceByKind =\n            {\n                audio: false,\n                video: false\n            };\n        this._sctpCapabilities = undefined;\n    }\n    /**\n     * The RTC handler name.\n     */\n    get handlerName() {\n        return this._handlerName;\n    }\n    /**\n     * Whether the Device is loaded.\n     */\n    get loaded() {\n        return this._loaded;\n    }\n    /**\n     * RTP capabilities of the Device for receiving media.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     */\n    get rtpCapabilities() {\n        if (!this._loaded)\n            throw new errors_1.InvalidStateError('not loaded');\n        return this._recvRtpCapabilities;\n    }\n    /**\n     * SCTP capabilities of the Device.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     */\n    get sctpCapabilities() {\n        if (!this._loaded)\n            throw new errors_1.InvalidStateError('not loaded');\n        return this._sctpCapabilities;\n    }\n    /**\n     * Initialize the Device.\n     */\n    async load({ routerRtpCapabilities }) {\n        logger.debug('load() [routerRtpCapabilities:%o]', routerRtpCapabilities);\n        // Temporal handler to get its capabilities.\n        let handler;\n        try {\n            if (this._loaded)\n                throw new errors_1.InvalidStateError('already loaded');\n            // This may throw.\n            ortc.validateRtpCapabilities(routerRtpCapabilities);\n            handler = this._handlerFactory();\n            const nativeRtpCapabilities = await handler.getNativeRtpCapabilities();\n            logger.debug('load() | got native RTP capabilities:%o', nativeRtpCapabilities);\n            // This may throw.\n            ortc.validateRtpCapabilities(nativeRtpCapabilities);\n            // Get extended RTP capabilities.\n            this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, routerRtpCapabilities);\n            logger.debug('load() | got extended RTP capabilities:%o', this._extendedRtpCapabilities);\n            // Check whether we can produce audio/video.\n            this._canProduceByKind.audio =\n                ortc.canSend('audio', this._extendedRtpCapabilities);\n            this._canProduceByKind.video =\n                ortc.canSend('video', this._extendedRtpCapabilities);\n            // Generate our receiving RTP capabilities for receiving media.\n            this._recvRtpCapabilities =\n                ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);\n            // This may throw.\n            ortc.validateRtpCapabilities(this._recvRtpCapabilities);\n            logger.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities);\n            // Generate our SCTP capabilities.\n            this._sctpCapabilities = await handler.getNativeSctpCapabilities();\n            logger.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities);\n            // This may throw.\n            ortc.validateSctpCapabilities(this._sctpCapabilities);\n            logger.debug('load() succeeded');\n            this._loaded = true;\n            handler.close();\n        }\n        catch (error) {\n            if (handler)\n                handler.close();\n            throw error;\n        }\n    }\n    /**\n     * Whether we can produce audio/video.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     * @throws {TypeError} if wrong arguments.\n     */\n    canProduce(kind) {\n        if (!this._loaded)\n            throw new errors_1.InvalidStateError('not loaded');\n        else if (kind !== 'audio' && kind !== 'video')\n            throw new TypeError(`invalid kind \"${kind}\"`);\n        return this._canProduceByKind[kind];\n    }\n    /**\n     * Creates a Transport for sending media.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     * @throws {TypeError} if wrong arguments.\n     */\n    createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {\n        logger.debug('createSendTransport()');\n        return this._createTransport({\n            direction: 'send',\n            id: id,\n            iceParameters: iceParameters,\n            iceCandidates: iceCandidates,\n            dtlsParameters: dtlsParameters,\n            sctpParameters: sctpParameters,\n            iceServers: iceServers,\n            iceTransportPolicy: iceTransportPolicy,\n            additionalSettings: additionalSettings,\n            proprietaryConstraints: proprietaryConstraints,\n            appData: appData\n        });\n    }\n    /**\n     * Creates a Transport for receiving media.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     * @throws {TypeError} if wrong arguments.\n     */\n    createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {\n        logger.debug('createRecvTransport()');\n        return this._createTransport({\n            direction: 'recv',\n            id: id,\n            iceParameters: iceParameters,\n            iceCandidates: iceCandidates,\n            dtlsParameters: dtlsParameters,\n            sctpParameters: sctpParameters,\n            iceServers: iceServers,\n            iceTransportPolicy: iceTransportPolicy,\n            additionalSettings: additionalSettings,\n            proprietaryConstraints: proprietaryConstraints,\n            appData: appData\n        });\n    }\n    _createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {\n        if (!this._loaded)\n            throw new errors_1.InvalidStateError('not loaded');\n        else if (typeof id !== 'string')\n            throw new TypeError('missing id');\n        else if (typeof iceParameters !== 'object')\n            throw new TypeError('missing iceParameters');\n        else if (!Array.isArray(iceCandidates))\n            throw new TypeError('missing iceCandidates');\n        else if (typeof dtlsParameters !== 'object')\n            throw new TypeError('missing dtlsParameters');\n        else if (sctpParameters && typeof sctpParameters !== 'object')\n            throw new TypeError('wrong sctpParameters');\n        else if (appData && typeof appData !== 'object')\n            throw new TypeError('if given, appData must be an object');\n        // Create a new Transport.\n        const transport = new Transport_1.Transport({\n            direction,\n            id,\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            iceServers,\n            iceTransportPolicy,\n            additionalSettings,\n            proprietaryConstraints,\n            appData,\n            handlerFactory: this._handlerFactory,\n            extendedRtpCapabilities: this._extendedRtpCapabilities,\n            canProduceByKind: this._canProduceByKind\n        });\n        return transport;\n    }\n}\nexports.Device = Device;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvRGV2aWNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0RldmljZS5qcz8zNjNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIFJUQ1J0cFRyYW5zY2VpdmVyICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBib3dzZXIgPSByZXF1aXJlKFwiYm93c2VyXCIpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IG9ydGMgPSByZXF1aXJlKFwiLi9vcnRjXCIpO1xuY29uc3QgVHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi9UcmFuc3BvcnRcIik7XG5jb25zdCBDaHJvbWU3NF8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvQ2hyb21lNzRcIik7XG5jb25zdCBDaHJvbWU3MF8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvQ2hyb21lNzBcIik7XG5jb25zdCBDaHJvbWU2N18xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvQ2hyb21lNjdcIik7XG5jb25zdCBDaHJvbWU1NV8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvQ2hyb21lNTVcIik7XG5jb25zdCBGaXJlZm94NjBfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL0ZpcmVmb3g2MFwiKTtcbmNvbnN0IFNhZmFyaTEyXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9TYWZhcmkxMlwiKTtcbmNvbnN0IFNhZmFyaTExXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9TYWZhcmkxMVwiKTtcbmNvbnN0IEVkZ2UxMV8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvRWRnZTExXCIpO1xuY29uc3QgUmVhY3ROYXRpdmVfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL1JlYWN0TmF0aXZlXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignRGV2aWNlJyk7XG5mdW5jdGlvbiBkZXRlY3REZXZpY2UoKSB7XG4gICAgLy8gUmVhY3QtTmF0aXZlLlxuICAgIC8vIE5PVEU6IHJlYWN0LW5hdGl2ZS13ZWJydGMgPj0gMS43NS4wIGlzIHJlcXVpcmVkLlxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgICAgICBpZiAodHlwZW9mIFJUQ1BlZXJDb25uZWN0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3RoaXMuX2RldGVjdERldmljZSgpIHwgdW5zdXBwb3J0ZWQgUmVhY3ROYXRpdmUgd2l0aG91dCBSVENQZWVyQ29ubmVjdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3RoaXMuX2RldGVjdERldmljZSgpIHwgUmVhY3ROYXRpdmUgaGFuZGxlciBjaG9zZW4nKTtcbiAgICAgICAgcmV0dXJuICdSZWFjdE5hdGl2ZSc7XG4gICAgfVxuICAgIC8vIEJyb3dzZXIuXG4gICAgZWxzZSBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgY29uc3QgYnJvd3NlciA9IGJvd3Nlci5nZXRQYXJzZXIodWEpO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSBicm93c2VyLmdldEVuZ2luZSgpO1xuICAgICAgICAvLyBDaHJvbWUgYW5kIENocm9taXVtLlxuICAgICAgICBpZiAoYnJvd3Nlci5zYXRpc2ZpZXMoeyBjaHJvbWU6ICc+PTc0JywgY2hyb21pdW06ICc+PTc0JyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWU3NCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnJvd3Nlci5zYXRpc2ZpZXMoeyBjaHJvbWU6ICc+PTcwJywgY2hyb21pdW06ICc+PTcwJyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWU3MCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnJvd3Nlci5zYXRpc2ZpZXMoeyBjaHJvbWU6ICc+PTY3JywgY2hyb21pdW06ICc+PTY3JyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWU2Nyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnJvd3Nlci5zYXRpc2ZpZXMoeyBjaHJvbWU6ICc+PTU1JywgY2hyb21pdW06ICc+PTU1JyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWU1NSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyZWZveC5cbiAgICAgICAgZWxzZSBpZiAoYnJvd3Nlci5zYXRpc2ZpZXMoeyBmaXJlZm94OiAnPj02MCcgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnRmlyZWZveDYwJztcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWZhcmkgd2l0aCBVbmlmaWVkLVBsYW4gc3VwcG9ydCBlbmFibGVkLlxuICAgICAgICBlbHNlIGlmIChicm93c2VyLnNhdGlzZmllcyh7IHNhZmFyaTogJz49MTIuMCcgfSkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBSVENSdHBUcmFuc2NlaXZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIFJUQ1J0cFRyYW5zY2VpdmVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudERpcmVjdGlvbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1NhZmFyaTEyJztcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWZhcmkgd2l0aCBQbGFiLUIgc3VwcG9ydC5cbiAgICAgICAgZWxzZSBpZiAoYnJvd3Nlci5zYXRpc2ZpZXMoeyBzYWZhcmk6ICc+PTExJyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuICdTYWZhcmkxMSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT2xkIEVkZ2Ugd2l0aCBPUlRDIHN1cHBvcnQuXG4gICAgICAgIGVsc2UgaWYgKGJyb3dzZXIuc2F0aXNmaWVzKHsgJ21pY3Jvc29mdCBlZGdlJzogJz49MTEnIH0pICYmXG4gICAgICAgICAgICBicm93c2VyLnNhdGlzZmllcyh7ICdtaWNyb3NvZnQgZWRnZSc6ICc8PTE4JyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuICdFZGdlMTEnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJlc3QgZWZmb3J0IGZvciBDaHJvbWl1bSBiYXNlZCBicm93c2Vycy5cbiAgICAgICAgZWxzZSBpZiAoZW5naW5lLm5hbWUgJiYgZW5naW5lLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2JsaW5rJykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB1YS5tYXRjaCgvKD86KD86Q2hyb21lfENocm9taXVtKSlbIC9dKFxcdyspL2kpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IE51bWJlcihtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnNpb24gPj0gNzQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdDaHJvbWU3NCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZlcnNpb24gPj0gNzApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdDaHJvbWU3MCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZlcnNpb24gPj0gNjcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdDaHJvbWU2Nyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0Nocm9tZTU1JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0Nocm9tZTc0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVbnN1cHBvcnRlZCBicm93c2VyLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCd0aGlzLl9kZXRlY3REZXZpY2UoKSB8IGJyb3dzZXIgbm90IHN1cHBvcnRlZCBbbmFtZTolcywgdmVyc2lvbjolc10nLCBicm93c2VyLmdldEJyb3dzZXJOYW1lKCksIGJyb3dzZXIuZ2V0QnJvd3NlclZlcnNpb24oKSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVua25vd24gZGV2aWNlLlxuICAgIGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybigndGhpcy5fZGV0ZWN0RGV2aWNlKCkgfCB1bmtub3duIGRldmljZScpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuZGV0ZWN0RGV2aWNlID0gZGV0ZWN0RGV2aWNlO1xuY2xhc3MgRGV2aWNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgRGV2aWNlIHRvIGNvbm5lY3QgdG8gbWVkaWFzb3VwIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge1Vuc3VwcG9ydGVkRXJyb3J9IGlmIGRldmljZSBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgaGFuZGxlck5hbWUsIGhhbmRsZXJGYWN0b3J5LCBIYW5kbGVyIH0gPSB7fSkge1xuICAgICAgICAvLyBMb2FkZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKScpO1xuICAgICAgICAvLyBIYW5kbGUgZGVwcmVjYXRlZCBvcHRpb24uXG4gICAgICAgIGlmIChIYW5kbGVyKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignY29uc3RydWN0b3IoKSB8IEhhbmRsZXIgb3B0aW9uIGlzIERFUFJFQ0FURUQsIHVzZSBoYW5kbGVyTmFtZSBvciBoYW5kbGVyRmFjdG9yeSBpbnN0ZWFkJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEhhbmRsZXIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGhhbmRsZXJOYW1lID0gSGFuZGxlcjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub24gc3RyaW5nIEhhbmRsZXIgb3B0aW9uIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHVzZSBoYW5kbGVyRmFjdG9yeSBpbnN0ZWFkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZXJOYW1lICYmIGhhbmRsZXJGYWN0b3J5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdqdXN0IG9uZSBvZiBoYW5kbGVyTmFtZSBvciBoYW5kbGVySW50ZXJmYWNlIGNhbiBiZSBnaXZlbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVyRmFjdG9yeSkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBoYW5kbGVyRmFjdG9yeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyTmFtZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKSB8IGhhbmRsZXIgZ2l2ZW46ICVzJywgaGFuZGxlck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlck5hbWUgPSBkZXRlY3REZXZpY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlck5hbWUpXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKSB8IGRldGVjdGVkIGhhbmRsZXI6ICVzJywgaGFuZGxlck5hbWUpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ2RldmljZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGhhbmRsZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnQ2hyb21lNzQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IENocm9tZTc0XzEuQ2hyb21lNzQuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdDaHJvbWU3MCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJGYWN0b3J5ID0gQ2hyb21lNzBfMS5DaHJvbWU3MC5jcmVhdGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0Nocm9tZTY3JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBDaHJvbWU2N18xLkNocm9tZTY3LmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQ2hyb21lNTUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IENocm9tZTU1XzEuQ2hyb21lNTUuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdGaXJlZm94NjAnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IEZpcmVmb3g2MF8xLkZpcmVmb3g2MC5jcmVhdGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NhZmFyaTEyJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBTYWZhcmkxMl8xLlNhZmFyaTEyLmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnU2FmYXJpMTEnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IFNhZmFyaTExXzEuU2FmYXJpMTEuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdFZGdlMTEnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IEVkZ2UxMV8xLkVkZ2UxMS5jcmVhdGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1JlYWN0TmF0aXZlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBSZWFjdE5hdGl2ZV8xLlJlYWN0TmF0aXZlLmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5rbm93biBoYW5kbGVyTmFtZSBcIiR7aGFuZGxlck5hbWV9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhbCBoYW5kbGVyIHRvIGdldCBpdHMgbmFtZS5cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX2hhbmRsZXJGYWN0b3J5KCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJOYW1lID0gaGFuZGxlci5uYW1lO1xuICAgICAgICBoYW5kbGVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9yZWN2UnRwQ2FwYWJpbGl0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jYW5Qcm9kdWNlQnlLaW5kID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdWRpbzogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmlkZW86IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zY3RwQ2FwYWJpbGl0aWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgUlRDIGhhbmRsZXIgbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgaGFuZGxlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVyTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgRGV2aWNlIGlzIGxvYWRlZC5cbiAgICAgKi9cbiAgICBnZXQgbG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSVFAgY2FwYWJpbGl0aWVzIG9mIHRoZSBEZXZpY2UgZm9yIHJlY2VpdmluZyBtZWRpYS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRTdGF0ZUVycm9yfSBpZiBub3QgbG9hZGVkLlxuICAgICAqL1xuICAgIGdldCBydHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdub3QgbG9hZGVkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWN2UnRwQ2FwYWJpbGl0aWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTQ1RQIGNhcGFiaWxpdGllcyBvZiB0aGUgRGV2aWNlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7SW52YWxpZFN0YXRlRXJyb3J9IGlmIG5vdCBsb2FkZWQuXG4gICAgICovXG4gICAgZ2V0IHNjdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdub3QgbG9hZGVkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3RwQ2FwYWJpbGl0aWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBEZXZpY2UuXG4gICAgICovXG4gICAgYXN5bmMgbG9hZCh7IHJvdXRlclJ0cENhcGFiaWxpdGllcyB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnbG9hZCgpIFtyb3V0ZXJSdHBDYXBhYmlsaXRpZXM6JW9dJywgcm91dGVyUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgLy8gVGVtcG9yYWwgaGFuZGxlciB0byBnZXQgaXRzIGNhcGFiaWxpdGllcy5cbiAgICAgICAgbGV0IGhhbmRsZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9hZGVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignYWxyZWFkeSBsb2FkZWQnKTtcbiAgICAgICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICAgICAgb3J0Yy52YWxpZGF0ZVJ0cENhcGFiaWxpdGllcyhyb3V0ZXJSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgaGFuZGxlciA9IHRoaXMuX2hhbmRsZXJGYWN0b3J5KCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBhd2FpdCBoYW5kbGVyLmdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdsb2FkKCkgfCBnb3QgbmF0aXZlIFJUUCBjYXBhYmlsaXRpZXM6JW8nLCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgICAgICBvcnRjLnZhbGlkYXRlUnRwQ2FwYWJpbGl0aWVzKG5hdGl2ZVJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAvLyBHZXQgZXh0ZW5kZWQgUlRQIGNhcGFiaWxpdGllcy5cbiAgICAgICAgICAgIHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzID0gb3J0Yy5nZXRFeHRlbmRlZFJ0cENhcGFiaWxpdGllcyhuYXRpdmVSdHBDYXBhYmlsaXRpZXMsIHJvdXRlclJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2xvYWQoKSB8IGdvdCBleHRlbmRlZCBSVFAgY2FwYWJpbGl0aWVzOiVvJywgdGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB3ZSBjYW4gcHJvZHVjZSBhdWRpby92aWRlby5cbiAgICAgICAgICAgIHRoaXMuX2NhblByb2R1Y2VCeUtpbmQuYXVkaW8gPVxuICAgICAgICAgICAgICAgIG9ydGMuY2FuU2VuZCgnYXVkaW8nLCB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICB0aGlzLl9jYW5Qcm9kdWNlQnlLaW5kLnZpZGVvID1cbiAgICAgICAgICAgICAgICBvcnRjLmNhblNlbmQoJ3ZpZGVvJywgdGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgb3VyIHJlY2VpdmluZyBSVFAgY2FwYWJpbGl0aWVzIGZvciByZWNlaXZpbmcgbWVkaWEuXG4gICAgICAgICAgICB0aGlzLl9yZWN2UnRwQ2FwYWJpbGl0aWVzID1cbiAgICAgICAgICAgICAgICBvcnRjLmdldFJlY3ZSdHBDYXBhYmlsaXRpZXModGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgICAgICBvcnRjLnZhbGlkYXRlUnRwQ2FwYWJpbGl0aWVzKHRoaXMuX3JlY3ZSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdsb2FkKCkgfCBnb3QgcmVjZWl2aW5nIFJUUCBjYXBhYmlsaXRpZXM6JW8nLCB0aGlzLl9yZWN2UnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIG91ciBTQ1RQIGNhcGFiaWxpdGllcy5cbiAgICAgICAgICAgIHRoaXMuX3NjdHBDYXBhYmlsaXRpZXMgPSBhd2FpdCBoYW5kbGVyLmdldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnbG9hZCgpIHwgZ290IG5hdGl2ZSBTQ1RQIGNhcGFiaWxpdGllczolbycsIHRoaXMuX3NjdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgICAgICBvcnRjLnZhbGlkYXRlU2N0cENhcGFiaWxpdGllcyh0aGlzLl9zY3RwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnbG9hZCgpIHN1Y2NlZWRlZCcpO1xuICAgICAgICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhbmRsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKVxuICAgICAgICAgICAgICAgIGhhbmRsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgd2UgY2FuIHByb2R1Y2UgYXVkaW8vdmlkZW8uXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkU3RhdGVFcnJvcn0gaWYgbm90IGxvYWRlZC5cbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHdyb25nIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBjYW5Qcm9kdWNlKGtpbmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ25vdCBsb2FkZWQnKTtcbiAgICAgICAgZWxzZSBpZiAoa2luZCAhPT0gJ2F1ZGlvJyAmJiBraW5kICE9PSAndmlkZW8nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBraW5kIFwiJHtraW5kfVwiYCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5Qcm9kdWNlQnlLaW5kW2tpbmRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVHJhbnNwb3J0IGZvciBzZW5kaW5nIG1lZGlhLlxuICAgICAqXG4gICAgICogQHRocm93cyB7SW52YWxpZFN0YXRlRXJyb3J9IGlmIG5vdCBsb2FkZWQuXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBpZiB3cm9uZyBhcmd1bWVudHMuXG4gICAgICovXG4gICAgY3JlYXRlU2VuZFRyYW5zcG9ydCh7IGlkLCBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCBhcHBEYXRhID0ge30gfSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2NyZWF0ZVNlbmRUcmFuc3BvcnQoKScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlVHJhbnNwb3J0KHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3NlbmQnLFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgaWNlUGFyYW1ldGVyczogaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXM6IGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVyczogc2N0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3ksXG4gICAgICAgICAgICBhZGRpdGlvbmFsU2V0dGluZ3M6IGFkZGl0aW9uYWxTZXR0aW5ncyxcbiAgICAgICAgICAgIHByb3ByaWV0YXJ5Q29uc3RyYWludHM6IHByb3ByaWV0YXJ5Q29uc3RyYWludHMsXG4gICAgICAgICAgICBhcHBEYXRhOiBhcHBEYXRhXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVHJhbnNwb3J0IGZvciByZWNlaXZpbmcgbWVkaWEuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkU3RhdGVFcnJvcn0gaWYgbm90IGxvYWRlZC5cbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHdyb25nIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBjcmVhdGVSZWN2VHJhbnNwb3J0KHsgaWQsIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGFwcERhdGEgPSB7fSB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY3JlYXRlUmVjdlRyYW5zcG9ydCgpJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVUcmFuc3BvcnQoe1xuICAgICAgICAgICAgZGlyZWN0aW9uOiAncmVjdicsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBpY2VQYXJhbWV0ZXJzOiBpY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlczogaWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzOiBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzOiBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMsXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxTZXR0aW5nczogYWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICAgICAgcHJvcHJpZXRhcnlDb25zdHJhaW50czogcHJvcHJpZXRhcnlDb25zdHJhaW50cyxcbiAgICAgICAgICAgIGFwcERhdGE6IGFwcERhdGFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9jcmVhdGVUcmFuc3BvcnQoeyBkaXJlY3Rpb24sIGlkLCBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCBhcHBEYXRhID0ge30gfSkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignbm90IGxvYWRlZCcpO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBpZCcpO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaWNlUGFyYW1ldGVycyAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGljZVBhcmFtZXRlcnMnKTtcbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoaWNlQ2FuZGlkYXRlcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGljZUNhbmRpZGF0ZXMnKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGR0bHNQYXJhbWV0ZXJzICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZHRsc1BhcmFtZXRlcnMnKTtcbiAgICAgICAgZWxzZSBpZiAoc2N0cFBhcmFtZXRlcnMgJiYgdHlwZW9mIHNjdHBQYXJhbWV0ZXJzICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dyb25nIHNjdHBQYXJhbWV0ZXJzJyk7XG4gICAgICAgIGVsc2UgaWYgKGFwcERhdGEgJiYgdHlwZW9mIGFwcERhdGEgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWYgZ2l2ZW4sIGFwcERhdGEgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IFRyYW5zcG9ydC5cbiAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydF8xLlRyYW5zcG9ydCh7XG4gICAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZVNlcnZlcnMsXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3ksXG4gICAgICAgICAgICBhZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgICAgICBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLFxuICAgICAgICAgICAgYXBwRGF0YSxcbiAgICAgICAgICAgIGhhbmRsZXJGYWN0b3J5OiB0aGlzLl9oYW5kbGVyRmFjdG9yeSxcbiAgICAgICAgICAgIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzOiB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyxcbiAgICAgICAgICAgIGNhblByb2R1Y2VCeUtpbmQ6IHRoaXMuX2NhblByb2R1Y2VCeUtpbmRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gICAgfVxufVxuZXhwb3J0cy5EZXZpY2UgPSBEZXZpY2U7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/Device.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst logger = new Logger_1.Logger('EnhancedEventEmitter');\nclass EnhancedEventEmitter extends events_1.EventEmitter {\n    constructor() {\n        super();\n        this.setMaxListeners(Infinity);\n    }\n    safeEmit(event, ...args) {\n        const numListeners = this.listenerCount(event);\n        try {\n            return this.emit(event, ...args);\n        }\n        catch (error) {\n            logger.error('safeEmit() | event listener threw an error [event:%s]:%o', event, error);\n            return Boolean(numListeners);\n        }\n    }\n    async safeEmitAsPromise(event, ...args) {\n        return new Promise((resolve, reject) => (this.safeEmit(event, ...args, resolve, reject)));\n    }\n}\nexports.EnhancedEventEmitter = EnhancedEventEmitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvRW5oYW5jZWRFdmVudEVtaXR0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvRW5oYW5jZWRFdmVudEVtaXR0ZXIuanM/MWIyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignRW5oYW5jZWRFdmVudEVtaXR0ZXInKTtcbmNsYXNzIEVuaGFuY2VkRXZlbnRFbWl0dGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpO1xuICAgIH1cbiAgICBzYWZlRW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBudW1MaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ3NhZmVFbWl0KCkgfCBldmVudCBsaXN0ZW5lciB0aHJldyBhbiBlcnJvciBbZXZlbnQ6JXNdOiVvJywgZXZlbnQsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKG51bUxpc3RlbmVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2FmZUVtaXRBc1Byb21pc2UoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+ICh0aGlzLnNhZmVFbWl0KGV2ZW50LCAuLi5hcmdzLCByZXNvbHZlLCByZWplY3QpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5FbmhhbmNlZEV2ZW50RW1pdHRlciA9IEVuaGFuY2VkRXZlbnRFbWl0dGVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Logger.js":
/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Logger.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst debug_1 = __webpack_require__(/*! debug */ \"./node_modules/mediasoup-client/node_modules/debug/src/browser.js\");\nconst APP_NAME = 'mediasoup-client';\nclass Logger {\n    constructor(prefix) {\n        if (prefix) {\n            this._debug = debug_1.default(`${APP_NAME}:${prefix}`);\n            this._warn = debug_1.default(`${APP_NAME}:WARN:${prefix}`);\n            this._error = debug_1.default(`${APP_NAME}:ERROR:${prefix}`);\n        }\n        else {\n            this._debug = debug_1.default(APP_NAME);\n            this._warn = debug_1.default(`${APP_NAME}:WARN`);\n            this._error = debug_1.default(`${APP_NAME}:ERROR`);\n        }\n        /* eslint-disable no-console */\n        this._debug.log = console.info.bind(console);\n        this._warn.log = console.warn.bind(console);\n        this._error.log = console.error.bind(console);\n        /* eslint-enable no-console */\n    }\n    get debug() {\n        return this._debug;\n    }\n    get warn() {\n        return this._warn;\n    }\n    get error() {\n        return this._error;\n    }\n}\nexports.Logger = Logger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvTG9nZ2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0xvZ2dlci5qcz9lZTFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IEFQUF9OQU1FID0gJ21lZGlhc291cC1jbGllbnQnO1xuY2xhc3MgTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgpIHtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcgPSBkZWJ1Z18xLmRlZmF1bHQoYCR7QVBQX05BTUV9OiR7cHJlZml4fWApO1xuICAgICAgICAgICAgdGhpcy5fd2FybiA9IGRlYnVnXzEuZGVmYXVsdChgJHtBUFBfTkFNRX06V0FSTjoke3ByZWZpeH1gKTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZGVidWdfMS5kZWZhdWx0KGAke0FQUF9OQU1FfTpFUlJPUjoke3ByZWZpeH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnID0gZGVidWdfMS5kZWZhdWx0KEFQUF9OQU1FKTtcbiAgICAgICAgICAgIHRoaXMuX3dhcm4gPSBkZWJ1Z18xLmRlZmF1bHQoYCR7QVBQX05BTUV9OldBUk5gKTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZGVidWdfMS5kZWZhdWx0KGAke0FQUF9OQU1FfTpFUlJPUmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgdGhpcy5fZGVidWcubG9nID0gY29uc29sZS5pbmZvLmJpbmQoY29uc29sZSk7XG4gICAgICAgIHRoaXMuX3dhcm4ubG9nID0gY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG4gICAgICAgIHRoaXMuX2Vycm9yLmxvZyA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgfVxuICAgIGdldCBkZWJ1ZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlYnVnO1xuICAgIH1cbiAgICBnZXQgd2FybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhcm47XG4gICAgfVxuICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/Logger.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Producer.js":
/*!*******************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Producer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\nconst logger = new Logger_1.Logger('Producer');\nclass Producer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    /**\n     * @emits transportclose\n     * @emits trackended\n     * @emits @replacetrack - (track: MediaStreamTrack | null)\n     * @emits @setmaxspatiallayer - (spatialLayer: string)\n     * @emits @setrtpencodingparameters - (params: any)\n     * @emits @getstats\n     * @emits @close\n     */\n    constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData }) {\n        super();\n        // Closed flag.\n        this._closed = false;\n        logger.debug('constructor()');\n        this._id = id;\n        this._localId = localId;\n        this._rtpSender = rtpSender;\n        this._track = track;\n        this._kind = track.kind;\n        this._rtpParameters = rtpParameters;\n        this._paused = disableTrackOnPause ? !track.enabled : false;\n        this._maxSpatialLayer = undefined;\n        this._stopTracks = stopTracks;\n        this._disableTrackOnPause = disableTrackOnPause;\n        this._zeroRtpOnPause = zeroRtpOnPause;\n        this._appData = appData;\n        this._onTrackEnded = this._onTrackEnded.bind(this);\n        // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the\n        // '@replacetrack' event here, so RTCRtpSender.track won't be null.\n        this._handleTrack();\n    }\n    /**\n     * Producer id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Local id.\n     */\n    get localId() {\n        return this._localId;\n    }\n    /**\n     * Whether the Producer is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * Media kind.\n     */\n    get kind() {\n        return this._kind;\n    }\n    /**\n     * Associated RTCRtpSender.\n     */\n    get rtpSender() {\n        return this._rtpSender;\n    }\n    /**\n     * The associated track.\n     */\n    get track() {\n        return this._track;\n    }\n    /**\n     * RTP parameters.\n     */\n    get rtpParameters() {\n        return this._rtpParameters;\n    }\n    /**\n     * Whether the Producer is paused.\n     */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Max spatial layer.\n     *\n     * @type {Number | undefined}\n     */\n    get maxSpatialLayer() {\n        return this._maxSpatialLayer;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * Invalid setter.\n     */\n    set appData(appData) {\n        throw new Error('cannot override appData object');\n    }\n    /**\n     * Closes the Producer.\n     */\n    close() {\n        if (this._closed)\n            return;\n        logger.debug('close()');\n        this._closed = true;\n        this._destroyTrack();\n        this.emit('@close');\n    }\n    /**\n     * Transport was closed.\n     */\n    transportClosed() {\n        if (this._closed)\n            return;\n        logger.debug('transportClosed()');\n        this._closed = true;\n        this._destroyTrack();\n        this.safeEmit('transportclose');\n    }\n    /**\n     * Get associated RTCRtpSender stats.\n     */\n    async getStats() {\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        return this.safeEmitAsPromise('@getstats');\n    }\n    /**\n     * Pauses sending media.\n     */\n    pause() {\n        logger.debug('pause()');\n        if (this._closed) {\n            logger.error('pause() | Producer closed');\n            return;\n        }\n        this._paused = true;\n        if (this._track && this._disableTrackOnPause) {\n            this._track.enabled = false;\n        }\n        if (this._zeroRtpOnPause) {\n            this.safeEmitAsPromise('@replacetrack', null)\n                .catch(() => { });\n        }\n    }\n    /**\n     * Resumes sending media.\n     */\n    resume() {\n        logger.debug('resume()');\n        if (this._closed) {\n            logger.error('resume() | Producer closed');\n            return;\n        }\n        this._paused = false;\n        if (this._track && this._disableTrackOnPause) {\n            this._track.enabled = true;\n        }\n        if (this._zeroRtpOnPause) {\n            this.safeEmitAsPromise('@replacetrack', this._track)\n                .catch(() => { });\n        }\n    }\n    /**\n     * Replaces the current track with a new one or null.\n     */\n    async replaceTrack({ track }) {\n        logger.debug('replaceTrack() [track:%o]', track);\n        if (this._closed) {\n            // This must be done here. Otherwise there is no chance to stop the given\n            // track.\n            if (track && this._stopTracks) {\n                try {\n                    track.stop();\n                }\n                catch (error) { }\n            }\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (track && track.readyState === 'ended') {\n            throw new errors_1.InvalidStateError('track ended');\n        }\n        // Do nothing if this is the same track as the current handled one.\n        if (track === this._track) {\n            logger.debug('replaceTrack() | same track, ignored');\n            return;\n        }\n        if (!this._zeroRtpOnPause || !this._paused) {\n            await this.safeEmitAsPromise('@replacetrack', track);\n        }\n        // Destroy the previous track.\n        this._destroyTrack();\n        // Set the new track.\n        this._track = track;\n        // If this Producer was paused/resumed and the state of the new\n        // track does not match, fix it.\n        if (this._track && this._disableTrackOnPause) {\n            if (!this._paused)\n                this._track.enabled = true;\n            else if (this._paused)\n                this._track.enabled = false;\n        }\n        // Handle the effective track.\n        this._handleTrack();\n    }\n    /**\n     * Sets the video max spatial layer to be sent.\n     */\n    async setMaxSpatialLayer(spatialLayer) {\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (this._kind !== 'video')\n            throw new errors_1.UnsupportedError('not a video Producer');\n        else if (typeof spatialLayer !== 'number')\n            throw new TypeError('invalid spatialLayer');\n        if (spatialLayer === this._maxSpatialLayer)\n            return;\n        await this.safeEmitAsPromise('@setmaxspatiallayer', spatialLayer);\n        this._maxSpatialLayer = spatialLayer;\n    }\n    /**\n     * Sets the DSCP value.\n     */\n    async setRtpEncodingParameters(params) {\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (typeof params !== 'object')\n            throw new TypeError('invalid params');\n        await this.safeEmitAsPromise('@setrtpencodingparameters', params);\n    }\n    _onTrackEnded() {\n        logger.debug('track \"ended\" event');\n        this.safeEmit('trackended');\n    }\n    _handleTrack() {\n        if (!this._track)\n            return;\n        this._track.addEventListener('ended', this._onTrackEnded);\n    }\n    _destroyTrack() {\n        if (!this._track)\n            return;\n        try {\n            this._track.removeEventListener('ended', this._onTrackEnded);\n            // Just stop the track unless the app set stopTracks: false.\n            if (this._stopTracks)\n                this._track.stop();\n        }\n        catch (error) { }\n    }\n}\nexports.Producer = Producer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvUHJvZHVjZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvUHJvZHVjZXIuanM/MDE5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY29uc3QgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL0VuaGFuY2VkRXZlbnRFbWl0dGVyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdQcm9kdWNlcicpO1xuY2xhc3MgUHJvZHVjZXIgZXh0ZW5kcyBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xLkVuaGFuY2VkRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBAZW1pdHMgdHJhbnNwb3J0Y2xvc2VcbiAgICAgKiBAZW1pdHMgdHJhY2tlbmRlZFxuICAgICAqIEBlbWl0cyBAcmVwbGFjZXRyYWNrIC0gKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrIHwgbnVsbClcbiAgICAgKiBAZW1pdHMgQHNldG1heHNwYXRpYWxsYXllciAtIChzcGF0aWFsTGF5ZXI6IHN0cmluZylcbiAgICAgKiBAZW1pdHMgQHNldHJ0cGVuY29kaW5ncGFyYW1ldGVycyAtIChwYXJhbXM6IGFueSlcbiAgICAgKiBAZW1pdHMgQGdldHN0YXRzXG4gICAgICogQGVtaXRzIEBjbG9zZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgaWQsIGxvY2FsSWQsIHJ0cFNlbmRlciwgdHJhY2ssIHJ0cFBhcmFtZXRlcnMsIHN0b3BUcmFja3MsIGRpc2FibGVUcmFja09uUGF1c2UsIHplcm9SdHBPblBhdXNlLCBhcHBEYXRhIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gQ2xvc2VkIGZsYWcuXG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCknKTtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgdGhpcy5fbG9jYWxJZCA9IGxvY2FsSWQ7XG4gICAgICAgIHRoaXMuX3J0cFNlbmRlciA9IHJ0cFNlbmRlcjtcbiAgICAgICAgdGhpcy5fdHJhY2sgPSB0cmFjaztcbiAgICAgICAgdGhpcy5fa2luZCA9IHRyYWNrLmtpbmQ7XG4gICAgICAgIHRoaXMuX3J0cFBhcmFtZXRlcnMgPSBydHBQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBkaXNhYmxlVHJhY2tPblBhdXNlID8gIXRyYWNrLmVuYWJsZWQgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5fbWF4U3BhdGlhbExheWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zdG9wVHJhY2tzID0gc3RvcFRyYWNrcztcbiAgICAgICAgdGhpcy5fZGlzYWJsZVRyYWNrT25QYXVzZSA9IGRpc2FibGVUcmFja09uUGF1c2U7XG4gICAgICAgIHRoaXMuX3plcm9SdHBPblBhdXNlID0gemVyb1J0cE9uUGF1c2U7XG4gICAgICAgIHRoaXMuX2FwcERhdGEgPSBhcHBEYXRhO1xuICAgICAgICB0aGlzLl9vblRyYWNrRW5kZWQgPSB0aGlzLl9vblRyYWNrRW5kZWQuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gTk9URTogTWlub3IgaXNzdWUuIElmIHplcm9SdHBPblBhdXNlIGlzIHRydWUsIHdlIGNhbm5vdCBlbWl0IHRoZVxuICAgICAgICAvLyAnQHJlcGxhY2V0cmFjaycgZXZlbnQgaGVyZSwgc28gUlRDUnRwU2VuZGVyLnRyYWNrIHdvbid0IGJlIG51bGwuXG4gICAgICAgIHRoaXMuX2hhbmRsZVRyYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VyIGlkLlxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2NhbCBpZC5cbiAgICAgKi9cbiAgICBnZXQgbG9jYWxJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIFByb2R1Y2VyIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZWRpYSBraW5kLlxuICAgICAqL1xuICAgIGdldCBraW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2luZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlZCBSVENSdHBTZW5kZXIuXG4gICAgICovXG4gICAgZ2V0IHJ0cFNlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J0cFNlbmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFzc29jaWF0ZWQgdHJhY2suXG4gICAgICovXG4gICAgZ2V0IHRyYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJUUCBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGdldCBydHBQYXJhbWV0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnRwUGFyYW1ldGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgUHJvZHVjZXIgaXMgcGF1c2VkLlxuICAgICAqL1xuICAgIGdldCBwYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1heCBzcGF0aWFsIGxheWVyLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlciB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgbWF4U3BhdGlhbExheWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4U3BhdGlhbExheWVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHAgY3VzdG9tIGRhdGEuXG4gICAgICovXG4gICAgZ2V0IGFwcERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBEYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkIHNldHRlci5cbiAgICAgKi9cbiAgICBzZXQgYXBwRGF0YShhcHBEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IG92ZXJyaWRlIGFwcERhdGEgb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgUHJvZHVjZXIuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kZXN0cm95VHJhY2soKTtcbiAgICAgICAgdGhpcy5lbWl0KCdAY2xvc2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IHdhcyBjbG9zZWQuXG4gICAgICovXG4gICAgdHJhbnNwb3J0Q2xvc2VkKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3RyYW5zcG9ydENsb3NlZCgpJyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lUcmFjaygpO1xuICAgICAgICB0aGlzLnNhZmVFbWl0KCd0cmFuc3BvcnRjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYXNzb2NpYXRlZCBSVENSdHBTZW5kZXIgc3RhdHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3RhdHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQGdldHN0YXRzJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlcyBzZW5kaW5nIG1lZGlhLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3BhdXNlKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdwYXVzZSgpIHwgUHJvZHVjZXIgY2xvc2VkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3RyYWNrICYmIHRoaXMuX2Rpc2FibGVUcmFja09uUGF1c2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5femVyb1J0cE9uUGF1c2UpIHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoJ0ByZXBsYWNldHJhY2snLCBudWxsKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgc2VuZGluZyBtZWRpYS5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdyZXN1bWUoKSB8IFByb2R1Y2VyIGNsb3NlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fdHJhY2sgJiYgdGhpcy5fZGlzYWJsZVRyYWNrT25QYXVzZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2suZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3plcm9SdHBPblBhdXNlKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAcmVwbGFjZXRyYWNrJywgdGhpcy5fdHJhY2spXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgdHJhY2sgd2l0aCBhIG5ldyBvbmUgb3IgbnVsbC5cbiAgICAgKi9cbiAgICBhc3luYyByZXBsYWNlVHJhY2soeyB0cmFjayB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW3RyYWNrOiVvXScsIHRyYWNrKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgLy8gVGhpcyBtdXN0IGJlIGRvbmUgaGVyZS4gT3RoZXJ3aXNlIHRoZXJlIGlzIG5vIGNoYW5jZSB0byBzdG9wIHRoZSBnaXZlblxuICAgICAgICAgICAgLy8gdHJhY2suXG4gICAgICAgICAgICBpZiAodHJhY2sgJiYgdGhpcy5fc3RvcFRyYWNrcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJhY2sgJiYgdHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCd0cmFjayBlbmRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhpcyBpcyB0aGUgc2FtZSB0cmFjayBhcyB0aGUgY3VycmVudCBoYW5kbGVkIG9uZS5cbiAgICAgICAgaWYgKHRyYWNrID09PSB0aGlzLl90cmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSB8IHNhbWUgdHJhY2ssIGlnbm9yZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3plcm9SdHBPblBhdXNlIHx8ICF0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoJ0ByZXBsYWNldHJhY2snLCB0cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVzdHJveSB0aGUgcHJldmlvdXMgdHJhY2suXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lUcmFjaygpO1xuICAgICAgICAvLyBTZXQgdGhlIG5ldyB0cmFjay5cbiAgICAgICAgdGhpcy5fdHJhY2sgPSB0cmFjaztcbiAgICAgICAgLy8gSWYgdGhpcyBQcm9kdWNlciB3YXMgcGF1c2VkL3Jlc3VtZWQgYW5kIHRoZSBzdGF0ZSBvZiB0aGUgbmV3XG4gICAgICAgIC8vIHRyYWNrIGRvZXMgbm90IG1hdGNoLCBmaXggaXQuXG4gICAgICAgIGlmICh0aGlzLl90cmFjayAmJiB0aGlzLl9kaXNhYmxlVHJhY2tPblBhdXNlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZClcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BhdXNlZClcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFjay5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBlZmZlY3RpdmUgdHJhY2suXG4gICAgICAgIHRoaXMuX2hhbmRsZVRyYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpZGVvIG1heCBzcGF0aWFsIGxheWVyIHRvIGJlIHNlbnQuXG4gICAgICovXG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKHNwYXRpYWxMYXllcikge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fa2luZCAhPT0gJ3ZpZGVvJylcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgYSB2aWRlbyBQcm9kdWNlcicpO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3BhdGlhbExheWVyICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3BhdGlhbExheWVyJyk7XG4gICAgICAgIGlmIChzcGF0aWFsTGF5ZXIgPT09IHRoaXMuX21heFNwYXRpYWxMYXllcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgYXdhaXQgdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQHNldG1heHNwYXRpYWxsYXllcicsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIHRoaXMuX21heFNwYXRpYWxMYXllciA9IHNwYXRpYWxMYXllcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgRFNDUCB2YWx1ZS5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMocGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGFyYW1zJyk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoJ0BzZXRydHBlbmNvZGluZ3BhcmFtZXRlcnMnLCBwYXJhbXMpO1xuICAgIH1cbiAgICBfb25UcmFja0VuZGVkKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3RyYWNrIFwiZW5kZWRcIiBldmVudCcpO1xuICAgICAgICB0aGlzLnNhZmVFbWl0KCd0cmFja2VuZGVkJyk7XG4gICAgfVxuICAgIF9oYW5kbGVUcmFjaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFjaylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLl9vblRyYWNrRW5kZWQpO1xuICAgIH1cbiAgICBfZGVzdHJveVRyYWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RyYWNrKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLl9vblRyYWNrRW5kZWQpO1xuICAgICAgICAgICAgLy8gSnVzdCBzdG9wIHRoZSB0cmFjayB1bmxlc3MgdGhlIGFwcCBzZXQgc3RvcFRyYWNrczogZmFsc2UuXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RvcFRyYWNrcylcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFjay5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG59XG5leHBvcnRzLlByb2R1Y2VyID0gUHJvZHVjZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/Producer.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Transport.js":
/*!********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Transport.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst awaitqueue_1 = __webpack_require__(/*! awaitqueue */ \"./node_modules/awaitqueue/lib/index.js\");\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\nconst ortc = __webpack_require__(/*! ./ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\nconst Producer_1 = __webpack_require__(/*! ./Producer */ \"./node_modules/mediasoup-client/lib/Producer.js\");\nconst Consumer_1 = __webpack_require__(/*! ./Consumer */ \"./node_modules/mediasoup-client/lib/Consumer.js\");\nconst DataProducer_1 = __webpack_require__(/*! ./DataProducer */ \"./node_modules/mediasoup-client/lib/DataProducer.js\");\nconst DataConsumer_1 = __webpack_require__(/*! ./DataConsumer */ \"./node_modules/mediasoup-client/lib/DataConsumer.js\");\nconst logger = new Logger_1.Logger('Transport');\nclass Transport extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    /**\n     * @emits connect - (transportLocalParameters: any, callback: Function, errback: Function)\n     * @emits connectionstatechange - (connectionState: ConnectionState)\n     * @emits produce - (producerLocalParameters: any, callback: Function, errback: Function)\n     * @emits producedata - (dataProducerLocalParameters: any, callback: Function, errback: Function)\n     */\n    constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind }) {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Transport connection state.\n        this._connectionState = 'new';\n        // Map of Producers indexed by id.\n        this._producers = new Map();\n        // Map of Consumers indexed by id.\n        this._consumers = new Map();\n        // Map of DataProducers indexed by id.\n        this._dataProducers = new Map();\n        // Map of DataConsumers indexed by id.\n        this._dataConsumers = new Map();\n        // Whether the Consumer for RTP probation has been created.\n        this._probatorConsumerCreated = false;\n        // AwaitQueue instance to make async tasks happen sequentially.\n        this._awaitQueue = new awaitqueue_1.AwaitQueue({ ClosedErrorClass: errors_1.InvalidStateError });\n        logger.debug('constructor() [id:%s, direction:%s]', id, direction);\n        this._id = id;\n        this._direction = direction;\n        this._extendedRtpCapabilities = extendedRtpCapabilities;\n        this._canProduceByKind = canProduceByKind;\n        this._maxSctpMessageSize =\n            sctpParameters ? sctpParameters.maxMessageSize : null;\n        // Clone and sanitize additionalSettings.\n        additionalSettings = utils.clone(additionalSettings);\n        delete additionalSettings.iceServers;\n        delete additionalSettings.iceTransportPolicy;\n        delete additionalSettings.bundlePolicy;\n        delete additionalSettings.rtcpMuxPolicy;\n        delete additionalSettings.sdpSemantics;\n        this._handler = handlerFactory();\n        this._handler.run({\n            direction,\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            iceServers,\n            iceTransportPolicy,\n            additionalSettings,\n            proprietaryConstraints,\n            extendedRtpCapabilities\n        });\n        this._appData = appData;\n        this._handleHandler();\n    }\n    /**\n     * Transport id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Whether the Transport is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * Transport direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    /**\n     * RTC handler instance.\n     */\n    get handler() {\n        return this._handler;\n    }\n    /**\n     * Connection state.\n     */\n    get connectionState() {\n        return this._connectionState;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * Invalid setter.\n     */\n    set appData(appData) {\n        throw new Error('cannot override appData object');\n    }\n    /**\n     * Close the Transport.\n     */\n    close() {\n        if (this._closed)\n            return;\n        logger.debug('close()');\n        this._closed = true;\n        // Close the AwaitQueue.\n        this._awaitQueue.close();\n        // Close the handler.\n        this._handler.close();\n        // Close all Producers.\n        for (const producer of this._producers.values()) {\n            producer.transportClosed();\n        }\n        this._producers.clear();\n        // Close all Consumers.\n        for (const consumer of this._consumers.values()) {\n            consumer.transportClosed();\n        }\n        this._consumers.clear();\n        // Close all DataProducers.\n        for (const dataProducer of this._dataProducers.values()) {\n            dataProducer.transportClosed();\n        }\n        this._dataProducers.clear();\n        // Close all DataConsumers.\n        for (const dataConsumer of this._dataConsumers.values()) {\n            dataConsumer.transportClosed();\n        }\n        this._dataConsumers.clear();\n    }\n    /**\n     * Get associated Transport (RTCPeerConnection) stats.\n     *\n     * @returns {RTCStatsReport}\n     */\n    async getStats() {\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        return this._handler.getTransportStats();\n    }\n    /**\n     * Restart ICE connection.\n     */\n    async restartIce({ iceParameters }) {\n        logger.debug('restartIce()');\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (!iceParameters)\n            throw new TypeError('missing iceParameters');\n        // Enqueue command.\n        return this._awaitQueue.push(async () => this._handler.restartIce(iceParameters));\n    }\n    /**\n     * Update ICE servers.\n     */\n    async updateIceServers({ iceServers } = {}) {\n        logger.debug('updateIceServers()');\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (!Array.isArray(iceServers))\n            throw new TypeError('missing iceServers');\n        // Enqueue command.\n        return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers));\n    }\n    /**\n     * Create a Producer.\n     */\n    async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, appData = {} } = {}) {\n        logger.debug('produce() [track:%o]', track);\n        if (!track)\n            throw new TypeError('missing track');\n        else if (this._direction !== 'send')\n            throw new errors_1.UnsupportedError('not a sending Transport');\n        else if (!this._canProduceByKind[track.kind])\n            throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);\n        else if (track.readyState === 'ended')\n            throw new errors_1.InvalidStateError('track ended');\n        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\n            throw new TypeError('no \"connect\" listener set into this transport');\n        else if (this.listenerCount('produce') === 0)\n            throw new TypeError('no \"produce\" listener set into this transport');\n        else if (appData && typeof appData !== 'object')\n            throw new TypeError('if given, appData must be an object');\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            let normalizedEncodings;\n            if (encodings && !Array.isArray(encodings)) {\n                throw TypeError('encodings must be an array');\n            }\n            else if (encodings && encodings.length === 0) {\n                normalizedEncodings = undefined;\n            }\n            else if (encodings) {\n                normalizedEncodings = encodings\n                    .map((encoding) => {\n                    const normalizedEncoding = { active: true };\n                    if (encoding.active === false)\n                        normalizedEncoding.active = false;\n                    if (typeof encoding.dtx === 'boolean')\n                        normalizedEncoding.dtx = encoding.dtx;\n                    if (typeof encoding.scalabilityMode === 'string')\n                        normalizedEncoding.scalabilityMode = encoding.scalabilityMode;\n                    if (typeof encoding.scaleResolutionDownBy === 'number')\n                        normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;\n                    if (typeof encoding.maxBitrate === 'number')\n                        normalizedEncoding.maxBitrate = encoding.maxBitrate;\n                    if (typeof encoding.maxFramerate === 'number')\n                        normalizedEncoding.maxFramerate = encoding.maxFramerate;\n                    if (typeof encoding.adaptivePtime === 'boolean')\n                        normalizedEncoding.adaptivePtime = encoding.adaptivePtime;\n                    if (typeof encoding.priority === 'string')\n                        normalizedEncoding.priority = encoding.priority;\n                    if (typeof encoding.networkPriority === 'string')\n                        normalizedEncoding.networkPriority = encoding.networkPriority;\n                    return normalizedEncoding;\n                });\n            }\n            const { localId, rtpParameters, rtpSender } = await this._handler.send({\n                track,\n                encodings: normalizedEncodings,\n                codecOptions,\n                codec\n            });\n            try {\n                // This will fill rtpParameters's missing fields with default values.\n                ortc.validateRtpParameters(rtpParameters);\n                const { id } = await this.safeEmitAsPromise('produce', {\n                    kind: track.kind,\n                    rtpParameters,\n                    appData\n                });\n                const producer = new Producer_1.Producer({\n                    id,\n                    localId,\n                    rtpSender,\n                    track,\n                    rtpParameters,\n                    stopTracks,\n                    disableTrackOnPause,\n                    zeroRtpOnPause,\n                    appData\n                });\n                this._producers.set(producer.id, producer);\n                this._handleProducer(producer);\n                return producer;\n            }\n            catch (error) {\n                this._handler.stopSending(localId)\n                    .catch(() => { });\n                throw error;\n            }\n        })\n            // This catch is needed to stop the given track if the command above\n            // failed due to closed Transport.\n            .catch((error) => {\n            if (stopTracks) {\n                try {\n                    track.stop();\n                }\n                catch (error2) { }\n            }\n            throw error;\n        });\n    }\n    /**\n     * Create a Consumer to consume a remote Producer.\n     */\n    async consume({ id, producerId, kind, rtpParameters, appData = {} }) {\n        logger.debug('consume()');\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (this._direction !== 'recv')\n            throw new errors_1.UnsupportedError('not a receiving Transport');\n        else if (typeof id !== 'string')\n            throw new TypeError('missing id');\n        else if (typeof producerId !== 'string')\n            throw new TypeError('missing producerId');\n        else if (kind !== 'audio' && kind !== 'video')\n            throw new TypeError(`invalid kind '${kind}'`);\n        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\n            throw new TypeError('no \"connect\" listener set into this transport');\n        else if (appData && typeof appData !== 'object')\n            throw new TypeError('if given, appData must be an object');\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            // Ensure the device can consume it.\n            const canConsume = ortc.canReceive(rtpParameters, this._extendedRtpCapabilities);\n            if (!canConsume)\n                throw new errors_1.UnsupportedError('cannot consume this Producer');\n            const { localId, rtpReceiver, track } = await this._handler.receive({ trackId: id, kind, rtpParameters });\n            const consumer = new Consumer_1.Consumer({\n                id,\n                localId,\n                producerId,\n                rtpReceiver,\n                track,\n                rtpParameters,\n                appData\n            });\n            this._consumers.set(consumer.id, consumer);\n            this._handleConsumer(consumer);\n            // If this is the first video Consumer and the Consumer for RTP probation\n            // has not yet been created, create it now.\n            if (!this._probatorConsumerCreated && kind === 'video') {\n                try {\n                    const probatorRtpParameters = ortc.generateProbatorRtpParameters(consumer.rtpParameters);\n                    await this._handler.receive({\n                        trackId: 'probator',\n                        kind: 'video',\n                        rtpParameters: probatorRtpParameters\n                    });\n                    logger.debug('consume() | Consumer for RTP probation created');\n                    this._probatorConsumerCreated = true;\n                }\n                catch (error) {\n                    logger.error('consume() | failed to create Consumer for RTP probation:%o', error);\n                }\n            }\n            return consumer;\n        });\n    }\n    /**\n     * Create a DataProducer\n     */\n    async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, priority = 'low', label = '', protocol = '', appData = {} } = {}) {\n        logger.debug('produceData()');\n        if (this._direction !== 'send')\n            throw new errors_1.UnsupportedError('not a sending Transport');\n        else if (!this._maxSctpMessageSize)\n            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n        else if (!['very-low', 'low', 'medium', 'high'].includes(priority))\n            throw new TypeError('wrong priority');\n        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\n            throw new TypeError('no \"connect\" listener set into this transport');\n        else if (this.listenerCount('producedata') === 0)\n            throw new TypeError('no \"producedata\" listener set into this transport');\n        else if (appData && typeof appData !== 'object')\n            throw new TypeError('if given, appData must be an object');\n        if (maxPacketLifeTime || maxRetransmits)\n            ordered = false;\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({\n                ordered,\n                maxPacketLifeTime,\n                maxRetransmits,\n                priority,\n                label,\n                protocol\n            });\n            // This will fill sctpStreamParameters's missing fields with default values.\n            ortc.validateSctpStreamParameters(sctpStreamParameters);\n            const { id } = await this.safeEmitAsPromise('producedata', {\n                sctpStreamParameters,\n                label,\n                protocol,\n                appData\n            });\n            const dataProducer = new DataProducer_1.DataProducer({ id, dataChannel, sctpStreamParameters, appData });\n            this._dataProducers.set(dataProducer.id, dataProducer);\n            this._handleDataProducer(dataProducer);\n            return dataProducer;\n        });\n    }\n    /**\n     * Create a DataConsumer\n     */\n    async consumeData({ id, dataProducerId, sctpStreamParameters, label = '', protocol = '', appData = {} }) {\n        logger.debug('consumeData()');\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (this._direction !== 'recv')\n            throw new errors_1.UnsupportedError('not a receiving Transport');\n        else if (!this._maxSctpMessageSize)\n            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n        else if (typeof id !== 'string')\n            throw new TypeError('missing id');\n        else if (typeof dataProducerId !== 'string')\n            throw new TypeError('missing dataProducerId');\n        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\n            throw new TypeError('no \"connect\" listener set into this transport');\n        else if (appData && typeof appData !== 'object')\n            throw new TypeError('if given, appData must be an object');\n        // This may throw.\n        ortc.validateSctpStreamParameters(sctpStreamParameters);\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            const { dataChannel } = await this._handler.receiveDataChannel({\n                sctpStreamParameters,\n                label,\n                protocol\n            });\n            const dataConsumer = new DataConsumer_1.DataConsumer({\n                id,\n                dataProducerId,\n                dataChannel,\n                sctpStreamParameters,\n                appData\n            });\n            this._dataConsumers.set(dataConsumer.id, dataConsumer);\n            this._handleDataConsumer(dataConsumer);\n            return dataConsumer;\n        });\n    }\n    _handleHandler() {\n        const handler = this._handler;\n        handler.on('@connect', ({ dtlsParameters }, callback, errback) => {\n            if (this._closed) {\n                errback(new errors_1.InvalidStateError('closed'));\n                return;\n            }\n            this.safeEmit('connect', { dtlsParameters }, callback, errback);\n        });\n        handler.on('@connectionstatechange', (connectionState) => {\n            if (connectionState === this._connectionState)\n                return;\n            logger.debug('connection state changed to %s', connectionState);\n            this._connectionState = connectionState;\n            if (!this._closed)\n                this.safeEmit('connectionstatechange', connectionState);\n        });\n    }\n    _handleProducer(producer) {\n        producer.on('@close', () => {\n            this._producers.delete(producer.id);\n            if (this._closed)\n                return;\n            this._awaitQueue.push(async () => this._handler.stopSending(producer.localId))\n                .catch((error) => logger.warn('producer.close() failed:%o', error));\n        });\n        producer.on('@replacetrack', (track, callback, errback) => {\n            this._awaitQueue.push(async () => this._handler.replaceTrack(producer.localId, track))\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {\n            this._awaitQueue.push(async () => (this._handler.setMaxSpatialLayer(producer.localId, spatialLayer)))\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@setrtpencodingparameters', (params, callback, errback) => {\n            this._awaitQueue.push(async () => (this._handler.setRtpEncodingParameters(producer.localId, params)))\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@getstats', (callback, errback) => {\n            if (this._closed)\n                return errback(new errors_1.InvalidStateError('closed'));\n            this._handler.getSenderStats(producer.localId)\n                .then(callback)\n                .catch(errback);\n        });\n    }\n    _handleConsumer(consumer) {\n        consumer.on('@close', () => {\n            this._consumers.delete(consumer.id);\n            if (this._closed)\n                return;\n            this._awaitQueue.push(async () => this._handler.stopReceiving(consumer.localId))\n                .catch(() => { });\n        });\n        consumer.on('@getstats', (callback, errback) => {\n            if (this._closed)\n                return errback(new errors_1.InvalidStateError('closed'));\n            this._handler.getReceiverStats(consumer.localId)\n                .then(callback)\n                .catch(errback);\n        });\n    }\n    _handleDataProducer(dataProducer) {\n        dataProducer.on('@close', () => {\n            this._dataProducers.delete(dataProducer.id);\n        });\n    }\n    _handleDataConsumer(dataConsumer) {\n        dataConsumer.on('@close', () => {\n            this._dataConsumers.delete(dataConsumer.id);\n        });\n    }\n}\nexports.Transport = Transport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvVHJhbnNwb3J0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL1RyYW5zcG9ydC5qcz81MjVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYXdhaXRxdWV1ZV8xID0gcmVxdWlyZShcImF3YWl0cXVldWVcIik7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcbmNvbnN0IEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEgPSByZXF1aXJlKFwiLi9FbmhhbmNlZEV2ZW50RW1pdHRlclwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IG9ydGMgPSByZXF1aXJlKFwiLi9vcnRjXCIpO1xuY29uc3QgUHJvZHVjZXJfMSA9IHJlcXVpcmUoXCIuL1Byb2R1Y2VyXCIpO1xuY29uc3QgQ29uc3VtZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnN1bWVyXCIpO1xuY29uc3QgRGF0YVByb2R1Y2VyXzEgPSByZXF1aXJlKFwiLi9EYXRhUHJvZHVjZXJcIik7XG5jb25zdCBEYXRhQ29uc3VtZXJfMSA9IHJlcXVpcmUoXCIuL0RhdGFDb25zdW1lclwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ1RyYW5zcG9ydCcpO1xuY2xhc3MgVHJhbnNwb3J0IGV4dGVuZHMgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMS5FbmhhbmNlZEV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogQGVtaXRzIGNvbm5lY3QgLSAodHJhbnNwb3J0TG9jYWxQYXJhbWV0ZXJzOiBhbnksIGNhbGxiYWNrOiBGdW5jdGlvbiwgZXJyYmFjazogRnVuY3Rpb24pXG4gICAgICogQGVtaXRzIGNvbm5lY3Rpb25zdGF0ZWNoYW5nZSAtIChjb25uZWN0aW9uU3RhdGU6IENvbm5lY3Rpb25TdGF0ZSlcbiAgICAgKiBAZW1pdHMgcHJvZHVjZSAtIChwcm9kdWNlckxvY2FsUGFyYW1ldGVyczogYW55LCBjYWxsYmFjazogRnVuY3Rpb24sIGVycmJhY2s6IEZ1bmN0aW9uKVxuICAgICAqIEBlbWl0cyBwcm9kdWNlZGF0YSAtIChkYXRhUHJvZHVjZXJMb2NhbFBhcmFtZXRlcnM6IGFueSwgY2FsbGJhY2s6IEZ1bmN0aW9uLCBlcnJiYWNrOiBGdW5jdGlvbilcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGRpcmVjdGlvbiwgaWQsIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGFwcERhdGEsIGhhbmRsZXJGYWN0b3J5LCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcywgY2FuUHJvZHVjZUJ5S2luZCB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIENsb3NlZCBmbGFnLlxuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gVHJhbnNwb3J0IGNvbm5lY3Rpb24gc3RhdGUuXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSA9ICduZXcnO1xuICAgICAgICAvLyBNYXAgb2YgUHJvZHVjZXJzIGluZGV4ZWQgYnkgaWQuXG4gICAgICAgIHRoaXMuX3Byb2R1Y2VycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTWFwIG9mIENvbnN1bWVycyBpbmRleGVkIGJ5IGlkLlxuICAgICAgICB0aGlzLl9jb25zdW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE1hcCBvZiBEYXRhUHJvZHVjZXJzIGluZGV4ZWQgYnkgaWQuXG4gICAgICAgIHRoaXMuX2RhdGFQcm9kdWNlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE1hcCBvZiBEYXRhQ29uc3VtZXJzIGluZGV4ZWQgYnkgaWQuXG4gICAgICAgIHRoaXMuX2RhdGFDb25zdW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFdoZXRoZXIgdGhlIENvbnN1bWVyIGZvciBSVFAgcHJvYmF0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX3Byb2JhdG9yQ29uc3VtZXJDcmVhdGVkID0gZmFsc2U7XG4gICAgICAgIC8vIEF3YWl0UXVldWUgaW5zdGFuY2UgdG8gbWFrZSBhc3luYyB0YXNrcyBoYXBwZW4gc2VxdWVudGlhbGx5LlxuICAgICAgICB0aGlzLl9hd2FpdFF1ZXVlID0gbmV3IGF3YWl0cXVldWVfMS5Bd2FpdFF1ZXVlKHsgQ2xvc2VkRXJyb3JDbGFzczogZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IgfSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKSBbaWQ6JXMsIGRpcmVjdGlvbjolc10nLCBpZCwgZGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyA9IGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB0aGlzLl9jYW5Qcm9kdWNlQnlLaW5kID0gY2FuUHJvZHVjZUJ5S2luZDtcbiAgICAgICAgdGhpcy5fbWF4U2N0cE1lc3NhZ2VTaXplID1cbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzID8gc2N0cFBhcmFtZXRlcnMubWF4TWVzc2FnZVNpemUgOiBudWxsO1xuICAgICAgICAvLyBDbG9uZSBhbmQgc2FuaXRpemUgYWRkaXRpb25hbFNldHRpbmdzLlxuICAgICAgICBhZGRpdGlvbmFsU2V0dGluZ3MgPSB1dGlscy5jbG9uZShhZGRpdGlvbmFsU2V0dGluZ3MpO1xuICAgICAgICBkZWxldGUgYWRkaXRpb25hbFNldHRpbmdzLmljZVNlcnZlcnM7XG4gICAgICAgIGRlbGV0ZSBhZGRpdGlvbmFsU2V0dGluZ3MuaWNlVHJhbnNwb3J0UG9saWN5O1xuICAgICAgICBkZWxldGUgYWRkaXRpb25hbFNldHRpbmdzLmJ1bmRsZVBvbGljeTtcbiAgICAgICAgZGVsZXRlIGFkZGl0aW9uYWxTZXR0aW5ncy5ydGNwTXV4UG9saWN5O1xuICAgICAgICBkZWxldGUgYWRkaXRpb25hbFNldHRpbmdzLnNkcFNlbWFudGljcztcbiAgICAgICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXJGYWN0b3J5KCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZXIucnVuKHtcbiAgICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZVNlcnZlcnMsXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3ksXG4gICAgICAgICAgICBhZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgICAgICBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLFxuICAgICAgICAgICAgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2FwcERhdGEgPSBhcHBEYXRhO1xuICAgICAgICB0aGlzLl9oYW5kbGVIYW5kbGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBpZC5cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgVHJhbnNwb3J0IGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXJlY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJUQyBoYW5kbGVyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBoYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdGlvbiBzdGF0ZS5cbiAgICAgKi9cbiAgICBnZXQgY29ubmVjdGlvblN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHAgY3VzdG9tIGRhdGEuXG4gICAgICovXG4gICAgZ2V0IGFwcERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBEYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkIHNldHRlci5cbiAgICAgKi9cbiAgICBzZXQgYXBwRGF0YShhcHBEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IG92ZXJyaWRlIGFwcERhdGEgb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBUcmFuc3BvcnQuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICAvLyBDbG9zZSB0aGUgQXdhaXRRdWV1ZS5cbiAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZS5jbG9zZSgpO1xuICAgICAgICAvLyBDbG9zZSB0aGUgaGFuZGxlci5cbiAgICAgICAgdGhpcy5faGFuZGxlci5jbG9zZSgpO1xuICAgICAgICAvLyBDbG9zZSBhbGwgUHJvZHVjZXJzLlxuICAgICAgICBmb3IgKGNvbnN0IHByb2R1Y2VyIG9mIHRoaXMuX3Byb2R1Y2Vycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcHJvZHVjZXIudHJhbnNwb3J0Q2xvc2VkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvZHVjZXJzLmNsZWFyKCk7XG4gICAgICAgIC8vIENsb3NlIGFsbCBDb25zdW1lcnMuXG4gICAgICAgIGZvciAoY29uc3QgY29uc3VtZXIgb2YgdGhpcy5fY29uc3VtZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjb25zdW1lci50cmFuc3BvcnRDbG9zZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25zdW1lcnMuY2xlYXIoKTtcbiAgICAgICAgLy8gQ2xvc2UgYWxsIERhdGFQcm9kdWNlcnMuXG4gICAgICAgIGZvciAoY29uc3QgZGF0YVByb2R1Y2VyIG9mIHRoaXMuX2RhdGFQcm9kdWNlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGRhdGFQcm9kdWNlci50cmFuc3BvcnRDbG9zZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhUHJvZHVjZXJzLmNsZWFyKCk7XG4gICAgICAgIC8vIENsb3NlIGFsbCBEYXRhQ29uc3VtZXJzLlxuICAgICAgICBmb3IgKGNvbnN0IGRhdGFDb25zdW1lciBvZiB0aGlzLl9kYXRhQ29uc3VtZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBkYXRhQ29uc3VtZXIudHJhbnNwb3J0Q2xvc2VkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGF0YUNvbnN1bWVycy5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYXNzb2NpYXRlZCBUcmFuc3BvcnQgKFJUQ1BlZXJDb25uZWN0aW9uKSBzdGF0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSVENTdGF0c1JlcG9ydH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdGF0cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVyLmdldFRyYW5zcG9ydFN0YXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RhcnQgSUNFIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgcmVzdGFydEljZSh7IGljZVBhcmFtZXRlcnMgfSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgZWxzZSBpZiAoIWljZVBhcmFtZXRlcnMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGljZVBhcmFtZXRlcnMnKTtcbiAgICAgICAgLy8gRW5xdWV1ZSBjb21tYW5kLlxuICAgICAgICByZXR1cm4gdGhpcy5fYXdhaXRRdWV1ZS5wdXNoKGFzeW5jICgpID0+IHRoaXMuX2hhbmRsZXIucmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBJQ0Ugc2VydmVycy5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKHsgaWNlU2VydmVycyB9ID0ge30pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGljZVNlcnZlcnMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBpY2VTZXJ2ZXJzJyk7XG4gICAgICAgIC8vIEVucXVldWUgY29tbWFuZC5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F3YWl0UXVldWUucHVzaChhc3luYyAoKSA9PiB0aGlzLl9oYW5kbGVyLnVwZGF0ZUljZVNlcnZlcnMoaWNlU2VydmVycykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBQcm9kdWNlci5cbiAgICAgKi9cbiAgICBhc3luYyBwcm9kdWNlKHsgdHJhY2ssIGVuY29kaW5ncywgY29kZWNPcHRpb25zLCBjb2RlYywgc3RvcFRyYWNrcyA9IHRydWUsIGRpc2FibGVUcmFja09uUGF1c2UgPSB0cnVlLCB6ZXJvUnRwT25QYXVzZSA9IGZhbHNlLCBhcHBEYXRhID0ge30gfSA9IHt9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncHJvZHVjZSgpIFt0cmFjazolb10nLCB0cmFjayk7XG4gICAgICAgIGlmICghdHJhY2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIHRyYWNrJyk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBhIHNlbmRpbmcgVHJhbnNwb3J0Jyk7XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9jYW5Qcm9kdWNlQnlLaW5kW3RyYWNrLmtpbmRdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoYGNhbm5vdCBwcm9kdWNlICR7dHJhY2sua2luZH1gKTtcbiAgICAgICAgZWxzZSBpZiAodHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJylcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcigndHJhY2sgZW5kZWQnKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdjb25uZWN0JykgPT09IDAgJiYgdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnbmV3JylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIFwiY29ubmVjdFwiIGxpc3RlbmVyIHNldCBpbnRvIHRoaXMgdHJhbnNwb3J0Jyk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgncHJvZHVjZScpID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gXCJwcm9kdWNlXCIgbGlzdGVuZXIgc2V0IGludG8gdGhpcyB0cmFuc3BvcnQnKTtcbiAgICAgICAgZWxzZSBpZiAoYXBwRGF0YSAmJiB0eXBlb2YgYXBwRGF0YSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZiBnaXZlbiwgYXBwRGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAvLyBFbnF1ZXVlIGNvbW1hbmQuXG4gICAgICAgIHJldHVybiB0aGlzLl9hd2FpdFF1ZXVlLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IG5vcm1hbGl6ZWRFbmNvZGluZ3M7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmdzICYmICFBcnJheS5pc0FycmF5KGVuY29kaW5ncykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2VuY29kaW5ncyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFbmNvZGluZ3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmdzID0gZW5jb2RpbmdzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGVuY29kaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFbmNvZGluZyA9IHsgYWN0aXZlOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZy5hY3RpdmUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nLmR0eCA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLmR0eCA9IGVuY29kaW5nLmR0eDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9IGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5tYXhCaXRyYXRlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFbmNvZGluZy5tYXhCaXRyYXRlID0gZW5jb2RpbmcubWF4Qml0cmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLm1heEZyYW1lcmF0ZSA9IGVuY29kaW5nLm1heEZyYW1lcmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5hZGFwdGl2ZVB0aW1lID09PSAnYm9vbGVhbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmcuYWRhcHRpdmVQdGltZSA9IGVuY29kaW5nLmFkYXB0aXZlUHRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcucHJpb3JpdHkgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLnByaW9yaXR5ID0gZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcubmV0d29ya1ByaW9yaXR5ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFbmNvZGluZy5uZXR3b3JrUHJpb3JpdHkgPSBlbmNvZGluZy5uZXR3b3JrUHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRW5jb2Rpbmc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGxvY2FsSWQsIHJ0cFBhcmFtZXRlcnMsIHJ0cFNlbmRlciB9ID0gYXdhaXQgdGhpcy5faGFuZGxlci5zZW5kKHtcbiAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICBlbmNvZGluZ3M6IG5vcm1hbGl6ZWRFbmNvZGluZ3MsXG4gICAgICAgICAgICAgICAgY29kZWNPcHRpb25zLFxuICAgICAgICAgICAgICAgIGNvZGVjXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGZpbGwgcnRwUGFyYW1ldGVycydzIG1pc3NpbmcgZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgb3J0Yy52YWxpZGF0ZVJ0cFBhcmFtZXRlcnMocnRwUGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCB9ID0gYXdhaXQgdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgncHJvZHVjZScsIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogdHJhY2sua2luZCxcbiAgICAgICAgICAgICAgICAgICAgcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgYXBwRGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2R1Y2VyID0gbmV3IFByb2R1Y2VyXzEuUHJvZHVjZXIoe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgICAgICAgICAgcnRwU2VuZGVyLFxuICAgICAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICAgICAgcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgc3RvcFRyYWNrcyxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVRyYWNrT25QYXVzZSxcbiAgICAgICAgICAgICAgICAgICAgemVyb1J0cE9uUGF1c2UsXG4gICAgICAgICAgICAgICAgICAgIGFwcERhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9kdWNlcnMuc2V0KHByb2R1Y2VyLmlkLCBwcm9kdWNlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlUHJvZHVjZXIocHJvZHVjZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9kdWNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuc3RvcFNlbmRpbmcobG9jYWxJZClcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAvLyBUaGlzIGNhdGNoIGlzIG5lZWRlZCB0byBzdG9wIHRoZSBnaXZlbiB0cmFjayBpZiB0aGUgY29tbWFuZCBhYm92ZVxuICAgICAgICAgICAgLy8gZmFpbGVkIGR1ZSB0byBjbG9zZWQgVHJhbnNwb3J0LlxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKHN0b3BUcmFja3MpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBDb25zdW1lciB0byBjb25zdW1lIGEgcmVtb3RlIFByb2R1Y2VyLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbnN1bWUoeyBpZCwgcHJvZHVjZXJJZCwga2luZCwgcnRwUGFyYW1ldGVycywgYXBwRGF0YSA9IHt9IH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjb25zdW1lKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBhIHJlY2VpdmluZyBUcmFuc3BvcnQnKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgaWQnKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHByb2R1Y2VySWQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBwcm9kdWNlcklkJyk7XG4gICAgICAgIGVsc2UgaWYgKGtpbmQgIT09ICdhdWRpbycgJiYga2luZCAhPT0gJ3ZpZGVvJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQga2luZCAnJHtraW5kfSdgKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdjb25uZWN0JykgPT09IDAgJiYgdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnbmV3JylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIFwiY29ubmVjdFwiIGxpc3RlbmVyIHNldCBpbnRvIHRoaXMgdHJhbnNwb3J0Jyk7XG4gICAgICAgIGVsc2UgaWYgKGFwcERhdGEgJiYgdHlwZW9mIGFwcERhdGEgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWYgZ2l2ZW4sIGFwcERhdGEgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgLy8gRW5xdWV1ZSBjb21tYW5kLlxuICAgICAgICByZXR1cm4gdGhpcy5fYXdhaXRRdWV1ZS5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZGV2aWNlIGNhbiBjb25zdW1lIGl0LlxuICAgICAgICAgICAgY29uc3QgY2FuQ29uc3VtZSA9IG9ydGMuY2FuUmVjZWl2ZShydHBQYXJhbWV0ZXJzLCB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICBpZiAoIWNhbkNvbnN1bWUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ2Nhbm5vdCBjb25zdW1lIHRoaXMgUHJvZHVjZXInKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbG9jYWxJZCwgcnRwUmVjZWl2ZXIsIHRyYWNrIH0gPSBhd2FpdCB0aGlzLl9oYW5kbGVyLnJlY2VpdmUoeyB0cmFja0lkOiBpZCwga2luZCwgcnRwUGFyYW1ldGVycyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnN1bWVyID0gbmV3IENvbnN1bWVyXzEuQ29uc3VtZXIoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICAgICAgcHJvZHVjZXJJZCxcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlcixcbiAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGFwcERhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZXJzLnNldChjb25zdW1lci5pZCwgY29uc3VtZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlQ29uc3VtZXIoY29uc3VtZXIpO1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdmlkZW8gQ29uc3VtZXIgYW5kIHRoZSBDb25zdW1lciBmb3IgUlRQIHByb2JhdGlvblxuICAgICAgICAgICAgLy8gaGFzIG5vdCB5ZXQgYmVlbiBjcmVhdGVkLCBjcmVhdGUgaXQgbm93LlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcm9iYXRvckNvbnN1bWVyQ3JlYXRlZCAmJiBraW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvYmF0b3JSdHBQYXJhbWV0ZXJzID0gb3J0Yy5nZW5lcmF0ZVByb2JhdG9yUnRwUGFyYW1ldGVycyhjb25zdW1lci5ydHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5faGFuZGxlci5yZWNlaXZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrSWQ6ICdwcm9iYXRvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiAndmlkZW8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogcHJvYmF0b3JSdHBQYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN1bWUoKSB8IENvbnN1bWVyIGZvciBSVFAgcHJvYmF0aW9uIGNyZWF0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvYmF0b3JDb25zdW1lckNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdjb25zdW1lKCkgfCBmYWlsZWQgdG8gY3JlYXRlIENvbnN1bWVyIGZvciBSVFAgcHJvYmF0aW9uOiVvJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25zdW1lcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIERhdGFQcm9kdWNlclxuICAgICAqL1xuICAgIGFzeW5jIHByb2R1Y2VEYXRhKHsgb3JkZXJlZCA9IHRydWUsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgcHJpb3JpdHkgPSAnbG93JywgbGFiZWwgPSAnJywgcHJvdG9jb2wgPSAnJywgYXBwRGF0YSA9IHt9IH0gPSB7fSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Byb2R1Y2VEYXRhKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBhIHNlbmRpbmcgVHJhbnNwb3J0Jyk7XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9tYXhTY3RwTWVzc2FnZVNpemUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignU0NUUCBub3QgZW5hYmxlZCBieSByZW1vdGUgVHJhbnNwb3J0Jyk7XG4gICAgICAgIGVsc2UgaWYgKCFbJ3ZlcnktbG93JywgJ2xvdycsICdtZWRpdW0nLCAnaGlnaCddLmluY2x1ZGVzKHByaW9yaXR5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dyb25nIHByaW9yaXR5Jyk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnY29ubmVjdCcpID09PSAwICYmIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSA9PT0gJ25ldycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBcImNvbm5lY3RcIiBsaXN0ZW5lciBzZXQgaW50byB0aGlzIHRyYW5zcG9ydCcpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ3Byb2R1Y2VkYXRhJykgPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBcInByb2R1Y2VkYXRhXCIgbGlzdGVuZXIgc2V0IGludG8gdGhpcyB0cmFuc3BvcnQnKTtcbiAgICAgICAgZWxzZSBpZiAoYXBwRGF0YSAmJiB0eXBlb2YgYXBwRGF0YSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZiBnaXZlbiwgYXBwRGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICBpZiAobWF4UGFja2V0TGlmZVRpbWUgfHwgbWF4UmV0cmFuc21pdHMpXG4gICAgICAgICAgICBvcmRlcmVkID0gZmFsc2U7XG4gICAgICAgIC8vIEVucXVldWUgY29tbWFuZC5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F3YWl0UXVldWUucHVzaChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9ID0gYXdhaXQgdGhpcy5faGFuZGxlci5zZW5kRGF0YUNoYW5uZWwoe1xuICAgICAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICAgICAgcHJvdG9jb2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGZpbGwgc2N0cFN0cmVhbVBhcmFtZXRlcnMncyBtaXNzaW5nIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICAgICAgb3J0Yy52YWxpZGF0ZVNjdHBTdHJlYW1QYXJhbWV0ZXJzKHNjdHBTdHJlYW1QYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQgfSA9IGF3YWl0IHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoJ3Byb2R1Y2VkYXRhJywge1xuICAgICAgICAgICAgICAgIHNjdHBTdHJlYW1QYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgICAgIGFwcERhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZGF0YVByb2R1Y2VyID0gbmV3IERhdGFQcm9kdWNlcl8xLkRhdGFQcm9kdWNlcih7IGlkLCBkYXRhQ2hhbm5lbCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGFwcERhdGEgfSk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhUHJvZHVjZXJzLnNldChkYXRhUHJvZHVjZXIuaWQsIGRhdGFQcm9kdWNlcik7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVEYXRhUHJvZHVjZXIoZGF0YVByb2R1Y2VyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhUHJvZHVjZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBEYXRhQ29uc3VtZXJcbiAgICAgKi9cbiAgICBhc3luYyBjb25zdW1lRGF0YSh7IGlkLCBkYXRhUHJvZHVjZXJJZCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsID0gJycsIHByb3RvY29sID0gJycsIGFwcERhdGEgPSB7fSB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3VtZURhdGEoKScpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGEgcmVjZWl2aW5nIFRyYW5zcG9ydCcpO1xuICAgICAgICBlbHNlIGlmICghdGhpcy5fbWF4U2N0cE1lc3NhZ2VTaXplKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ1NDVFAgbm90IGVuYWJsZWQgYnkgcmVtb3RlIFRyYW5zcG9ydCcpO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBpZCcpO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGF0YVByb2R1Y2VySWQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBkYXRhUHJvZHVjZXJJZCcpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Nvbm5lY3QnKSA9PT0gMCAmJiB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPT09ICduZXcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gXCJjb25uZWN0XCIgbGlzdGVuZXIgc2V0IGludG8gdGhpcyB0cmFuc3BvcnQnKTtcbiAgICAgICAgZWxzZSBpZiAoYXBwRGF0YSAmJiB0eXBlb2YgYXBwRGF0YSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZiBnaXZlbiwgYXBwRGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgb3J0Yy52YWxpZGF0ZVNjdHBTdHJlYW1QYXJhbWV0ZXJzKHNjdHBTdHJlYW1QYXJhbWV0ZXJzKTtcbiAgICAgICAgLy8gRW5xdWV1ZSBjb21tYW5kLlxuICAgICAgICByZXR1cm4gdGhpcy5fYXdhaXRRdWV1ZS5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YUNoYW5uZWwgfSA9IGF3YWl0IHRoaXMuX2hhbmRsZXIucmVjZWl2ZURhdGFDaGFubmVsKHtcbiAgICAgICAgICAgICAgICBzY3RwU3RyZWFtUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhQ29uc3VtZXIgPSBuZXcgRGF0YUNvbnN1bWVyXzEuRGF0YUNvbnN1bWVyKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvZHVjZXJJZCxcbiAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbCxcbiAgICAgICAgICAgICAgICBzY3RwU3RyZWFtUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBhcHBEYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFDb25zdW1lcnMuc2V0KGRhdGFDb25zdW1lci5pZCwgZGF0YUNvbnN1bWVyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZURhdGFDb25zdW1lcihkYXRhQ29uc3VtZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFDb25zdW1lcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9oYW5kbGVIYW5kbGVyKCkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5faGFuZGxlcjtcbiAgICAgICAgaGFuZGxlci5vbignQGNvbm5lY3QnLCAoeyBkdGxzUGFyYW1ldGVycyB9LCBjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIGVycmJhY2sobmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlci5vbignQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIChjb25uZWN0aW9uU3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2Nvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZCB0byAlcycsIGNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPSBjb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2hhbmRsZVByb2R1Y2VyKHByb2R1Y2VyKSB7XG4gICAgICAgIHByb2R1Y2VyLm9uKCdAY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm9kdWNlcnMuZGVsZXRlKHByb2R1Y2VyLmlkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZS5wdXNoKGFzeW5jICgpID0+IHRoaXMuX2hhbmRsZXIuc3RvcFNlbmRpbmcocHJvZHVjZXIubG9jYWxJZCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gbG9nZ2VyLndhcm4oJ3Byb2R1Y2VyLmNsb3NlKCkgZmFpbGVkOiVvJywgZXJyb3IpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2R1Y2VyLm9uKCdAcmVwbGFjZXRyYWNrJywgKHRyYWNrLCBjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZS5wdXNoKGFzeW5jICgpID0+IHRoaXMuX2hhbmRsZXIucmVwbGFjZVRyYWNrKHByb2R1Y2VyLmxvY2FsSWQsIHRyYWNrKSlcbiAgICAgICAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9kdWNlci5vbignQHNldG1heHNwYXRpYWxsYXllcicsIChzcGF0aWFsTGF5ZXIsIGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hd2FpdFF1ZXVlLnB1c2goYXN5bmMgKCkgPT4gKHRoaXMuX2hhbmRsZXIuc2V0TWF4U3BhdGlhbExheWVyKHByb2R1Y2VyLmxvY2FsSWQsIHNwYXRpYWxMYXllcikpKVxuICAgICAgICAgICAgICAgIC50aGVuKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2R1Y2VyLm9uKCdAc2V0cnRwZW5jb2RpbmdwYXJhbWV0ZXJzJywgKHBhcmFtcywgY2FsbGJhY2ssIGVycmJhY2spID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2F3YWl0UXVldWUucHVzaChhc3luYyAoKSA9PiAodGhpcy5faGFuZGxlci5zZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMocHJvZHVjZXIubG9jYWxJZCwgcGFyYW1zKSkpXG4gICAgICAgICAgICAgICAgLnRoZW4oY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycmJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvZHVjZXIub24oJ0BnZXRzdGF0cycsIChjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyYmFjayhuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpKTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuZ2V0U2VuZGVyU3RhdHMocHJvZHVjZXIubG9jYWxJZClcbiAgICAgICAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaGFuZGxlQ29uc3VtZXIoY29uc3VtZXIpIHtcbiAgICAgICAgY29uc3VtZXIub24oJ0BjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVycy5kZWxldGUoY29uc3VtZXIuaWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9hd2FpdFF1ZXVlLnB1c2goYXN5bmMgKCkgPT4gdGhpcy5faGFuZGxlci5zdG9wUmVjZWl2aW5nKGNvbnN1bWVyLmxvY2FsSWQpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3VtZXIub24oJ0BnZXRzdGF0cycsIChjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyYmFjayhuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpKTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuZ2V0UmVjZWl2ZXJTdGF0cyhjb25zdW1lci5sb2NhbElkKVxuICAgICAgICAgICAgICAgIC50aGVuKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9oYW5kbGVEYXRhUHJvZHVjZXIoZGF0YVByb2R1Y2VyKSB7XG4gICAgICAgIGRhdGFQcm9kdWNlci5vbignQGNsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGF0YVByb2R1Y2Vycy5kZWxldGUoZGF0YVByb2R1Y2VyLmlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9oYW5kbGVEYXRhQ29uc3VtZXIoZGF0YUNvbnN1bWVyKSB7XG4gICAgICAgIGRhdGFDb25zdW1lci5vbignQGNsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGF0YUNvbnN1bWVycy5kZWxldGUoZGF0YUNvbnN1bWVyLmlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc3BvcnQgPSBUcmFuc3BvcnQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/Transport.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/errors.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Error indicating not support for something.\n */\nclass UnsupportedError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'UnsupportedError';\n        if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.\n         {\n            // @ts-ignore\n            Error.captureStackTrace(this, UnsupportedError);\n        }\n        else {\n            this.stack = (new Error(message)).stack;\n        }\n    }\n}\nexports.UnsupportedError = UnsupportedError;\n/**\n * Error produced when calling a method in an invalid state.\n */\nclass InvalidStateError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'InvalidStateError';\n        if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.\n         {\n            // @ts-ignore\n            Error.captureStackTrace(this, InvalidStateError);\n        }\n        else {\n            this.stack = (new Error(message)).stack;\n        }\n    }\n}\nexports.InvalidStateError = InvalidStateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvZXJyb3JzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2Vycm9ycy5qcz85YzBiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBFcnJvciBpbmRpY2F0aW5nIG5vdCBzdXBwb3J0IGZvciBzb21ldGhpbmcuXG4gKi9cbmNsYXNzIFVuc3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Vuc3VwcG9ydGVkRXJyb3InO1xuICAgICAgICBpZiAoRXJyb3IuaGFzT3duUHJvcGVydHkoJ2NhcHR1cmVTdGFja1RyYWNlJykpIC8vIEp1c3QgaW4gVjguXG4gICAgICAgICB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBVbnN1cHBvcnRlZEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKG1lc3NhZ2UpKS5zdGFjaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVW5zdXBwb3J0ZWRFcnJvciA9IFVuc3VwcG9ydGVkRXJyb3I7XG4vKipcbiAqIEVycm9yIHByb2R1Y2VkIHdoZW4gY2FsbGluZyBhIG1ldGhvZCBpbiBhbiBpbnZhbGlkIHN0YXRlLlxuICovXG5jbGFzcyBJbnZhbGlkU3RhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZFN0YXRlRXJyb3InO1xuICAgICAgICBpZiAoRXJyb3IuaGFzT3duUHJvcGVydHkoJ2NhcHR1cmVTdGFja1RyYWNlJykpIC8vIEp1c3QgaW4gVjguXG4gICAgICAgICB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnZhbGlkU3RhdGVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcihtZXNzYWdlKSkuc3RhY2s7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRTdGF0ZUVycm9yID0gSW52YWxpZFN0YXRlRXJyb3I7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/errors.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome55.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome55.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\nconst ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\nconst sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\nconst sdpPlanBUtils = __webpack_require__(/*! ./sdp/planBUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\");\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst logger = new Logger_1.Logger('Chrome55');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Chrome55 extends HandlerInterface_1.HandlerInterface {\n    constructor() {\n        super();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Map of sending MediaStreamTracks indexed by localId.\n        this._mapSendLocalIdTrack = new Map();\n        // Next sending localId.\n        this._nextSendLocalId = 0;\n        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n        // Value is an Object with mid, rtpParameters and rtpReceiver.\n        this._mapRecvLocalIdInfo = new Map();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Chrome55();\n    }\n    get name() {\n        return 'Chrome55';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b'\n        });\n        try {\n            const offer = await pc.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true\n            });\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            planB: true\n        });\n        this._sendingRtpParametersByKind =\n            {\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._sendingRemoteRtpParametersByKind =\n            {\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b',\n            ...additionalSettings\n        }, proprietaryConstraints);\n        // Handle RTCPeerConnection connection status.\n        this._pc.addEventListener('iceconnectionstatechange', () => {\n            switch (this._pc.iceConnectionState) {\n                case 'checking':\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                case 'connected':\n                case 'completed':\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                case 'failed':\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                case 'disconnected':\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                case 'closed':\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n            }\n        });\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady)\n            return;\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec }) {\n        this._assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (codec) {\n            logger.warn('send() | codec selection is not available in %s handler', this.name);\n        }\n        this._sendStream.addTrack(track);\n        this._pc.addStream(this._sendStream);\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        sendingRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRtpParameters.codecs);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        sendingRemoteRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n        if (track.kind === 'video' && encodings && encodings.length > 1) {\n            logger.debug('send() | enabling simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');\n            sdpPlanBUtils.addLegacySimulcast({\n                offerMediaObject,\n                track,\n                numStreams: encodings.length\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media\n            .find((m) => m.type === track.kind);\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname =\n            sdpCommonUtils.getCname({ offerMediaObject });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings =\n            sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx])\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n            }\n        }\n        // If VP8 and there is effective simulcast, add scalabilityMode to each\n        // encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'S1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        const localId = String(this._nextSendLocalId);\n        this._nextSendLocalId++;\n        // Insert into the map.\n        this._mapSendLocalIdTrack.set(localId, track);\n        return {\n            localId: localId,\n            rtpParameters: sendingRtpParameters\n        };\n    }\n    async stopSending(localId) {\n        this._assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        const track = this._mapSendLocalIdTrack.get(localId);\n        if (!track)\n            throw new Error('track not found');\n        this._mapSendLocalIdTrack.delete(localId);\n        this._sendStream.removeTrack(track);\n        this._pc.addStream(this._sendStream);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        try {\n            await this._pc.setLocalDescription(offer);\n        }\n        catch (error) {\n            // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n            // \"Failed to create channels\". If so, ignore it.\n            if (this._sendStream.getTracks().length === 0) {\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n                return;\n            }\n            throw error;\n        }\n        if (this._pc.signalingState === 'stable')\n            return;\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localId, track) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        throw new errors_1.UnsupportedError(' not implemented');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async setRtpEncodingParameters(localId, params) {\n        throw new errors_1.UnsupportedError('not supported');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getSenderStats(localId) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\n        this._assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n            priority\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'application');\n            if (!this._transportReady)\n                await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive({ trackId, kind, rtpParameters }) {\n        this._assertRecvDirection();\n        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n        const localId = trackId;\n        const mid = kind;\n        const streamId = rtpParameters.rtcp.cname;\n        this._remoteSdp.receive({\n            mid,\n            kind,\n            offerRtpParameters: rtpParameters,\n            streamId,\n            trackId\n        });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        const answerMediaObject = localSdpObject.media\n            .find((m) => String(m.mid) === mid);\n        // May need to modify codec parameters in the answer based on codec\n        // parameters in the offer.\n        sdpCommonUtils.applyCodecParameters({\n            offerRtpParameters: rtpParameters,\n            answerMediaObject\n        });\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        const stream = this._pc.getRemoteStreams()\n            .find((s) => s.id === streamId);\n        const track = stream.getTrackById(localId);\n        if (!track)\n            throw new Error('remote track not found');\n        // Insert into the map.\n        this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });\n        return { localId, track };\n    }\n    async stopReceiving(localId) {\n        this._assertRecvDirection();\n        logger.debug('stopReceiving() [localId:%s]', localId);\n        const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\n        // Remove from the map.\n        this._mapRecvLocalIdInfo.delete(localId);\n        this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getReceiverStats(localId) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {\n        this._assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async _setupTransport({ localDtlsRole, localSdpObject }) {\n        if (!localSdpObject)\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await this.safeEmitAsPromise('@connect', { dtlsParameters });\n        this._transportReady = true;\n    }\n    _assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    _assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Chrome55 = Chrome55;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvQ2hyb21lNTUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvQ2hyb21lNTUuanM/ZTBkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBvcnRjID0gcmVxdWlyZShcIi4uL29ydGNcIik7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKTtcbmNvbnN0IHNkcFBsYW5CVXRpbHMgPSByZXF1aXJlKFwiLi9zZHAvcGxhbkJVdGlsc1wiKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdDaHJvbWU1NScpO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDEwMjQsIE1JUzogMTAyNCB9O1xuY2xhc3MgQ2hyb21lNTUgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBNYXAgb2Ygc2VuZGluZyBNZWRpYVN0cmVhbVRyYWNrcyBpbmRleGVkIGJ5IGxvY2FsSWQuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkVHJhY2sgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE5leHQgc2VuZGluZyBsb2NhbElkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQgPSAwO1xuICAgICAgICAvLyBNYXAgb2YgTUlELCBSVFAgcGFyYW1ldGVycyBhbmQgUlRDUnRwUmVjZWl2ZXIgaW5kZXhlZCBieSBsb2NhbCBpZC5cbiAgICAgICAgLy8gVmFsdWUgaXMgYW4gT2JqZWN0IHdpdGggbWlkLCBydHBQYXJhbWV0ZXJzIGFuZCBydHBSZWNlaXZlci5cbiAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBDaHJvbWU1NSgpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdDaHJvbWU1NSc7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICdwbGFuLWInXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcih7XG4gICAgICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVBdWRpbzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvZmZlclRvUmVjZWl2ZVZpZGVvOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoeyBzZHBPYmplY3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogU0NUUF9OVU1fU1RSRUFNU1xuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcGxhbkI6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyB8fCBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5IHx8ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICdwbGFuLWInLFxuICAgICAgICAgICAgLi4uYWRkaXRpb25hbFNldHRpbmdzXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICAvLyBIYW5kbGUgUlRDUGVlckNvbm5lY3Rpb24gY29ubmVjdGlvbiBzdGF0dXMuXG4gICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX3BjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgdGhpcy5fcGMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNwb3J0U3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHsgdHJhY2ssIGVuY29kaW5ncywgY29kZWNPcHRpb25zLCBjb2RlYyB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgW2tpbmQ6JXMsIHRyYWNrLmlkOiVzXScsIHRyYWNrLmtpbmQsIHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgICAgICBsb2dnZXIud2Fybignc2VuZCgpIHwgY29kZWMgc2VsZWN0aW9uIGlzIG5vdCBhdmFpbGFibGUgaW4gJXMgaGFuZGxlcicsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gICAgICAgIHRoaXMuX3BjLmFkZFN0cmVhbSh0aGlzLl9zZW5kU3RyZWFtKTtcbiAgICAgICAgbGV0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbGV0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgIGxldCBvZmZlck1lZGlhT2JqZWN0O1xuICAgICAgICBjb25zdCBzZW5kaW5nUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzID1cbiAgICAgICAgICAgIG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPVxuICAgICAgICAgICAgb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ3ZpZGVvJyAmJiBlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgc2ltdWxjYXN0Jyk7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ3ZpZGVvJyk7XG4gICAgICAgICAgICBzZHBQbGFuQlV0aWxzLmFkZExlZ2FjeVNpbXVsY2FzdCh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICBudW1TdHJlYW1zOiBlbmNvZGluZ3MubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gdHJhY2sua2luZCk7XG4gICAgICAgIC8vIFNldCBSVENQIENOQU1FLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lID1cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmdldENuYW1lKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9XG4gICAgICAgICAgICBzZHBQbGFuQlV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QsIHRyYWNrIH0pO1xuICAgICAgICAvLyBDb21wbGV0ZSBlbmNvZGluZ3Mgd2l0aCBnaXZlbiB2YWx1ZXMuXG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nc1tpZHhdKVxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdLCBlbmNvZGluZ3NbaWR4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgVlA4IGFuZCB0aGVyZSBpcyBlZmZlY3RpdmUgc2ltdWxjYXN0LCBhZGQgc2NhbGFiaWxpdHlNb2RlIHRvIGVhY2hcbiAgICAgICAgLy8gZW5jb2RpbmcuXG4gICAgICAgIGlmIChzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDgnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuY29kaW5nIG9mIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncykge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9ICdTMVQzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29kZWNPcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSBTdHJpbmcodGhpcy5fbmV4dFNlbmRMb2NhbElkKTtcbiAgICAgICAgdGhpcy5fbmV4dFNlbmRMb2NhbElkKys7XG4gICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkVHJhY2suc2V0KGxvY2FsSWQsIHRyYWNrKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQ6IGxvY2FsSWQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVyc1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMuX21hcFNlbmRMb2NhbElkVHJhY2suZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYWNrKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFjayBub3QgZm91bmQnKTtcbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRUcmFjay5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgICAgICB0aGlzLl9wYy5hZGRTdHJlYW0odGhpcy5fc2VuZFN0cmVhbSk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTk9URTogSWYgdGhlcmUgYXJlIG5vIHNlbmRpbmcgdHJhY2tzLCBzZXRMb2NhbERlc2NyaXB0aW9uKCkgd2lsbCBmYWlsIHdpdGhcbiAgICAgICAgICAgIC8vIFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFubmVsc1wiLiBJZiBzbywgaWdub3JlIGl0LlxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbmRTdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3N0b3BTZW5kaW5nKCkgfCBpZ25vcmluZyBleHBlY3RlZCBlcnJvciBkdWUgbm8gc2VuZGluZyB0cmFja3M6ICVzJywgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBsb2NhbElkLCB0cmFjaykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIobG9jYWxJZCwgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCcgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZERhdGFDaGFubmVsKHsgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCwgcHJvdG9jb2wsIHByaW9yaXR5IH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRUaW1lOiBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICBwcmlvcml0eVxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgICAgIC5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgc3RyZWFtSWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICBvcmRlcmVkOiBvcHRpb25zLm9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiBvcHRpb25zLm1heFJldHJhbnNtaXRzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKHsgdHJhY2tJZCwga2luZCwgcnRwUGFyYW1ldGVycyB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFja0lkO1xuICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICBjb25zdCBzdHJlYW1JZCA9IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmUoe1xuICAgICAgICAgICAgbWlkLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgdHJhY2tJZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IG1pZCk7XG4gICAgICAgIC8vIE1heSBuZWVkIHRvIG1vZGlmeSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBhbnN3ZXIgYmFzZWQgb24gY29kZWNcbiAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9wYy5nZXRSZW1vdGVTdHJlYW1zKClcbiAgICAgICAgICAgIC5maW5kKChzKSA9PiBzLmlkID09PSBzdHJlYW1JZCk7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gc3RyZWFtLmdldFRyYWNrQnlJZChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFjaylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3RlIHRyYWNrIG5vdCBmb3VuZCcpO1xuICAgICAgICAvLyBJbnNlcnQgaW50byB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uc2V0KGxvY2FsSWQsIHsgbWlkLCBydHBQYXJhbWV0ZXJzIH0pO1xuICAgICAgICByZXR1cm4geyBsb2NhbElkLCB0cmFjayB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgeyBtaWQsIHJ0cFBhcmFtZXRlcnMgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgfHwge307XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wbGFuQlN0b3BSZWNlaXZpbmcoeyBtaWQ6IG1pZCwgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzIH0pO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cyB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdFRpbWU6IG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oeyBvbGREYXRhQ2hhbm5lbFNwZWM6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KVxuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoeyBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgX2Fzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hyb21lNTUgPSBDaHJvbWU1NTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/Chrome55.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome67.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome67.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\nconst ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\nconst sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\nconst sdpPlanBUtils = __webpack_require__(/*! ./sdp/planBUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\");\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst logger = new Logger_1.Logger('Chrome67');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Chrome67 extends HandlerInterface_1.HandlerInterface {\n    constructor() {\n        super();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Map of RTCRtpSender indexed by localId.\n        this._mapSendLocalIdRtpSender = new Map();\n        // Next sending localId.\n        this._nextSendLocalId = 0;\n        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n        // Value is an Object with mid, rtpParameters and rtpReceiver.\n        this._mapRecvLocalIdInfo = new Map();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Chrome67();\n    }\n    get name() {\n        return 'Chrome67';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b'\n        });\n        try {\n            const offer = await pc.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true\n            });\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            planB: true\n        });\n        this._sendingRtpParametersByKind =\n            {\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._sendingRemoteRtpParametersByKind =\n            {\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b',\n            ...additionalSettings\n        }, proprietaryConstraints);\n        // Handle RTCPeerConnection connection status.\n        this._pc.addEventListener('iceconnectionstatechange', () => {\n            switch (this._pc.iceConnectionState) {\n                case 'checking':\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                case 'connected':\n                case 'completed':\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                case 'failed':\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                case 'disconnected':\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                case 'closed':\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n            }\n        });\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady)\n            return;\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec }) {\n        this._assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (codec) {\n            logger.warn('send() | codec selection is not available in %s handler', this.name);\n        }\n        this._sendStream.addTrack(track);\n        this._pc.addTrack(track, this._sendStream);\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        sendingRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRtpParameters.codecs);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        sendingRemoteRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n        if (track.kind === 'video' && encodings && encodings.length > 1) {\n            logger.debug('send() | enabling simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'video');\n            sdpPlanBUtils.addLegacySimulcast({\n                offerMediaObject,\n                track,\n                numStreams: encodings.length\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media\n            .find((m) => m.type === track.kind);\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname =\n            sdpCommonUtils.getCname({ offerMediaObject });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings =\n            sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx])\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n            }\n        }\n        // If VP8 and there is effective simulcast, add scalabilityMode to each\n        // encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'S1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        const localId = String(this._nextSendLocalId);\n        this._nextSendLocalId++;\n        const rtpSender = this._pc.getSenders()\n            .find((s) => s.track === track);\n        // Insert into the map.\n        this._mapSendLocalIdRtpSender.set(localId, rtpSender);\n        return {\n            localId: localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender\n        };\n    }\n    async stopSending(localId) {\n        this._assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        this._pc.removeTrack(rtpSender);\n        if (rtpSender.track)\n            this._sendStream.removeTrack(rtpSender.track);\n        this._mapSendLocalIdRtpSender.delete(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        try {\n            await this._pc.setLocalDescription(offer);\n        }\n        catch (error) {\n            // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n            // \"Failed to create channels\". If so, ignore it.\n            if (this._sendStream.getTracks().length === 0) {\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n                return;\n            }\n            throw error;\n        }\n        if (this._pc.signalingState === 'stable')\n            return;\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this._assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        const oldTrack = rtpSender.track;\n        await rtpSender.replaceTrack(track);\n        // Remove the old track from the local stream.\n        if (oldTrack)\n            this._sendStream.removeTrack(oldTrack);\n        // Add the new track to the local stream.\n        if (track)\n            this._sendStream.addTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this._assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer)\n                encoding.active = true;\n            else\n                encoding.active = false;\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this._assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async getSenderStats(localId) {\n        this._assertSendDirection();\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        return rtpSender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\n        this._assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n            priority\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'application');\n            if (!this._transportReady)\n                await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive({ trackId, kind, rtpParameters }) {\n        this._assertRecvDirection();\n        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n        const localId = trackId;\n        const mid = kind;\n        this._remoteSdp.receive({\n            mid,\n            kind,\n            offerRtpParameters: rtpParameters,\n            streamId: rtpParameters.rtcp.cname,\n            trackId\n        });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        const answerMediaObject = localSdpObject.media\n            .find((m) => String(m.mid) === mid);\n        // May need to modify codec parameters in the answer based on codec\n        // parameters in the offer.\n        sdpCommonUtils.applyCodecParameters({\n            offerRtpParameters: rtpParameters,\n            answerMediaObject\n        });\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        const rtpReceiver = this._pc.getReceivers()\n            .find((r) => r.track && r.track.id === localId);\n        if (!rtpReceiver)\n            throw new Error('new RTCRtpReceiver not');\n        // Insert into the map.\n        this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters, rtpReceiver });\n        return {\n            localId,\n            track: rtpReceiver.track,\n            rtpReceiver\n        };\n    }\n    async stopReceiving(localId) {\n        this._assertRecvDirection();\n        logger.debug('stopReceiving() [localId:%s]', localId);\n        const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\n        // Remove from the map.\n        this._mapRecvLocalIdInfo.delete(localId);\n        this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this._assertRecvDirection();\n        const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};\n        if (!rtpReceiver)\n            throw new Error('associated RTCRtpReceiver not found');\n        return rtpReceiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {\n        this._assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async _setupTransport({ localDtlsRole, localSdpObject }) {\n        if (!localSdpObject)\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await this.safeEmitAsPromise('@connect', { dtlsParameters });\n        this._transportReady = true;\n    }\n    _assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    _assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Chrome67 = Chrome67;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvQ2hyb21lNjcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvQ2hyb21lNjcuanM/MTBiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBvcnRjID0gcmVxdWlyZShcIi4uL29ydGNcIik7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKTtcbmNvbnN0IHNkcFBsYW5CVXRpbHMgPSByZXF1aXJlKFwiLi9zZHAvcGxhbkJVdGlsc1wiKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdDaHJvbWU2NycpO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDEwMjQsIE1JUzogMTAyNCB9O1xuY2xhc3MgQ2hyb21lNjcgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBNYXAgb2YgUlRDUnRwU2VuZGVyIGluZGV4ZWQgYnkgbG9jYWxJZC5cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE5leHQgc2VuZGluZyBsb2NhbElkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQgPSAwO1xuICAgICAgICAvLyBNYXAgb2YgTUlELCBSVFAgcGFyYW1ldGVycyBhbmQgUlRDUnRwUmVjZWl2ZXIgaW5kZXhlZCBieSBsb2NhbCBpZC5cbiAgICAgICAgLy8gVmFsdWUgaXMgYW4gT2JqZWN0IHdpdGggbWlkLCBydHBQYXJhbWV0ZXJzIGFuZCBydHBSZWNlaXZlci5cbiAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBDaHJvbWU2NygpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdDaHJvbWU2Nyc7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICdwbGFuLWInXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcih7XG4gICAgICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVBdWRpbzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvZmZlclRvUmVjZWl2ZVZpZGVvOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoeyBzZHBPYmplY3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogU0NUUF9OVU1fU1RSRUFNU1xuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcGxhbkI6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyB8fCBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5IHx8ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICdwbGFuLWInLFxuICAgICAgICAgICAgLi4uYWRkaXRpb25hbFNldHRpbmdzXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICAvLyBIYW5kbGUgUlRDUGVlckNvbm5lY3Rpb24gY29ubmVjdGlvbiBzdGF0dXMuXG4gICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX3BjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgdGhpcy5fcGMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNwb3J0U3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHsgdHJhY2ssIGVuY29kaW5ncywgY29kZWNPcHRpb25zLCBjb2RlYyB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgW2tpbmQ6JXMsIHRyYWNrLmlkOiVzXScsIHRyYWNrLmtpbmQsIHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgICAgICBsb2dnZXIud2Fybignc2VuZCgpIHwgY29kZWMgc2VsZWN0aW9uIGlzIG5vdCBhdmFpbGFibGUgaW4gJXMgaGFuZGxlcicsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gICAgICAgIHRoaXMuX3BjLmFkZFRyYWNrKHRyYWNrLCB0aGlzLl9zZW5kU3RyZWFtKTtcbiAgICAgICAgbGV0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbGV0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgIGxldCBvZmZlck1lZGlhT2JqZWN0O1xuICAgICAgICBjb25zdCBzZW5kaW5nUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzID1cbiAgICAgICAgICAgIG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPVxuICAgICAgICAgICAgb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ3ZpZGVvJyAmJiBlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgc2ltdWxjYXN0Jyk7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAgICAgLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ3ZpZGVvJyk7XG4gICAgICAgICAgICBzZHBQbGFuQlV0aWxzLmFkZExlZ2FjeVNpbXVsY2FzdCh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICBudW1TdHJlYW1zOiBlbmNvZGluZ3MubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gdHJhY2sua2luZCk7XG4gICAgICAgIC8vIFNldCBSVENQIENOQU1FLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lID1cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmdldENuYW1lKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9XG4gICAgICAgICAgICBzZHBQbGFuQlV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QsIHRyYWNrIH0pO1xuICAgICAgICAvLyBDb21wbGV0ZSBlbmNvZGluZ3Mgd2l0aCBnaXZlbiB2YWx1ZXMuXG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nc1tpZHhdKVxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdLCBlbmNvZGluZ3NbaWR4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgVlA4IGFuZCB0aGVyZSBpcyBlZmZlY3RpdmUgc2ltdWxjYXN0LCBhZGQgc2NhbGFiaWxpdHlNb2RlIHRvIGVhY2hcbiAgICAgICAgLy8gZW5jb2RpbmcuXG4gICAgICAgIGlmIChzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDgnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuY29kaW5nIG9mIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncykge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9ICdTMVQzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29kZWNPcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSBTdHJpbmcodGhpcy5fbmV4dFNlbmRMb2NhbElkKTtcbiAgICAgICAgdGhpcy5fbmV4dFNlbmRMb2NhbElkKys7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX3BjLmdldFNlbmRlcnMoKVxuICAgICAgICAgICAgLmZpbmQoKHMpID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgICAgLy8gSW5zZXJ0IGludG8gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuc2V0KGxvY2FsSWQsIHJ0cFNlbmRlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkOiBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydHBTZW5kZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHRoaXMuX3BjLnJlbW92ZVRyYWNrKHJ0cFNlbmRlcik7XG4gICAgICAgIGlmIChydHBTZW5kZXIudHJhY2spXG4gICAgICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLnJlbW92ZVRyYWNrKHJ0cFNlbmRlci50cmFjayk7XG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBJZiB0aGVyZSBhcmUgbm8gc2VuZGluZyB0cmFja3MsIHNldExvY2FsRGVzY3JpcHRpb24oKSB3aWxsIGZhaWwgd2l0aFxuICAgICAgICAgICAgLy8gXCJGYWlsZWQgdG8gY3JlYXRlIGNoYW5uZWxzXCIuIElmIHNvLCBpZ25vcmUgaXQuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2VuZFN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2Fybignc3RvcFNlbmRpbmcoKSB8IGlnbm9yaW5nIGV4cGVjdGVkIGVycm9yIGR1ZSBubyBzZW5kaW5nIHRyYWNrczogJXMnLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2sobG9jYWxJZCwgdHJhY2spIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBjb25zdCBvbGRUcmFjayA9IHJ0cFNlbmRlci50cmFjaztcbiAgICAgICAgYXdhaXQgcnRwU2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgb2xkIHRyYWNrIGZyb20gdGhlIGxvY2FsIHN0cmVhbS5cbiAgICAgICAgaWYgKG9sZFRyYWNrKVxuICAgICAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5yZW1vdmVUcmFjayhvbGRUcmFjayk7XG4gICAgICAgIC8vIEFkZCB0aGUgbmV3IHRyYWNrIHRvIHRoZSBsb2NhbCBzdHJlYW0uXG4gICAgICAgIGlmICh0cmFjaylcbiAgICAgICAgICAgIHRoaXMuX3NlbmRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuICAgIH1cbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIobG9jYWxJZCwgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSBbbG9jYWxJZDolcywgc3BhdGlhbExheWVyOiVzXScsIGxvY2FsSWQsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gcnRwU2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA8PSBzcGF0aWFsTGF5ZXIpXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSBbbG9jYWxJZDolcywgcGFyYW1zOiVvXScsIGxvY2FsSWQsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gcnRwU2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSA9IHsgLi4uZW5jb2RpbmcsIC4uLnBhcmFtcyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcnRwU2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHJ0cFNlbmRlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCwgcHJpb3JpdHkgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdFRpbWU6IG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgIHByaW9yaXR5XG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAgICAgLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUoeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSBbdHJhY2tJZDolcywga2luZDolc10nLCB0cmFja0lkLCBraW5kKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IHRyYWNrSWQ7XG4gICAgICAgIGNvbnN0IG1pZCA9IGtpbmQ7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlKHtcbiAgICAgICAgICAgIG1pZCxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzdHJlYW1JZDogcnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgdHJhY2tJZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IG1pZCk7XG4gICAgICAgIC8vIE1heSBuZWVkIHRvIG1vZGlmeSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBhbnN3ZXIgYmFzZWQgb24gY29kZWNcbiAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBjb25zdCBydHBSZWNlaXZlciA9IHRoaXMuX3BjLmdldFJlY2VpdmVycygpXG4gICAgICAgICAgICAuZmluZCgocikgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSBsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBSZWNlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3IFJUQ1J0cFJlY2VpdmVyIG5vdCcpO1xuICAgICAgICAvLyBJbnNlcnQgaW50byB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uc2V0KGxvY2FsSWQsIHsgbWlkLCBydHBQYXJhbWV0ZXJzLCBydHBSZWNlaXZlciB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICB0cmFjazogcnRwUmVjZWl2ZXIudHJhY2ssXG4gICAgICAgICAgICBydHBSZWNlaXZlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgeyBtaWQsIHJ0cFBhcmFtZXRlcnMgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgfHwge307XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wbGFuQlN0b3BSZWNlaXZpbmcoeyBtaWQ6IG1pZCwgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzIH0pO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBydHBSZWNlaXZlciB9ID0gdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLmdldChsb2NhbElkKSB8fCB7fTtcbiAgICAgICAgaWYgKCFydHBSZWNlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBSZWNlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHJ0cFJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cyB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdFRpbWU6IG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oeyBvbGREYXRhQ2hhbm5lbFNwZWM6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KVxuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoeyBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgX2Fzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hyb21lNjcgPSBDaHJvbWU2NztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/Chrome67.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome70.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome70.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\nconst ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\nconst sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\nconst sdpUnifiedPlanUtils = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\");\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"./node_modules/mediasoup-client/lib/scalabilityModes.js\");\nconst logger = new Logger_1.Logger('Chrome70');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Chrome70 extends HandlerInterface_1.HandlerInterface {\n    constructor() {\n        super();\n        // Map of RTCTransceivers indexed by MID.\n        this._mapMidTransceiver = new Map();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Chrome70();\n    }\n    get name() {\n        return 'Chrome70';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'unified-plan'\n        });\n        try {\n            pc.addTransceiver('audio');\n            pc.addTransceiver('video');\n            const offer = await pc.createOffer();\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters\n        });\n        this._sendingRtpParametersByKind =\n            {\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._sendingRemoteRtpParametersByKind =\n            {\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'unified-plan',\n            ...additionalSettings\n        }, proprietaryConstraints);\n        // Handle RTCPeerConnection connection status.\n        this._pc.addEventListener('iceconnectionstatechange', () => {\n            switch (this._pc.iceConnectionState) {\n                case 'checking':\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                case 'connected':\n                case 'completed':\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                case 'failed':\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                case 'disconnected':\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                case 'closed':\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n            }\n        });\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady)\n            return;\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec }) {\n        this._assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRemoteRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\n        const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n        if (encodings && encodings.length > 1) {\n            logger.debug('send() | enabling legacy simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n            sdpUnifiedPlanUtils.addLegacySimulcast({\n                offerMediaObject,\n                numStreams: encodings.length\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        // Special case for VP9 with SVC.\n        let hackVp9Svc = false;\n        const layers = scalabilityModes_1.parse((encodings || [{}])[0].scalabilityMode);\n        if (encodings &&\n            encodings.length === 1 &&\n            layers.spatialLayers > 1 &&\n            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {\n            logger.debug('send() | enabling legacy simulcast for VP9 SVC');\n            hackVp9Svc = true;\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n            sdpUnifiedPlanUtils.addLegacySimulcast({\n                offerMediaObject,\n                numStreams: layers.spatialLayers\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        // If encodings are given, apply them now.\n        if (encodings) {\n            logger.debug('send() | applying given encodings');\n            const parameters = transceiver.sender.getParameters();\n            for (let idx = 0; idx < (parameters.encodings || []).length; ++idx) {\n                const encoding = parameters.encodings[idx];\n                const desiredEncoding = encodings[idx];\n                // Should not happen but just in case.\n                if (!desiredEncoding)\n                    break;\n                parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);\n            }\n            await transceiver.sender.setParameters(parameters);\n        }\n        // We can now get the transceiver.mid.\n        const localId = transceiver.mid;\n        // Set MID.\n        sendingRtpParameters.mid = localId;\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname =\n            sdpCommonUtils.getCname({ offerMediaObject });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings =\n            sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx])\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n            }\n        }\n        // Hack for VP9 SVC.\n        if (hackVp9Svc) {\n            sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'S1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            reuseMid: mediaSectionIdx.reuseMid,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender: transceiver.sender\n        };\n    }\n    async stopSending(localId) {\n        this._assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        transceiver.sender.replaceTrack(null);\n        this._pc.removeTrack(transceiver.sender);\n        this._remoteSdp.closeMediaSection(transceiver.mid);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this._assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        await transceiver.sender.replaceTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this._assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer)\n                encoding.active = true;\n            else\n                encoding.active = false;\n        });\n        await transceiver.sender.setParameters(parameters);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this._assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await transceiver.sender.setParameters(parameters);\n    }\n    async getSenderStats(localId) {\n        this._assertSendDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        return transceiver.sender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\n        this._assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n            priority\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'application');\n            if (!this._transportReady)\n                await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive({ trackId, kind, rtpParameters }) {\n        this._assertRecvDirection();\n        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n        const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n        this._remoteSdp.receive({\n            mid: localId,\n            kind,\n            offerRtpParameters: rtpParameters,\n            streamId: rtpParameters.rtcp.cname,\n            trackId\n        });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        const answerMediaObject = localSdpObject.media\n            .find((m) => String(m.mid) === localId);\n        // May need to modify codec parameters in the answer based on codec\n        // parameters in the offer.\n        sdpCommonUtils.applyCodecParameters({\n            offerRtpParameters: rtpParameters,\n            answerMediaObject\n        });\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        const transceiver = this._pc.getTransceivers()\n            .find((t) => t.mid === localId);\n        if (!transceiver)\n            throw new Error('new RTCRtpTransceiver not found');\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            track: transceiver.receiver.track,\n            rtpReceiver: transceiver.receiver\n        };\n    }\n    async stopReceiving(localId) {\n        this._assertRecvDirection();\n        logger.debug('stopReceiving() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        this._remoteSdp.closeMediaSection(transceiver.mid);\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this._assertRecvDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        return transceiver.receiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {\n        this._assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation();\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async _setupTransport({ localDtlsRole, localSdpObject }) {\n        if (!localSdpObject)\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await this.safeEmitAsPromise('@connect', { dtlsParameters });\n        this._transportReady = true;\n    }\n    _assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    _assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Chrome70 = Chrome70;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvQ2hyb21lNzAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvQ2hyb21lNzAuanM/NTEzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBvcnRjID0gcmVxdWlyZShcIi4uL29ydGNcIik7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKTtcbmNvbnN0IHNkcFVuaWZpZWRQbGFuVXRpbHMgPSByZXF1aXJlKFwiLi9zZHAvdW5pZmllZFBsYW5VdGlsc1wiKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBzY2FsYWJpbGl0eU1vZGVzXzEgPSByZXF1aXJlKFwiLi4vc2NhbGFiaWxpdHlNb2Rlc1wiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0Nocm9tZTcwJyk7XG5jb25zdCBTQ1RQX05VTV9TVFJFQU1TID0geyBPUzogMTAyNCwgTUlTOiAxMDI0IH07XG5jbGFzcyBDaHJvbWU3MCBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1RyYW5zY2VpdmVycyBpbmRleGVkIGJ5IE1JRC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBDaHJvbWU3MCgpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdDaHJvbWU3MCc7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICd1bmlmaWVkLXBsYW4nXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICAgICAgICBwYy5hZGRUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoeyBzZHBPYmplY3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogU0NUUF9OVU1fU1RSRUFNU1xuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmQgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMgfHwgW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSB8fCAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICAgICAgc2RwU2VtYW50aWNzOiAndW5pZmllZC1wbGFuJyxcbiAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxTZXR0aW5nc1xuICAgICAgICB9LCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgLy8gSGFuZGxlIFJUQ1BlZXJDb25uZWN0aW9uIGNvbm5lY3Rpb24gc3RhdHVzLlxuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLl9wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIHRoaXMuX3BjLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICAvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzID1cbiAgICAgICAgICAgIG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9XG4gICAgICAgICAgICBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uSWR4ID0gdGhpcy5fcmVtb3RlU2RwLmdldE5leHRNZWRpYVNlY3Rpb25JZHgoKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wYy5hZGRUcmFuc2NlaXZlcih0cmFjaywgeyBkaXJlY3Rpb246ICdzZW5kb25seScsIHN0cmVhbXM6IFt0aGlzLl9zZW5kU3RyZWFtXSB9KTtcbiAgICAgICAgbGV0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbGV0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgIGxldCBvZmZlck1lZGlhT2JqZWN0O1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnc2VydmVyJywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgIGlmIChlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgbGVnYWN5IHNpbXVsY2FzdCcpO1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVttZWRpYVNlY3Rpb25JZHguaWR4XTtcbiAgICAgICAgICAgIHNkcFVuaWZpZWRQbGFuVXRpbHMuYWRkTGVnYWN5U2ltdWxjYXN0KHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgICAgIG51bVN0cmVhbXM6IGVuY29kaW5ncy5sZW5ndGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgVlA5IHdpdGggU1ZDLlxuICAgICAgICBsZXQgaGFja1ZwOVN2YyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBsYXllcnMgPSBzY2FsYWJpbGl0eU1vZGVzXzEucGFyc2UoKGVuY29kaW5ncyB8fCBbe31dKVswXS5zY2FsYWJpbGl0eU1vZGUpO1xuICAgICAgICBpZiAoZW5jb2RpbmdzICYmXG4gICAgICAgICAgICBlbmNvZGluZ3MubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICBsYXllcnMuc3BhdGlhbExheWVycyA+IDEgJiZcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vdnA5Jykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBlbmFibGluZyBsZWdhY3kgc2ltdWxjYXN0IGZvciBWUDkgU1ZDJyk7XG4gICAgICAgICAgICBoYWNrVnA5U3ZjID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFbbWVkaWFTZWN0aW9uSWR4LmlkeF07XG4gICAgICAgICAgICBzZHBVbmlmaWVkUGxhblV0aWxzLmFkZExlZ2FjeVNpbXVsY2FzdCh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgICAgICBudW1TdHJlYW1zOiBsYXllcnMuc3BhdGlhbExheWVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgLy8gSWYgZW5jb2RpbmdzIGFyZSBnaXZlbiwgYXBwbHkgdGhlbSBub3cuXG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgYXBwbHlpbmcgZ2l2ZW4gZW5jb2RpbmdzJyk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IChwYXJhbWV0ZXJzLmVuY29kaW5ncyB8fCBbXSkubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kaW5nID0gcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNpcmVkRW5jb2RpbmcgPSBlbmNvZGluZ3NbaWR4XTtcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgbm90IGhhcHBlbiBidXQganVzdCBpbiBjYXNlLlxuICAgICAgICAgICAgICAgIGlmICghZGVzaXJlZEVuY29kaW5nKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdID0gT2JqZWN0LmFzc2lnbihlbmNvZGluZywgZGVzaXJlZEVuY29kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGNhbiBub3cgZ2V0IHRoZSB0cmFuc2NlaXZlci5taWQuXG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFuc2NlaXZlci5taWQ7XG4gICAgICAgIC8vIFNldCBNSUQuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLm1pZCA9IGxvY2FsSWQ7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9XG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5nZXRDbmFtZSh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPVxuICAgICAgICAgICAgc2RwVW5pZmllZFBsYW5VdGlscy5nZXRSdHBFbmNvZGluZ3MoeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAvLyBDb21wbGV0ZSBlbmNvZGluZ3Mgd2l0aCBnaXZlbiB2YWx1ZXMuXG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nc1tpZHhdKVxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdLCBlbmNvZGluZ3NbaWR4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFjayBmb3IgVlA5IFNWQy5cbiAgICAgICAgaWYgKGhhY2tWcDlTdmMpIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IFtzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbMF1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIFZQOCBvciBIMjY0IGFuZCB0aGVyZSBpcyBlZmZlY3RpdmUgc2ltdWxjYXN0LCBhZGQgc2NhbGFiaWxpdHlNb2RlIHRvXG4gICAgICAgIC8vIGVhY2ggZW5jb2RpbmcuXG4gICAgICAgIGlmIChzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vdnA4JyB8fFxuICAgICAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vaDI2NCcpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuY29kaW5nIG9mIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncykge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9ICdTMVQzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgcmV1c2VNaWQ6IG1lZGlhU2VjdGlvbklkeC5yZXVzZU1pZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAvLyBTdG9yZSBpbiB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zZXQobG9jYWxJZCwgdHJhbnNjZWl2ZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRwU2VuZGVyOiB0cmFuc2NlaXZlci5zZW5kZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgICAgIHRoaXMuX3BjLnJlbW92ZVRyYWNrKHRyYW5zY2VpdmVyLnNlbmRlcik7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2sobG9jYWxJZCwgdHJhY2spIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgW2xvY2FsSWQ6JXMsIHNwYXRpYWxMYXllcjolc10nLCBsb2NhbElkLCBzcGF0aWFsTGF5ZXIpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPD0gc3BhdGlhbExheWVyKVxuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGxvY2FsSWQsIHBhcmFtcykge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSB7IC4uLmVuY29kaW5nLCAuLi5wYXJhbXMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZERhdGFDaGFubmVsKHsgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCwgcHJvdG9jb2wsIHByaW9yaXR5IH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRUaW1lOiBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICBwcmlvcml0eVxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgICAgIC5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgc3RyZWFtSWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICBvcmRlcmVkOiBvcHRpb25zLm9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiBvcHRpb25zLm1heFJldHJhbnNtaXRzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKHsgdHJhY2tJZCwga2luZCwgcnRwUGFyYW1ldGVycyB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSBydHBQYXJhbWV0ZXJzLm1pZCB8fCBTdHJpbmcodGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2l6ZSk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlKHtcbiAgICAgICAgICAgIG1pZDogbG9jYWxJZCxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzdHJlYW1JZDogcnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgdHJhY2tJZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IGxvY2FsSWQpO1xuICAgICAgICAvLyBNYXkgbmVlZCB0byBtb2RpZnkgY29kZWMgcGFyYW1ldGVycyBpbiB0aGUgYW5zd2VyIGJhc2VkIG9uIGNvZGVjXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgaW4gdGhlIG9mZmVyLlxuICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJNZWRpYU9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdjbGllbnQnLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wYy5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAgICAgLmZpbmQoKHQpID0+IHQubWlkID09PSBsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3IFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAvLyBTdG9yZSBpbiB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zZXQobG9jYWxJZCwgdHJhbnNjZWl2ZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgIHRyYWNrOiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjayxcbiAgICAgICAgICAgIHJ0cFJlY2VpdmVyOiB0cmFuc2NlaXZlci5yZWNlaXZlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlRGF0YUNoYW5uZWwoeyBzY3RwU3RyZWFtUGFyYW1ldGVycywgbGFiZWwsIHByb3RvY29sIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB7IHN0cmVhbUlkLCBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMgfSA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRUaW1lOiBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2xcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgb2ZmZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlU2N0cEFzc29jaWF0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KVxuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoeyBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgX2Fzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hyb21lNzAgPSBDaHJvbWU3MDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/Chrome70.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome74.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome74.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\nconst ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\nconst sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\nconst sdpUnifiedPlanUtils = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\");\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"./node_modules/mediasoup-client/lib/scalabilityModes.js\");\nconst logger = new Logger_1.Logger('Chrome74');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Chrome74 extends HandlerInterface_1.HandlerInterface {\n    constructor() {\n        super();\n        // Map of RTCTransceivers indexed by MID.\n        this._mapMidTransceiver = new Map();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Chrome74();\n    }\n    get name() {\n        return 'Chrome74';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'unified-plan'\n        });\n        try {\n            pc.addTransceiver('audio');\n            pc.addTransceiver('video');\n            const offer = await pc.createOffer();\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters\n        });\n        this._sendingRtpParametersByKind =\n            {\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._sendingRemoteRtpParametersByKind =\n            {\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'unified-plan',\n            ...additionalSettings\n        }, proprietaryConstraints);\n        // Handle RTCPeerConnection connection status.\n        this._pc.addEventListener('iceconnectionstatechange', () => {\n            switch (this._pc.iceConnectionState) {\n                case 'checking':\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                case 'connected':\n                case 'completed':\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                case 'failed':\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                case 'disconnected':\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                case 'closed':\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n            }\n        });\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady)\n            return;\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec }) {\n        this._assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (encodings && encodings.length > 1) {\n            encodings.forEach((encoding, idx) => {\n                encoding.rid = `r${idx}`;\n            });\n        }\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRemoteRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\n        const transceiver = this._pc.addTransceiver(track, {\n            direction: 'sendonly',\n            streams: [this._sendStream],\n            sendEncodings: encodings\n        });\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n        // Special case for VP9 with SVC.\n        let hackVp9Svc = false;\n        const layers = scalabilityModes_1.parse((encodings || [{}])[0].scalabilityMode);\n        if (encodings &&\n            encodings.length === 1 &&\n            layers.spatialLayers > 1 &&\n            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {\n            logger.debug('send() | enabling legacy simulcast for VP9 SVC');\n            hackVp9Svc = true;\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n            sdpUnifiedPlanUtils.addLegacySimulcast({\n                offerMediaObject,\n                numStreams: layers.spatialLayers\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        // We can now get the transceiver.mid.\n        const localId = transceiver.mid;\n        // Set MID.\n        sendingRtpParameters.mid = localId;\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname =\n            sdpCommonUtils.getCname({ offerMediaObject });\n        // Set RTP encodings by parsing the SDP offer if no encodings are given.\n        if (!encodings) {\n            sendingRtpParameters.encodings =\n                sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\n        }\n        // Set RTP encodings by parsing the SDP offer and complete them with given\n        // one if just a single encoding has been given.\n        else if (encodings.length === 1) {\n            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\n            Object.assign(newEncodings[0], encodings[0]);\n            // Hack for VP9 SVC.\n            if (hackVp9Svc)\n                newEncodings = [newEncodings[0]];\n            sendingRtpParameters.encodings = newEncodings;\n        }\n        // Otherwise if more than 1 encoding are given use them verbatim.\n        else {\n            sendingRtpParameters.encodings = encodings;\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'S1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            reuseMid: mediaSectionIdx.reuseMid,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n            extmapAllowMixed: true\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender: transceiver.sender\n        };\n    }\n    async stopSending(localId) {\n        this._assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        transceiver.sender.replaceTrack(null);\n        this._pc.removeTrack(transceiver.sender);\n        this._remoteSdp.closeMediaSection(transceiver.mid);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this._assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        await transceiver.sender.replaceTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this._assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer)\n                encoding.active = true;\n            else\n                encoding.active = false;\n        });\n        await transceiver.sender.setParameters(parameters);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this._assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await transceiver.sender.setParameters(parameters);\n    }\n    async getSenderStats(localId) {\n        this._assertSendDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        return transceiver.sender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\n        this._assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n            priority\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'application');\n            if (!this._transportReady)\n                await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive({ trackId, kind, rtpParameters }) {\n        this._assertRecvDirection();\n        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n        const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n        this._remoteSdp.receive({\n            mid: localId,\n            kind,\n            offerRtpParameters: rtpParameters,\n            streamId: rtpParameters.rtcp.cname,\n            trackId\n        });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        const answerMediaObject = localSdpObject.media\n            .find((m) => String(m.mid) === localId);\n        // May need to modify codec parameters in the answer based on codec\n        // parameters in the offer.\n        sdpCommonUtils.applyCodecParameters({\n            offerRtpParameters: rtpParameters,\n            answerMediaObject\n        });\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        const transceiver = this._pc.getTransceivers()\n            .find((t) => t.mid === localId);\n        if (!transceiver)\n            throw new Error('new RTCRtpTransceiver not found');\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            track: transceiver.receiver.track,\n            rtpReceiver: transceiver.receiver\n        };\n    }\n    async stopReceiving(localId) {\n        this._assertRecvDirection();\n        logger.debug('stopReceiving() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        this._remoteSdp.closeMediaSection(transceiver.mid);\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this._assertRecvDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        return transceiver.receiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {\n        this._assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation();\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async _setupTransport({ localDtlsRole, localSdpObject }) {\n        if (!localSdpObject)\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await this.safeEmitAsPromise('@connect', { dtlsParameters });\n        this._transportReady = true;\n    }\n    _assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    _assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Chrome74 = Chrome74;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvQ2hyb21lNzQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvQ2hyb21lNzQuanM/ZDBkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBvcnRjID0gcmVxdWlyZShcIi4uL29ydGNcIik7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKTtcbmNvbnN0IHNkcFVuaWZpZWRQbGFuVXRpbHMgPSByZXF1aXJlKFwiLi9zZHAvdW5pZmllZFBsYW5VdGlsc1wiKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBzY2FsYWJpbGl0eU1vZGVzXzEgPSByZXF1aXJlKFwiLi4vc2NhbGFiaWxpdHlNb2Rlc1wiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0Nocm9tZTc0Jyk7XG5jb25zdCBTQ1RQX05VTV9TVFJFQU1TID0geyBPUzogMTAyNCwgTUlTOiAxMDI0IH07XG5jbGFzcyBDaHJvbWU3NCBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1RyYW5zY2VpdmVycyBpbmRleGVkIGJ5IE1JRC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBDaHJvbWU3NCgpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdDaHJvbWU3NCc7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICd1bmlmaWVkLXBsYW4nXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICAgICAgICBwYy5hZGRUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoeyBzZHBPYmplY3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogU0NUUF9OVU1fU1RSRUFNU1xuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmQgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMgfHwgW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSB8fCAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICAgICAgc2RwU2VtYW50aWNzOiAndW5pZmllZC1wbGFuJyxcbiAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxTZXR0aW5nc1xuICAgICAgICB9LCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgLy8gSGFuZGxlIFJUQ1BlZXJDb25uZWN0aW9uIGNvbm5lY3Rpb24gc3RhdHVzLlxuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLl9wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIHRoaXMuX3BjLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICAvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGlmIChlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcucmlkID0gYHIke2lkeH1gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZGluZ1J0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPVxuICAgICAgICAgICAgb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzLCBjb2RlYyk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzID1cbiAgICAgICAgICAgIG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25JZHggPSB0aGlzLl9yZW1vdGVTZHAuZ2V0TmV4dE1lZGlhU2VjdGlvbklkeCgpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seScsXG4gICAgICAgICAgICBzdHJlYW1zOiBbdGhpcy5fc2VuZFN0cmVhbV0sXG4gICAgICAgICAgICBzZW5kRW5jb2RpbmdzOiBlbmNvZGluZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxldCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICBsZXQgb2ZmZXJNZWRpYU9iamVjdDtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIFZQOSB3aXRoIFNWQy5cbiAgICAgICAgbGV0IGhhY2tWcDlTdmMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0gc2NhbGFiaWxpdHlNb2Rlc18xLnBhcnNlKChlbmNvZGluZ3MgfHwgW3t9XSlbMF0uc2NhbGFiaWxpdHlNb2RlKTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAmJlxuICAgICAgICAgICAgZW5jb2RpbmdzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgbGF5ZXJzLnNwYXRpYWxMYXllcnMgPiAxICYmXG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOScpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgbGVnYWN5IHNpbXVsY2FzdCBmb3IgVlA5IFNWQycpO1xuICAgICAgICAgICAgaGFja1ZwOVN2YyA9IHRydWU7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAgICAgc2RwVW5pZmllZFBsYW5VdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogbGF5ZXJzLnNwYXRpYWxMYXllcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIC8vIFdlIGNhbiBub3cgZ2V0IHRoZSB0cmFuc2NlaXZlci5taWQuXG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFuc2NlaXZlci5taWQ7XG4gICAgICAgIC8vIFNldCBNSUQuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLm1pZCA9IGxvY2FsSWQ7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9XG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5nZXRDbmFtZSh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzIGJ5IHBhcnNpbmcgdGhlIFNEUCBvZmZlciBpZiBubyBlbmNvZGluZ3MgYXJlIGdpdmVuLlxuICAgICAgICBpZiAoIWVuY29kaW5ncykge1xuICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID1cbiAgICAgICAgICAgICAgICBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MgYnkgcGFyc2luZyB0aGUgU0RQIG9mZmVyIGFuZCBjb21wbGV0ZSB0aGVtIHdpdGggZ2l2ZW5cbiAgICAgICAgLy8gb25lIGlmIGp1c3QgYSBzaW5nbGUgZW5jb2RpbmcgaGFzIGJlZW4gZ2l2ZW4uXG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5ncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBuZXdFbmNvZGluZ3MgPSBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld0VuY29kaW5nc1swXSwgZW5jb2RpbmdzWzBdKTtcbiAgICAgICAgICAgIC8vIEhhY2sgZm9yIFZQOSBTVkMuXG4gICAgICAgICAgICBpZiAoaGFja1ZwOVN2YylcbiAgICAgICAgICAgICAgICBuZXdFbmNvZGluZ3MgPSBbbmV3RW5jb2RpbmdzWzBdXTtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IG5ld0VuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgaWYgbW9yZSB0aGFuIDEgZW5jb2RpbmcgYXJlIGdpdmVuIHVzZSB0aGVtIHZlcmJhdGltLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggb3IgSDI2NCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0b1xuICAgICAgICAvLyBlYWNoIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIChzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcgfHxcbiAgICAgICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2gyNjQnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnUzFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIHJldXNlTWlkOiBtZWRpYVNlY3Rpb25JZHgucmV1c2VNaWQsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYW5zd2VyUnRwUGFyYW1ldGVyczogc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBjb2RlY09wdGlvbnMsXG4gICAgICAgICAgICBleHRtYXBBbGxvd01peGVkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydHBTZW5kZXI6IHRyYW5zY2VpdmVyLnNlbmRlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgICAgdGhpcy5fcGMucmVtb3ZlVHJhY2sodHJhbnNjZWl2ZXIuc2VuZGVyKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhsb2NhbElkLCB0cmFjaykge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgdHJhY2suaWQ6JXNdJywgbG9jYWxJZCwgdHJhY2suaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgbm8gdHJhY2tdJywgbG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuICAgIH1cbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIobG9jYWxJZCwgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSBbbG9jYWxJZDolcywgc3BhdGlhbExheWVyOiVzXScsIGxvY2FsSWQsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA8PSBzcGF0aWFsTGF5ZXIpXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSBbbG9jYWxJZDolcywgcGFyYW1zOiVvXScsIGxvY2FsSWQsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSA9IHsgLi4uZW5jb2RpbmcsIC4uLnBhcmFtcyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCwgcHJpb3JpdHkgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgIHByaW9yaXR5XG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAgICAgLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUoeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSBbdHJhY2tJZDolcywga2luZDolc10nLCB0cmFja0lkLCBraW5kKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IHJ0cFBhcmFtZXRlcnMubWlkIHx8IFN0cmluZyh0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zaXplKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmUoe1xuICAgICAgICAgICAgbWlkOiBsb2NhbElkLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHN0cmVhbUlkOiBydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUsXG4gICAgICAgICAgICB0cmFja0lkXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsZXQgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICBjb25zdCBhbnN3ZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAuZmluZCgobSkgPT4gU3RyaW5nKG0ubWlkKSA9PT0gbG9jYWxJZCk7XG4gICAgICAgIC8vIE1heSBuZWVkIHRvIG1vZGlmeSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBhbnN3ZXIgYmFzZWQgb24gY29kZWNcbiAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAgICAgICAuZmluZCgodCkgPT4gdC5taWQgPT09IGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXcgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgdHJhY2s6IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLFxuICAgICAgICAgICAgcnRwUmVjZWl2ZXI6IHRyYW5zY2VpdmVyLnJlY2VpdmVyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BSZWNlaXZpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cyB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnY2xpZW50JywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCB9O1xuICAgIH1cbiAgICBhc3luYyBfc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlLCBsb2NhbFNkcE9iamVjdCB9KSB7XG4gICAgICAgIGlmICghbG9jYWxTZHBPYmplY3QpXG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyh7IHNkcE9iamVjdDogbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgIC8vIFNldCBvdXIgRFRMUyByb2xlLlxuICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID0gbG9jYWxEdGxzUm9sZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1vdGUgRFRMUyByb2xlIGluIHRoZSBTRFAuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVEdGxzUm9sZShsb2NhbER0bHNSb2xlID09PSAnY2xpZW50JyA/ICdzZXJ2ZXInIDogJ2NsaWVudCcpO1xuICAgICAgICAvLyBOZWVkIHRvIHRlbGwgdGhlIHJlbW90ZSB0cmFuc3BvcnQgYWJvdXQgb3VyIHBhcmFtZXRlcnMuXG4gICAgICAgIGF3YWl0IHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoJ0Bjb25uZWN0JywgeyBkdGxzUGFyYW1ldGVycyB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgICBfYXNzZXJ0U2VuZERpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJzZW5kXCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwicmVjdlwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DaHJvbWU3NCA9IENocm9tZTc0O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/Chrome74.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Edge11.js":
/*!**************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Edge11.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\nconst ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\nconst edgeUtils = __webpack_require__(/*! ./ortc/edgeUtils */ \"./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js\");\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst logger = new Logger_1.Logger('Edge11');\nclass Edge11 extends HandlerInterface_1.HandlerInterface {\n    constructor() {\n        super();\n        // Map of RTCRtpSenders indexed by id.\n        this._rtpSenders = new Map();\n        // Map of RTCRtpReceivers indexed by id.\n        this._rtpReceivers = new Map();\n        // Next localId for sending tracks.\n        this._nextSendLocalId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Edge11();\n    }\n    get name() {\n        return 'Edge11';\n    }\n    close() {\n        logger.debug('close()');\n        // Close the ICE gatherer.\n        // NOTE: Not yet implemented by Edge.\n        try {\n            this._iceGatherer.close();\n        }\n        catch (error) { }\n        // Close the ICE transport.\n        try {\n            this._iceTransport.stop();\n        }\n        catch (error) { }\n        // Close the DTLS transport.\n        try {\n            this._dtlsTransport.stop();\n        }\n        catch (error) { }\n        // Close RTCRtpSenders.\n        for (const rtpSender of this._rtpSenders.values()) {\n            try {\n                rtpSender.stop();\n            }\n            catch (error) { }\n        }\n        // Close RTCRtpReceivers.\n        for (const rtpReceiver of this._rtpReceivers.values()) {\n            try {\n                rtpReceiver.stop();\n            }\n            catch (error) { }\n        }\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        return edgeUtils.getCapabilities();\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: { OS: 0, MIS: 0 }\n        };\n    }\n    run({ direction, // eslint-disable-line @typescript-eslint/no-unused-vars\n    iceParameters, iceCandidates, dtlsParameters, sctpParameters, // eslint-disable-line @typescript-eslint/no-unused-vars\n    iceServers, iceTransportPolicy, additionalSettings, // eslint-disable-line @typescript-eslint/no-unused-vars\n    proprietaryConstraints, // eslint-disable-line @typescript-eslint/no-unused-vars\n    extendedRtpCapabilities }) {\n        logger.debug('run()');\n        this._sendingRtpParametersByKind =\n            {\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._remoteIceParameters = iceParameters;\n        this._remoteIceCandidates = iceCandidates;\n        this._remoteDtlsParameters = dtlsParameters;\n        this._cname = `CNAME-${utils.generateRandomNumber()}`;\n        this._setIceGatherer({ iceServers, iceTransportPolicy });\n        this._setIceTransport();\n        this._setDtlsTransport();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async updateIceServers(iceServers) {\n        // NOTE: Edge 11 does not implement iceGatherer.gater().\n        throw new errors_1.UnsupportedError('not supported');\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        this._remoteIceParameters = iceParameters;\n        if (!this._transportReady)\n            return;\n        logger.debug('restartIce() | calling iceTransport.start()');\n        this._iceTransport.start(this._iceGatherer, iceParameters, 'controlling');\n        for (const candidate of this._remoteIceCandidates) {\n            this._iceTransport.addRemoteCandidate(candidate);\n        }\n        this._iceTransport.addRemoteCandidate({});\n    }\n    async getTransportStats() {\n        return this._iceTransport.getStats();\n    }\n    async send(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    { track, encodings, codecOptions, codec }) {\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'server' });\n        logger.debug('send() | calling new RTCRtpSender()');\n        const rtpSender = new RTCRtpSender(track, this._dtlsTransport);\n        const rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);\n        const useRtx = rtpParameters.codecs\n            .some((_codec) => /.+\\/rtx$/i.test(_codec.mimeType));\n        if (!encodings)\n            encodings = [{}];\n        for (const encoding of encodings) {\n            encoding.ssrc = utils.generateRandomNumber();\n            if (useRtx)\n                encoding.rtx = { ssrc: utils.generateRandomNumber() };\n        }\n        rtpParameters.encodings = encodings;\n        // Fill RTCRtpParameters.rtcp.\n        rtpParameters.rtcp =\n            {\n                cname: this._cname,\n                reducedSize: true,\n                mux: true\n            };\n        // NOTE: Convert our standard RTCRtpParameters into those that Edge\n        // expects.\n        const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);\n        logger.debug('send() | calling rtpSender.send() [params:%o]', edgeRtpParameters);\n        await rtpSender.send(edgeRtpParameters);\n        const localId = String(this._nextSendLocalId);\n        this._nextSendLocalId++;\n        // Store it.\n        this._rtpSenders.set(localId, rtpSender);\n        return { localId, rtpParameters, rtpSender };\n    }\n    async stopSending(localId) {\n        logger.debug('stopSending() [localId:%s]', localId);\n        const rtpSender = this._rtpSenders.get(localId);\n        if (!rtpSender)\n            throw new Error('RTCRtpSender not found');\n        this._rtpSenders.delete(localId);\n        try {\n            logger.debug('stopSending() | calling rtpSender.stop()');\n            rtpSender.stop();\n        }\n        catch (error) {\n            logger.warn('stopSending() | rtpSender.stop() failed:%o', error);\n            throw error;\n        }\n    }\n    async replaceTrack(localId, track) {\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const rtpSender = this._rtpSenders.get(localId);\n        if (!rtpSender)\n            throw new Error('RTCRtpSender not found');\n        rtpSender.setTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const rtpSender = this._rtpSenders.get(localId);\n        if (!rtpSender)\n            throw new Error('RTCRtpSender not found');\n        const parameters = rtpSender.getParameters();\n        parameters.encodings\n            .forEach((encoding, idx) => {\n            if (idx <= spatialLayer)\n                encoding.active = true;\n            else\n                encoding.active = false;\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const rtpSender = this._rtpSenders.get(localId);\n        if (!rtpSender)\n            throw new Error('RTCRtpSender not found');\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async getSenderStats(localId) {\n        const rtpSender = this._rtpSenders.get(localId);\n        if (!rtpSender)\n            throw new Error('RTCRtpSender not found');\n        return rtpSender.getStats();\n    }\n    async sendDataChannel(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    options) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async receive({ trackId, kind, rtpParameters }) {\n        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'server' });\n        logger.debug('receive() | calling new RTCRtpReceiver()');\n        const rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);\n        rtpReceiver.addEventListener('error', (event) => {\n            logger.error('rtpReceiver \"error\" event [event:%o]', event);\n        });\n        // NOTE: Convert our standard RTCRtpParameters into those that Edge\n        // expects.\n        const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);\n        logger.debug('receive() | calling rtpReceiver.receive() [params:%o]', edgeRtpParameters);\n        await rtpReceiver.receive(edgeRtpParameters);\n        const localId = trackId;\n        // Store it.\n        this._rtpReceivers.set(localId, rtpReceiver);\n        return {\n            localId,\n            track: rtpReceiver.track,\n            rtpReceiver\n        };\n    }\n    async stopReceiving(localId) {\n        logger.debug('stopReceiving() [localId:%s]', localId);\n        const rtpReceiver = this._rtpReceivers.get(localId);\n        if (!rtpReceiver)\n            throw new Error('RTCRtpReceiver not found');\n        this._rtpReceivers.delete(localId);\n        try {\n            logger.debug('stopReceiving() | calling rtpReceiver.stop()');\n            rtpReceiver.stop();\n        }\n        catch (error) {\n            logger.warn('stopReceiving() | rtpReceiver.stop() failed:%o', error);\n        }\n    }\n    async getReceiverStats(localId) {\n        const rtpReceiver = this._rtpReceivers.get(localId);\n        if (!rtpReceiver)\n            throw new Error('RTCRtpReceiver not found');\n        return rtpReceiver.getStats();\n    }\n    async receiveDataChannel(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    options) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    _setIceGatherer({ iceServers, iceTransportPolicy }) {\n        const iceGatherer = new RTCIceGatherer({\n            iceServers: iceServers || [],\n            gatherPolicy: iceTransportPolicy || 'all'\n        });\n        iceGatherer.addEventListener('error', (event) => {\n            logger.error('iceGatherer \"error\" event [event:%o]', event);\n        });\n        // NOTE: Not yet implemented by Edge, which starts gathering automatically.\n        try {\n            iceGatherer.gather();\n        }\n        catch (error) {\n            logger.debug('_setIceGatherer() | iceGatherer.gather() failed: %s', error.toString());\n        }\n        this._iceGatherer = iceGatherer;\n    }\n    _setIceTransport() {\n        const iceTransport = new RTCIceTransport(this._iceGatherer);\n        // NOTE: Not yet implemented by Edge.\n        iceTransport.addEventListener('statechange', () => {\n            switch (iceTransport.state) {\n                case 'checking':\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                case 'connected':\n                case 'completed':\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                case 'failed':\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                case 'disconnected':\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                case 'closed':\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n            }\n        });\n        // NOTE: Not standard, but implemented by Edge.\n        iceTransport.addEventListener('icestatechange', () => {\n            switch (iceTransport.state) {\n                case 'checking':\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                case 'connected':\n                case 'completed':\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                case 'failed':\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                case 'disconnected':\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                case 'closed':\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n            }\n        });\n        iceTransport.addEventListener('candidatepairchange', (event) => {\n            logger.debug('iceTransport \"candidatepairchange\" event [pair:%o]', event.pair);\n        });\n        this._iceTransport = iceTransport;\n    }\n    _setDtlsTransport() {\n        const dtlsTransport = new RTCDtlsTransport(this._iceTransport);\n        // NOTE: Not yet implemented by Edge.\n        dtlsTransport.addEventListener('statechange', () => {\n            logger.debug('dtlsTransport \"statechange\" event [state:%s]', dtlsTransport.state);\n        });\n        // NOTE: Not standard, but implemented by Edge.\n        dtlsTransport.addEventListener('dtlsstatechange', () => {\n            logger.debug('dtlsTransport \"dtlsstatechange\" event [state:%s]', dtlsTransport.state);\n            if (dtlsTransport.state === 'closed')\n                this.emit('@connectionstatechange', 'closed');\n        });\n        dtlsTransport.addEventListener('error', (event) => {\n            logger.error('dtlsTransport \"error\" event [event:%o]', event);\n        });\n        this._dtlsTransport = dtlsTransport;\n    }\n    async _setupTransport({ localDtlsRole }) {\n        logger.debug('_setupTransport()');\n        // Get our local DTLS parameters.\n        const dtlsParameters = this._dtlsTransport.getLocalParameters();\n        dtlsParameters.role = localDtlsRole;\n        // Need to tell the remote transport about our parameters.\n        await this.safeEmitAsPromise('@connect', { dtlsParameters });\n        // Start the RTCIceTransport.\n        this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, 'controlling');\n        // Add remote ICE candidates.\n        for (const candidate of this._remoteIceCandidates) {\n            this._iceTransport.addRemoteCandidate(candidate);\n        }\n        // Also signal a 'complete' candidate as per spec.\n        // NOTE: It should be {complete: true} but Edge prefers {}.\n        // NOTE: If we don't signal end of candidates, the Edge RTCIceTransport\n        // won't enter the 'completed' state.\n        this._iceTransport.addRemoteCandidate({});\n        // NOTE: Edge does not like SHA less than 256.\n        this._remoteDtlsParameters.fingerprints = this._remoteDtlsParameters.fingerprints\n            .filter((fingerprint) => {\n            return (fingerprint.algorithm === 'sha-256' ||\n                fingerprint.algorithm === 'sha-384' ||\n                fingerprint.algorithm === 'sha-512');\n        });\n        // Start the RTCDtlsTransport.\n        this._dtlsTransport.start(this._remoteDtlsParameters);\n        this._transportReady = true;\n    }\n}\nexports.Edge11 = Edge11;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvRWRnZTExLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0VkZ2UxMS5qcz9lZTZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBvcnRjID0gcmVxdWlyZShcIi4uL29ydGNcIik7XG5jb25zdCBlZGdlVXRpbHMgPSByZXF1aXJlKFwiLi9vcnRjL2VkZ2VVdGlsc1wiKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdFZGdlMTEnKTtcbmNsYXNzIEVkZ2UxMSBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1J0cFNlbmRlcnMgaW5kZXhlZCBieSBpZC5cbiAgICAgICAgdGhpcy5fcnRwU2VuZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1J0cFJlY2VpdmVycyBpbmRleGVkIGJ5IGlkLlxuICAgICAgICB0aGlzLl9ydHBSZWNlaXZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE5leHQgbG9jYWxJZCBmb3Igc2VuZGluZyB0cmFja3MuXG4gICAgICAgIHRoaXMuX25leHRTZW5kTG9jYWxJZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBFZGdlMTEoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnRWRnZTExJztcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICAvLyBDbG9zZSB0aGUgSUNFIGdhdGhlcmVyLlxuICAgICAgICAvLyBOT1RFOiBOb3QgeWV0IGltcGxlbWVudGVkIGJ5IEVkZ2UuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9pY2VHYXRoZXJlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIC8vIENsb3NlIHRoZSBJQ0UgdHJhbnNwb3J0LlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5faWNlVHJhbnNwb3J0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAvLyBDbG9zZSB0aGUgRFRMUyB0cmFuc3BvcnQuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9kdGxzVHJhbnNwb3J0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAvLyBDbG9zZSBSVENSdHBTZW5kZXJzLlxuICAgICAgICBmb3IgKGNvbnN0IHJ0cFNlbmRlciBvZiB0aGlzLl9ydHBTZW5kZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJ0cFNlbmRlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsb3NlIFJUQ1J0cFJlY2VpdmVycy5cbiAgICAgICAgZm9yIChjb25zdCBydHBSZWNlaXZlciBvZiB0aGlzLl9ydHBSZWNlaXZlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcnRwUmVjZWl2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VVdGlscy5nZXRDYXBhYmlsaXRpZXMoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IHsgT1M6IDAsIE1JUzogMCB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bih7IGRpcmVjdGlvbiwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuX3JlbW90ZUljZVBhcmFtZXRlcnMgPSBpY2VQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9yZW1vdGVJY2VDYW5kaWRhdGVzID0gaWNlQ2FuZGlkYXRlcztcbiAgICAgICAgdGhpcy5fcmVtb3RlRHRsc1BhcmFtZXRlcnMgPSBkdGxzUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fY25hbWUgPSBgQ05BTUUtJHt1dGlscy5nZW5lcmF0ZVJhbmRvbU51bWJlcigpfWA7XG4gICAgICAgIHRoaXMuX3NldEljZUdhdGhlcmVyKHsgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5IH0pO1xuICAgICAgICB0aGlzLl9zZXRJY2VUcmFuc3BvcnQoKTtcbiAgICAgICAgdGhpcy5fc2V0RHRsc1RyYW5zcG9ydCgpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIC8vIE5PVEU6IEVkZ2UgMTEgZG9lcyBub3QgaW1wbGVtZW50IGljZUdhdGhlcmVyLmdhdGVyKCkuXG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICB0aGlzLl9yZW1vdGVJY2VQYXJhbWV0ZXJzID0gaWNlUGFyYW1ldGVycztcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIGljZVRyYW5zcG9ydC5zdGFydCgpJyk7XG4gICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5zdGFydCh0aGlzLl9pY2VHYXRoZXJlciwgaWNlUGFyYW1ldGVycywgJ2NvbnRyb2xsaW5nJyk7XG4gICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHRoaXMuX3JlbW90ZUljZUNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pY2VUcmFuc3BvcnQuYWRkUmVtb3RlQ2FuZGlkYXRlKHt9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNwb3J0U3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pY2VUcmFuc3BvcnQuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgW2tpbmQ6JXMsIHRyYWNrLmlkOiVzXScsIHRyYWNrLmtpbmQsIHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicgfSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBuZXcgUlRDUnRwU2VuZGVyKCknKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gbmV3IFJUQ1J0cFNlbmRlcih0cmFjaywgdGhpcy5fZHRsc1RyYW5zcG9ydCk7XG4gICAgICAgIGNvbnN0IHJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIHJ0cFBhcmFtZXRlcnMuY29kZWNzID0gb3J0Yy5yZWR1Y2VDb2RlY3MocnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3QgdXNlUnR4ID0gcnRwUGFyYW1ldGVycy5jb2RlY3NcbiAgICAgICAgICAgIC5zb21lKChfY29kZWMpID0+IC8uK1xcL3J0eCQvaS50ZXN0KF9jb2RlYy5taW1lVHlwZSkpO1xuICAgICAgICBpZiAoIWVuY29kaW5ncylcbiAgICAgICAgICAgIGVuY29kaW5ncyA9IFt7fV07XG4gICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2YgZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBlbmNvZGluZy5zc3JjID0gdXRpbHMuZ2VuZXJhdGVSYW5kb21OdW1iZXIoKTtcbiAgICAgICAgICAgIGlmICh1c2VSdHgpXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcucnR4ID0geyBzc3JjOiB1dGlscy5nZW5lcmF0ZVJhbmRvbU51bWJlcigpIH07XG4gICAgICAgIH1cbiAgICAgICAgcnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICAgIC8vIEZpbGwgUlRDUnRwUGFyYW1ldGVycy5ydGNwLlxuICAgICAgICBydHBQYXJhbWV0ZXJzLnJ0Y3AgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNuYW1lOiB0aGlzLl9jbmFtZSxcbiAgICAgICAgICAgICAgICByZWR1Y2VkU2l6ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtdXg6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8vIE5PVEU6IENvbnZlcnQgb3VyIHN0YW5kYXJkIFJUQ1J0cFBhcmFtZXRlcnMgaW50byB0aG9zZSB0aGF0IEVkZ2VcbiAgICAgICAgLy8gZXhwZWN0cy5cbiAgICAgICAgY29uc3QgZWRnZVJ0cFBhcmFtZXRlcnMgPSBlZGdlVXRpbHMubWFuZ2xlUnRwUGFyYW1ldGVycyhydHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHJ0cFNlbmRlci5zZW5kKCkgW3BhcmFtczolb10nLCBlZGdlUnRwUGFyYW1ldGVycyk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZW5kKGVkZ2VSdHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IFN0cmluZyh0aGlzLl9uZXh0U2VuZExvY2FsSWQpO1xuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQrKztcbiAgICAgICAgLy8gU3RvcmUgaXQuXG4gICAgICAgIHRoaXMuX3J0cFNlbmRlcnMuc2V0KGxvY2FsSWQsIHJ0cFNlbmRlcik7XG4gICAgICAgIHJldHVybiB7IGxvY2FsSWQsIHJ0cFBhcmFtZXRlcnMsIHJ0cFNlbmRlciB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcnRwU2VuZGVycy5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHRoaXMuX3J0cFNlbmRlcnMuZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBydHBTZW5kZXIuc3RvcCgpJyk7XG4gICAgICAgICAgICBydHBTZW5kZXIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3N0b3BTZW5kaW5nKCkgfCBydHBTZW5kZXIuc3RvcCgpIGZhaWxlZDolbycsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhsb2NhbElkLCB0cmFjaykge1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX3J0cFNlbmRlcnMuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBydHBTZW5kZXIuc2V0VHJhY2sodHJhY2spO1xuICAgIH1cbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIobG9jYWxJZCwgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgW2xvY2FsSWQ6JXMsIHNwYXRpYWxMYXllcjolc10nLCBsb2NhbElkLCBzcGF0aWFsTGF5ZXIpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9ydHBTZW5kZXJzLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJ0cFNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzXG4gICAgICAgICAgICAuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA8PSBzcGF0aWFsTGF5ZXIpXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9ydHBTZW5kZXJzLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJ0cFNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSB7IC4uLmVuY29kaW5nLCAuLi5wYXJhbXMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX3J0cFNlbmRlcnMuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICByZXR1cm4gcnRwU2VuZGVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREYXRhQ2hhbm5lbChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUoeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInIH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgbmV3IFJUQ1J0cFJlY2VpdmVyKCknKTtcbiAgICAgICAgY29uc3QgcnRwUmVjZWl2ZXIgPSBuZXcgUlRDUnRwUmVjZWl2ZXIodGhpcy5fZHRsc1RyYW5zcG9ydCwga2luZCk7XG4gICAgICAgIHJ0cFJlY2VpdmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ3J0cFJlY2VpdmVyIFwiZXJyb3JcIiBldmVudCBbZXZlbnQ6JW9dJywgZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URTogQ29udmVydCBvdXIgc3RhbmRhcmQgUlRDUnRwUGFyYW1ldGVycyBpbnRvIHRob3NlIHRoYXQgRWRnZVxuICAgICAgICAvLyBleHBlY3RzLlxuICAgICAgICBjb25zdCBlZGdlUnRwUGFyYW1ldGVycyA9IGVkZ2VVdGlscy5tYW5nbGVSdHBQYXJhbWV0ZXJzKHJ0cFBhcmFtZXRlcnMpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcnRwUmVjZWl2ZXIucmVjZWl2ZSgpIFtwYXJhbXM6JW9dJywgZWRnZVJ0cFBhcmFtZXRlcnMpO1xuICAgICAgICBhd2FpdCBydHBSZWNlaXZlci5yZWNlaXZlKGVkZ2VSdHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IHRyYWNrSWQ7XG4gICAgICAgIC8vIFN0b3JlIGl0LlxuICAgICAgICB0aGlzLl9ydHBSZWNlaXZlcnMuc2V0KGxvY2FsSWQsIHJ0cFJlY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICB0cmFjazogcnRwUmVjZWl2ZXIudHJhY2ssXG4gICAgICAgICAgICBydHBSZWNlaXZlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWQpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHJ0cFJlY2VpdmVyID0gdGhpcy5fcnRwUmVjZWl2ZXJzLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBSZWNlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUlRDUnRwUmVjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHRoaXMuX3J0cFJlY2VpdmVycy5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcnRwUmVjZWl2ZXIuc3RvcCgpJyk7XG4gICAgICAgICAgICBydHBSZWNlaXZlci5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIud2Fybignc3RvcFJlY2VpdmluZygpIHwgcnRwUmVjZWl2ZXIuc3RvcCgpIGZhaWxlZDolbycsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgY29uc3QgcnRwUmVjZWl2ZXIgPSB0aGlzLl9ydHBSZWNlaXZlcnMuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFJlY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSVENSdHBSZWNlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHJ0cFJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIF9zZXRJY2VHYXRoZXJlcih7IGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSB9KSB7XG4gICAgICAgIGNvbnN0IGljZUdhdGhlcmVyID0gbmV3IFJUQ0ljZUdhdGhlcmVyKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMgfHwgW10sXG4gICAgICAgICAgICBnYXRoZXJQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSB8fCAnYWxsJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWNlR2F0aGVyZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignaWNlR2F0aGVyZXIgXCJlcnJvclwiIGV2ZW50IFtldmVudDolb10nLCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOT1RFOiBOb3QgeWV0IGltcGxlbWVudGVkIGJ5IEVkZ2UsIHdoaWNoIHN0YXJ0cyBnYXRoZXJpbmcgYXV0b21hdGljYWxseS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGljZUdhdGhlcmVyLmdhdGhlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdfc2V0SWNlR2F0aGVyZXIoKSB8IGljZUdhdGhlcmVyLmdhdGhlcigpIGZhaWxlZDogJXMnLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pY2VHYXRoZXJlciA9IGljZUdhdGhlcmVyO1xuICAgIH1cbiAgICBfc2V0SWNlVHJhbnNwb3J0KCkge1xuICAgICAgICBjb25zdCBpY2VUcmFuc3BvcnQgPSBuZXcgUlRDSWNlVHJhbnNwb3J0KHRoaXMuX2ljZUdhdGhlcmVyKTtcbiAgICAgICAgLy8gTk9URTogTm90IHlldCBpbXBsZW1lbnRlZCBieSBFZGdlLlxuICAgICAgICBpY2VUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGljZVRyYW5zcG9ydC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URTogTm90IHN0YW5kYXJkLCBidXQgaW1wbGVtZW50ZWQgYnkgRWRnZS5cbiAgICAgICAgaWNlVHJhbnNwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2ljZXN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChpY2VUcmFuc3BvcnQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2luZyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGljZVRyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKCdjYW5kaWRhdGVwYWlyY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2ljZVRyYW5zcG9ydCBcImNhbmRpZGF0ZXBhaXJjaGFuZ2VcIiBldmVudCBbcGFpcjolb10nLCBldmVudC5wYWlyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydCA9IGljZVRyYW5zcG9ydDtcbiAgICB9XG4gICAgX3NldER0bHNUcmFuc3BvcnQoKSB7XG4gICAgICAgIGNvbnN0IGR0bHNUcmFuc3BvcnQgPSBuZXcgUlRDRHRsc1RyYW5zcG9ydCh0aGlzLl9pY2VUcmFuc3BvcnQpO1xuICAgICAgICAvLyBOT1RFOiBOb3QgeWV0IGltcGxlbWVudGVkIGJ5IEVkZ2UuXG4gICAgICAgIGR0bHNUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2R0bHNUcmFuc3BvcnQgXCJzdGF0ZWNoYW5nZVwiIGV2ZW50IFtzdGF0ZTolc10nLCBkdGxzVHJhbnNwb3J0LnN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5PVEU6IE5vdCBzdGFuZGFyZCwgYnV0IGltcGxlbWVudGVkIGJ5IEVkZ2UuXG4gICAgICAgIGR0bHNUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignZHRsc3N0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdkdGxzVHJhbnNwb3J0IFwiZHRsc3N0YXRlY2hhbmdlXCIgZXZlbnQgW3N0YXRlOiVzXScsIGR0bHNUcmFuc3BvcnQuc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGR0bHNUcmFuc3BvcnQuc3RhdGUgPT09ICdjbG9zZWQnKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGR0bHNUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignZHRsc1RyYW5zcG9ydCBcImVycm9yXCIgZXZlbnQgW2V2ZW50OiVvXScsIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2R0bHNUcmFuc3BvcnQgPSBkdGxzVHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBfc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdfc2V0dXBUcmFuc3BvcnQoKScpO1xuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSB0aGlzLl9kdGxzVHJhbnNwb3J0LmdldExvY2FsUGFyYW1ldGVycygpO1xuICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID0gbG9jYWxEdGxzUm9sZTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSk7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSBSVENJY2VUcmFuc3BvcnQuXG4gICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5zdGFydCh0aGlzLl9pY2VHYXRoZXJlciwgdGhpcy5fcmVtb3RlSWNlUGFyYW1ldGVycywgJ2NvbnRyb2xsaW5nJyk7XG4gICAgICAgIC8vIEFkZCByZW1vdGUgSUNFIGNhbmRpZGF0ZXMuXG4gICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHRoaXMuX3JlbW90ZUljZUNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHNvIHNpZ25hbCBhICdjb21wbGV0ZScgY2FuZGlkYXRlIGFzIHBlciBzcGVjLlxuICAgICAgICAvLyBOT1RFOiBJdCBzaG91bGQgYmUge2NvbXBsZXRlOiB0cnVlfSBidXQgRWRnZSBwcmVmZXJzIHt9LlxuICAgICAgICAvLyBOT1RFOiBJZiB3ZSBkb24ndCBzaWduYWwgZW5kIG9mIGNhbmRpZGF0ZXMsIHRoZSBFZGdlIFJUQ0ljZVRyYW5zcG9ydFxuICAgICAgICAvLyB3b24ndCBlbnRlciB0aGUgJ2NvbXBsZXRlZCcgc3RhdGUuXG4gICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoe30pO1xuICAgICAgICAvLyBOT1RFOiBFZGdlIGRvZXMgbm90IGxpa2UgU0hBIGxlc3MgdGhhbiAyNTYuXG4gICAgICAgIHRoaXMuX3JlbW90ZUR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50cyA9IHRoaXMuX3JlbW90ZUR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50c1xuICAgICAgICAgICAgLmZpbHRlcigoZmluZ2VycHJpbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoZmluZ2VycHJpbnQuYWxnb3JpdGhtID09PSAnc2hhLTI1NicgfHxcbiAgICAgICAgICAgICAgICBmaW5nZXJwcmludC5hbGdvcml0aG0gPT09ICdzaGEtMzg0JyB8fFxuICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LmFsZ29yaXRobSA9PT0gJ3NoYS01MTInKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSBSVENEdGxzVHJhbnNwb3J0LlxuICAgICAgICB0aGlzLl9kdGxzVHJhbnNwb3J0LnN0YXJ0KHRoaXMuX3JlbW90ZUR0bHNQYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuRWRnZTExID0gRWRnZTExO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/Edge11.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Firefox60.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Firefox60.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\nconst ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\nconst sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\nconst sdpUnifiedPlanUtils = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\");\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst logger = new Logger_1.Logger('Firefox60');\nconst SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };\nclass Firefox60 extends HandlerInterface_1.HandlerInterface {\n    constructor() {\n        super();\n        // Map of RTCTransceivers indexed by MID.\n        this._mapMidTransceiver = new Map();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Firefox60();\n    }\n    get name() {\n        return 'Firefox60';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require'\n        });\n        // NOTE: We need to add a real video track to get the RID extension mapping.\n        const canvas = document.createElement('canvas');\n        // NOTE: Otherwise Firefox fails in next line.\n        canvas.getContext('2d');\n        const fakeStream = canvas.captureStream();\n        const fakeVideoTrack = fakeStream.getVideoTracks()[0];\n        try {\n            pc.addTransceiver('audio', { direction: 'sendrecv' });\n            const videoTransceiver = pc.addTransceiver(fakeVideoTrack, { direction: 'sendrecv' });\n            const parameters = videoTransceiver.sender.getParameters();\n            const encodings = [\n                { rid: 'r0', maxBitrate: 100000 },\n                { rid: 'r1', maxBitrate: 500000 }\n            ];\n            parameters.encodings = encodings;\n            await videoTransceiver.sender.setParameters(parameters);\n            const offer = await pc.createOffer();\n            try {\n                canvas.remove();\n            }\n            catch (error) { }\n            try {\n                fakeVideoTrack.stop();\n            }\n            catch (error) { }\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                canvas.remove();\n            }\n            catch (error2) { }\n            try {\n                fakeVideoTrack.stop();\n            }\n            catch (error2) { }\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters\n        });\n        this._sendingRtpParametersByKind =\n            {\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._sendingRemoteRtpParametersByKind =\n            {\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            ...additionalSettings\n        }, proprietaryConstraints);\n        // Handle RTCPeerConnection connection status.\n        this._pc.addEventListener('iceconnectionstatechange', () => {\n            switch (this._pc.iceConnectionState) {\n                case 'checking':\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                case 'connected':\n                case 'completed':\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                case 'failed':\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                case 'disconnected':\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                case 'closed':\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async updateIceServers(iceServers) {\n        // NOTE: Firefox does not implement pc.setConfiguration().\n        throw new errors_1.UnsupportedError('not supported');\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady)\n            return;\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec }) {\n        this._assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        let reverseEncodings;\n        if (encodings && encodings.length > 1) {\n            encodings.forEach((encoding, idx) => {\n                encoding.rid = `r${idx}`;\n            });\n            // Clone the encodings and reverse them because Firefox likes them\n            // from high to low.\n            reverseEncodings = utils.clone(encodings).reverse();\n        }\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRemoteRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n        // NOTE: Firefox fails sometimes to properly anticipate the closed media\n        // section that it should use, so don't reuse closed media sections.\n        //   https://github.com/versatica/mediasoup-client/issues/104\n        //\n        // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();\n        const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });\n        // NOTE: This is not spec compliants. Encodings should be given in addTransceiver\n        // second argument, but Firefox does not support it.\n        if (reverseEncodings) {\n            const parameters = transceiver.sender.getParameters();\n            parameters.encodings = reverseEncodings;\n            await transceiver.sender.setParameters(parameters);\n        }\n        const offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        // In Firefox use DTLS role client even if we are the \"offerer\" since\n        // Firefox does not respect ICE-Lite.\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        // We can now get the transceiver.mid.\n        const localId = transceiver.mid;\n        // Set MID.\n        sendingRtpParameters.mid = localId;\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname =\n            sdpCommonUtils.getCname({ offerMediaObject });\n        // Set RTP encodings by parsing the SDP offer if no encodings are given.\n        if (!encodings) {\n            sendingRtpParameters.encodings =\n                sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\n        }\n        // Set RTP encodings by parsing the SDP offer and complete them with given\n        // one if just a single encoding has been given.\n        else if (encodings.length === 1) {\n            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\n            Object.assign(newEncodings[0], encodings[0]);\n            sendingRtpParameters.encodings = newEncodings;\n        }\n        // Otherwise if more than 1 encoding are given use them verbatim.\n        else {\n            sendingRtpParameters.encodings = encodings;\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'S1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n            extmapAllowMixed: true\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender: transceiver.sender\n        };\n    }\n    async stopSending(localId) {\n        logger.debug('stopSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated transceiver not found');\n        transceiver.sender.replaceTrack(null);\n        this._pc.removeTrack(transceiver.sender);\n        // NOTE: Cannot use closeMediaSection() due to the the note above in send()\n        // method.\n        // this._remoteSdp!.closeMediaSection(transceiver.mid);\n        this._remoteSdp.disableMediaSection(transceiver.mid);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this._assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        await transceiver.sender.replaceTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this._assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated transceiver not found');\n        const parameters = transceiver.sender.getParameters();\n        // NOTE: We require encodings given from low to high, however Firefox\n        // requires them in reverse order, so do magic here.\n        spatialLayer = parameters.encodings.length - 1 - spatialLayer;\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx >= spatialLayer)\n                encoding.active = true;\n            else\n                encoding.active = false;\n        });\n        await transceiver.sender.setParameters(parameters);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this._assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await transceiver.sender.setParameters(parameters);\n    }\n    async getSenderStats(localId) {\n        this._assertSendDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        return transceiver.sender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\n        this._assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n            priority\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'application');\n            if (!this._transportReady)\n                await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive({ trackId, kind, rtpParameters }) {\n        this._assertRecvDirection();\n        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n        const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n        this._remoteSdp.receive({\n            mid: localId,\n            kind,\n            offerRtpParameters: rtpParameters,\n            streamId: rtpParameters.rtcp.cname,\n            trackId\n        });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        const answerMediaObject = localSdpObject.media\n            .find((m) => String(m.mid) === localId);\n        // May need to modify codec parameters in the answer based on codec\n        // parameters in the offer.\n        sdpCommonUtils.applyCodecParameters({\n            offerRtpParameters: rtpParameters,\n            answerMediaObject\n        });\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        const transceiver = this._pc.getTransceivers()\n            .find((t) => t.mid === localId);\n        if (!transceiver)\n            throw new Error('new RTCRtpTransceiver not found');\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            track: transceiver.receiver.track,\n            rtpReceiver: transceiver.receiver\n        };\n    }\n    async stopReceiving(localId) {\n        this._assertRecvDirection();\n        logger.debug('stopReceiving() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        this._remoteSdp.closeMediaSection(transceiver.mid);\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this._assertRecvDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        return transceiver.receiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {\n        this._assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation();\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async _setupTransport({ localDtlsRole, localSdpObject }) {\n        if (!localSdpObject)\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await this.safeEmitAsPromise('@connect', { dtlsParameters });\n        this._transportReady = true;\n    }\n    _assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    _assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Firefox60 = Firefox60;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvRmlyZWZveDYwLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0ZpcmVmb3g2MC5qcz9kODU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc2RwVHJhbnNmb3JtID0gcmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIik7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IG9ydGMgPSByZXF1aXJlKFwiLi4vb3J0Y1wiKTtcbmNvbnN0IHNkcENvbW1vblV0aWxzID0gcmVxdWlyZShcIi4vc2RwL2NvbW1vblV0aWxzXCIpO1xuY29uc3Qgc2RwVW5pZmllZFBsYW5VdGlscyA9IHJlcXVpcmUoXCIuL3NkcC91bmlmaWVkUGxhblV0aWxzXCIpO1xuY29uc3QgSGFuZGxlckludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vSGFuZGxlckludGVyZmFjZVwiKTtcbmNvbnN0IFJlbW90ZVNkcF8xID0gcmVxdWlyZShcIi4vc2RwL1JlbW90ZVNkcFwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0ZpcmVmb3g2MCcpO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDE2LCBNSVM6IDIwNDggfTtcbmNsYXNzIEZpcmVmb3g2MCBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1RyYW5zY2VpdmVycyBpbmRleGVkIGJ5IE1JRC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBGaXJlZm94NjAoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnRmlyZWZveDYwJztcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICAvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJ1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URTogV2UgbmVlZCB0byBhZGQgYSByZWFsIHZpZGVvIHRyYWNrIHRvIGdldCB0aGUgUklEIGV4dGVuc2lvbiBtYXBwaW5nLlxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgLy8gTk9URTogT3RoZXJ3aXNlIEZpcmVmb3ggZmFpbHMgaW4gbmV4dCBsaW5lLlxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29uc3QgZmFrZVN0cmVhbSA9IGNhbnZhcy5jYXB0dXJlU3RyZWFtKCk7XG4gICAgICAgIGNvbnN0IGZha2VWaWRlb1RyYWNrID0gZmFrZVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJywgeyBkaXJlY3Rpb246ICdzZW5kcmVjdicgfSk7XG4gICAgICAgICAgICBjb25zdCB2aWRlb1RyYW5zY2VpdmVyID0gcGMuYWRkVHJhbnNjZWl2ZXIoZmFrZVZpZGVvVHJhY2ssIHsgZGlyZWN0aW9uOiAnc2VuZHJlY3YnIH0pO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHZpZGVvVHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kaW5ncyA9IFtcbiAgICAgICAgICAgICAgICB7IHJpZDogJ3IwJywgbWF4Qml0cmF0ZTogMTAwMDAwIH0sXG4gICAgICAgICAgICAgICAgeyByaWQ6ICdyMScsIG1heEJpdHJhdGU6IDUwMDAwMCB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICAgICAgICBhd2FpdCB2aWRlb1RyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYW52YXMucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmYWtlVmlkZW9UcmFjay5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIGNvbnN0IHNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlUnRwQ2FwYWJpbGl0aWVzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdFJ0cENhcGFiaWxpdGllcyh7IHNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmYWtlVmlkZW9UcmFjay5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcnVuKHsgZGlyZWN0aW9uLCBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzIHx8IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgfHwgJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxTZXR0aW5nc1xuICAgICAgICB9LCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgLy8gSGFuZGxlIFJUQ1BlZXJDb25uZWN0aW9uIGNvbm5lY3Rpb24gc3RhdHVzLlxuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIHVwZGF0ZUljZVNlcnZlcnMoaWNlU2VydmVycykge1xuICAgICAgICAvLyBOT1RFOiBGaXJlZm94IGRvZXMgbm90IGltcGxlbWVudCBwYy5zZXRDb25maWd1cmF0aW9uKCkuXG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICAvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGxldCByZXZlcnNlRW5jb2RpbmdzO1xuICAgICAgICBpZiAoZW5jb2RpbmdzICYmIGVuY29kaW5ncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBlbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnJpZCA9IGByJHtpZHh9YDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIGVuY29kaW5ncyBhbmQgcmV2ZXJzZSB0aGVtIGJlY2F1c2UgRmlyZWZveCBsaWtlcyB0aGVtXG4gICAgICAgICAgICAvLyBmcm9tIGhpZ2ggdG8gbG93LlxuICAgICAgICAgICAgcmV2ZXJzZUVuY29kaW5ncyA9IHV0aWxzLmNsb25lKGVuY29kaW5ncykucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzID1cbiAgICAgICAgICAgIG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9XG4gICAgICAgICAgICBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgLy8gTk9URTogRmlyZWZveCBmYWlscyBzb21ldGltZXMgdG8gcHJvcGVybHkgYW50aWNpcGF0ZSB0aGUgY2xvc2VkIG1lZGlhXG4gICAgICAgIC8vIHNlY3Rpb24gdGhhdCBpdCBzaG91bGQgdXNlLCBzbyBkb24ndCByZXVzZSBjbG9zZWQgbWVkaWEgc2VjdGlvbnMuXG4gICAgICAgIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL3ZlcnNhdGljYS9tZWRpYXNvdXAtY2xpZW50L2lzc3Vlcy8xMDRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgbWVkaWFTZWN0aW9uSWR4ID0gdGhpcy5fcmVtb3RlU2RwIS5nZXROZXh0TWVkaWFTZWN0aW9uSWR4KCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fcGMuYWRkVHJhbnNjZWl2ZXIodHJhY2ssIHsgZGlyZWN0aW9uOiAnc2VuZG9ubHknLCBzdHJlYW1zOiBbdGhpcy5fc2VuZFN0cmVhbV0gfSk7XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgbm90IHNwZWMgY29tcGxpYW50cy4gRW5jb2RpbmdzIHNob3VsZCBiZSBnaXZlbiBpbiBhZGRUcmFuc2NlaXZlclxuICAgICAgICAvLyBzZWNvbmQgYXJndW1lbnQsIGJ1dCBGaXJlZm94IGRvZXMgbm90IHN1cHBvcnQgaXQuXG4gICAgICAgIGlmIChyZXZlcnNlRW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzID0gcmV2ZXJzZUVuY29kaW5ncztcbiAgICAgICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbGV0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgIC8vIEluIEZpcmVmb3ggdXNlIERUTFMgcm9sZSBjbGllbnQgZXZlbiBpZiB3ZSBhcmUgdGhlIFwib2ZmZXJlclwiIHNpbmNlXG4gICAgICAgIC8vIEZpcmVmb3ggZG9lcyBub3QgcmVzcGVjdCBJQ0UtTGl0ZS5cbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAvLyBXZSBjYW4gbm93IGdldCB0aGUgdHJhbnNjZWl2ZXIubWlkLlxuICAgICAgICBjb25zdCBsb2NhbElkID0gdHJhbnNjZWl2ZXIubWlkO1xuICAgICAgICAvLyBTZXQgTUlELlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5taWQgPSBsb2NhbElkO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVtsb2NhbFNkcE9iamVjdC5tZWRpYS5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gU2V0IFJUQ1AgQ05BTUUuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUgPVxuICAgICAgICAgICAgc2RwQ29tbW9uVXRpbHMuZ2V0Q25hbWUoeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncyBieSBwYXJzaW5nIHRoZSBTRFAgb2ZmZXIgaWYgbm8gZW5jb2RpbmdzIGFyZSBnaXZlbi5cbiAgICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9XG4gICAgICAgICAgICAgICAgc2RwVW5pZmllZFBsYW5VdGlscy5nZXRSdHBFbmNvZGluZ3MoeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzIGJ5IHBhcnNpbmcgdGhlIFNEUCBvZmZlciBhbmQgY29tcGxldGUgdGhlbSB3aXRoIGdpdmVuXG4gICAgICAgIC8vIG9uZSBpZiBqdXN0IGEgc2luZ2xlIGVuY29kaW5nIGhhcyBiZWVuIGdpdmVuLlxuICAgICAgICBlbHNlIGlmIChlbmNvZGluZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdFbmNvZGluZ3MgPSBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld0VuY29kaW5nc1swXSwgZW5jb2RpbmdzWzBdKTtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IG5ld0VuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgaWYgbW9yZSB0aGFuIDEgZW5jb2RpbmcgYXJlIGdpdmVuIHVzZSB0aGVtIHZlcmJhdGltLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggb3IgSDI2NCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0b1xuICAgICAgICAvLyBlYWNoIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIChzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcgfHxcbiAgICAgICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2gyNjQnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnUzFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgICAgIGV4dG1hcEFsbG93TWl4ZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJ0cFNlbmRlcjogdHJhbnNjZWl2ZXIuc2VuZGVyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCB0cmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgICAgdGhpcy5fcGMucmVtb3ZlVHJhY2sodHJhbnNjZWl2ZXIuc2VuZGVyKTtcbiAgICAgICAgLy8gTk9URTogQ2Fubm90IHVzZSBjbG9zZU1lZGlhU2VjdGlvbigpIGR1ZSB0byB0aGUgdGhlIG5vdGUgYWJvdmUgaW4gc2VuZCgpXG4gICAgICAgIC8vIG1ldGhvZC5cbiAgICAgICAgLy8gdGhpcy5fcmVtb3RlU2RwIS5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuZGlzYWJsZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2sobG9jYWxJZCwgdHJhY2spIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgW2xvY2FsSWQ6JXMsIHNwYXRpYWxMYXllcjolc10nLCBsb2NhbElkLCBzcGF0aWFsTGF5ZXIpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCB0cmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIC8vIE5PVEU6IFdlIHJlcXVpcmUgZW5jb2RpbmdzIGdpdmVuIGZyb20gbG93IHRvIGhpZ2gsIGhvd2V2ZXIgRmlyZWZveFxuICAgICAgICAvLyByZXF1aXJlcyB0aGVtIGluIHJldmVyc2Ugb3JkZXIsIHNvIGRvIG1hZ2ljIGhlcmUuXG4gICAgICAgIHNwYXRpYWxMYXllciA9IHBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCAtIDEgLSBzcGF0aWFsTGF5ZXI7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPj0gc3BhdGlhbExheWVyKVxuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGxvY2FsSWQsIHBhcmFtcykge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSB7IC4uLmVuY29kaW5nLCAuLi5wYXJhbXMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZERhdGFDaGFubmVsKHsgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCwgcHJvdG9jb2wsIHByaW9yaXR5IH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICBwcmlvcml0eVxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgICAgIC5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgc3RyZWFtSWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICBvcmRlcmVkOiBvcHRpb25zLm9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiBvcHRpb25zLm1heFJldHJhbnNtaXRzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKHsgdHJhY2tJZCwga2luZCwgcnRwUGFyYW1ldGVycyB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSBydHBQYXJhbWV0ZXJzLm1pZCB8fCBTdHJpbmcodGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2l6ZSk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlKHtcbiAgICAgICAgICAgIG1pZDogbG9jYWxJZCxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzdHJlYW1JZDogcnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgdHJhY2tJZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IGxvY2FsSWQpO1xuICAgICAgICAvLyBNYXkgbmVlZCB0byBtb2RpZnkgY29kZWMgcGFyYW1ldGVycyBpbiB0aGUgYW5zd2VyIGJhc2VkIG9uIGNvZGVjXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgaW4gdGhlIG9mZmVyLlxuICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJNZWRpYU9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdjbGllbnQnLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wYy5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAgICAgLmZpbmQoKHQpID0+IHQubWlkID09PSBsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3IFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAvLyBTdG9yZSBpbiB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zZXQobG9jYWxJZCwgdHJhbnNjZWl2ZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgIHRyYWNrOiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjayxcbiAgICAgICAgICAgIHJ0cFJlY2VpdmVyOiB0cmFuc2NlaXZlci5yZWNlaXZlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlRGF0YUNoYW5uZWwoeyBzY3RwU3RyZWFtUGFyYW1ldGVycywgbGFiZWwsIHByb3RvY29sIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB7IHN0cmVhbUlkLCBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMgfSA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2xcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgb2ZmZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlU2N0cEFzc29jaWF0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KVxuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoeyBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgX2Fzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRmlyZWZveDYwID0gRmlyZWZveDYwO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/Firefox60.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js":
/*!************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\nclass HandlerInterface extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    /**\n     * @emits @connect - (\n     *     { dtlsParameters: DtlsParameters },\n     *     callback: Function,\n     *     errback: Function\n     *   )\n     * @emits @connectionstatechange - (connectionState: ConnectionState)\n     */\n    constructor() {\n        super();\n    }\n}\nexports.HandlerInterface = HandlerInterface;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvSGFuZGxlckludGVyZmFjZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3J4X3NvY2tldGlvX2NsaWVudC8uL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9IYW5kbGVySW50ZXJmYWNlLmpzP2Q3M2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4uL0VuaGFuY2VkRXZlbnRFbWl0dGVyXCIpO1xuY2xhc3MgSGFuZGxlckludGVyZmFjZSBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEBlbWl0cyBAY29ubmVjdCAtIChcbiAgICAgKiAgICAgeyBkdGxzUGFyYW1ldGVyczogRHRsc1BhcmFtZXRlcnMgfSxcbiAgICAgKiAgICAgY2FsbGJhY2s6IEZ1bmN0aW9uLFxuICAgICAqICAgICBlcnJiYWNrOiBGdW5jdGlvblxuICAgICAqICAgKVxuICAgICAqIEBlbWl0cyBAY29ubmVjdGlvbnN0YXRlY2hhbmdlIC0gKGNvbm5lY3Rpb25TdGF0ZTogQ29ubmVjdGlvblN0YXRlKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFuZGxlckludGVyZmFjZSA9IEhhbmRsZXJJbnRlcmZhY2U7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/ReactNative.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ReactNative.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\nconst ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\nconst sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\nconst sdpPlanBUtils = __webpack_require__(/*! ./sdp/planBUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\");\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst logger = new Logger_1.Logger('ReactNative');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass ReactNative extends HandlerInterface_1.HandlerInterface {\n    constructor() {\n        super();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Map of sending MediaStreamTracks indexed by localId.\n        this._mapSendLocalIdTrack = new Map();\n        // Next sending localId.\n        this._nextSendLocalId = 0;\n        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n        // Value is an Object with mid, rtpParameters and rtpReceiver.\n        this._mapRecvLocalIdInfo = new Map();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new ReactNative();\n    }\n    get name() {\n        return 'ReactNative';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b'\n        });\n        try {\n            const offer = await pc.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true\n            });\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            planB: true\n        });\n        this._sendingRtpParametersByKind =\n            {\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._sendingRemoteRtpParametersByKind =\n            {\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b',\n            ...additionalSettings\n        }, proprietaryConstraints);\n        // Handle RTCPeerConnection connection status.\n        this._pc.addEventListener('iceconnectionstatechange', () => {\n            switch (this._pc.iceConnectionState) {\n                case 'checking':\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                case 'connected':\n                case 'completed':\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                case 'failed':\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                case 'disconnected':\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                case 'closed':\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n            }\n        });\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady)\n            return;\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec }) {\n        this._assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (codec) {\n            logger.warn('send() | codec selection is not available in %s handler', this.name);\n        }\n        this._sendStream.addTrack(track);\n        this._pc.addStream(this._sendStream);\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        sendingRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRtpParameters.codecs);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        sendingRemoteRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n        if (track.kind === 'video' && encodings && encodings.length > 1) {\n            logger.debug('send() | enabling simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'video');\n            sdpPlanBUtils.addLegacySimulcast({\n                offerMediaObject,\n                track,\n                numStreams: encodings.length\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media\n            .find((m) => m.type === track.kind);\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname =\n            sdpCommonUtils.getCname({ offerMediaObject });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings =\n            sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx])\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n            }\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'S1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        const localId = String(this._nextSendLocalId);\n        this._nextSendLocalId++;\n        // Insert into the map.\n        this._mapSendLocalIdTrack.set(localId, track);\n        return {\n            localId: localId,\n            rtpParameters: sendingRtpParameters\n        };\n    }\n    async stopSending(localId) {\n        this._assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        const track = this._mapSendLocalIdTrack.get(localId);\n        if (!track)\n            throw new Error('track not found');\n        this._mapSendLocalIdTrack.delete(localId);\n        this._sendStream.removeTrack(track);\n        this._pc.addStream(this._sendStream);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        try {\n            await this._pc.setLocalDescription(offer);\n        }\n        catch (error) {\n            // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n            // \"Failed to create channels\". If so, ignore it.\n            if (this._sendStream.getTracks().length === 0) {\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n                return;\n            }\n            throw error;\n        }\n        if (this._pc.signalingState === 'stable')\n            return;\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    localId, track) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async setRtpEncodingParameters(localId, params) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getSenderStats(localId) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\n        this._assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n            priority\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'application');\n            if (!this._transportReady)\n                await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive({ trackId, kind, rtpParameters }) {\n        this._assertRecvDirection();\n        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n        const localId = trackId;\n        const mid = kind;\n        let streamId = rtpParameters.rtcp.cname;\n        // NOTE: In React-Native we cannot reuse the same remote MediaStream for new\n        // remote tracks. This is because react-native-webrtc does not react on new\n        // tracks generated within already existing streams, so force the streamId\n        // to be different.\n        logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');\n        streamId += `-hack-${utils.generateRandomNumber()}`;\n        this._remoteSdp.receive({\n            mid,\n            kind,\n            offerRtpParameters: rtpParameters,\n            streamId,\n            trackId\n        });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        const answerMediaObject = localSdpObject.media\n            .find((m) => String(m.mid) === mid);\n        // May need to modify codec parameters in the answer based on codec\n        // parameters in the offer.\n        sdpCommonUtils.applyCodecParameters({\n            offerRtpParameters: rtpParameters,\n            answerMediaObject\n        });\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        const stream = this._pc.getRemoteStreams()\n            .find((s) => s.id === streamId);\n        const track = stream.getTrackById(localId);\n        if (!track)\n            throw new Error('remote track not found');\n        // Insert into the map.\n        this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });\n        return { localId, track };\n    }\n    async stopReceiving(localId) {\n        this._assertRecvDirection();\n        logger.debug('stopReceiving() [localId:%s]', localId);\n        const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\n        // Remove from the map.\n        this._mapRecvLocalIdInfo.delete(localId);\n        this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getReceiverStats(localId) {\n        throw new errors_1.UnsupportedError('not implemented');\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {\n        this._assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async _setupTransport({ localDtlsRole, localSdpObject }) {\n        if (!localSdpObject)\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await this.safeEmitAsPromise('@connect', { dtlsParameters });\n        this._transportReady = true;\n    }\n    _assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    _assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.ReactNative = ReactNative;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvUmVhY3ROYXRpdmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvUmVhY3ROYXRpdmUuanM/ZWU0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBvcnRjID0gcmVxdWlyZShcIi4uL29ydGNcIik7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKTtcbmNvbnN0IHNkcFBsYW5CVXRpbHMgPSByZXF1aXJlKFwiLi9zZHAvcGxhbkJVdGlsc1wiKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdSZWFjdE5hdGl2ZScpO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDEwMjQsIE1JUzogMTAyNCB9O1xuY2xhc3MgUmVhY3ROYXRpdmUgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBNYXAgb2Ygc2VuZGluZyBNZWRpYVN0cmVhbVRyYWNrcyBpbmRleGVkIGJ5IGxvY2FsSWQuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkVHJhY2sgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE5leHQgc2VuZGluZyBsb2NhbElkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQgPSAwO1xuICAgICAgICAvLyBNYXAgb2YgTUlELCBSVFAgcGFyYW1ldGVycyBhbmQgUlRDUnRwUmVjZWl2ZXIgaW5kZXhlZCBieSBsb2NhbCBpZC5cbiAgICAgICAgLy8gVmFsdWUgaXMgYW4gT2JqZWN0IHdpdGggbWlkLCBydHBQYXJhbWV0ZXJzIGFuZCBydHBSZWNlaXZlci5cbiAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBSZWFjdE5hdGl2ZSgpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdSZWFjdE5hdGl2ZSc7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICdwbGFuLWInXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcih7XG4gICAgICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVBdWRpbzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvZmZlclRvUmVjZWl2ZVZpZGVvOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoeyBzZHBPYmplY3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogU0NUUF9OVU1fU1RSRUFNU1xuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcGxhbkI6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyB8fCBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5IHx8ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICdwbGFuLWInLFxuICAgICAgICAgICAgLi4uYWRkaXRpb25hbFNldHRpbmdzXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICAvLyBIYW5kbGUgUlRDUGVlckNvbm5lY3Rpb24gY29ubmVjdGlvbiBzdGF0dXMuXG4gICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX3BjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgdGhpcy5fcGMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNwb3J0U3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHsgdHJhY2ssIGVuY29kaW5ncywgY29kZWNPcHRpb25zLCBjb2RlYyB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgW2tpbmQ6JXMsIHRyYWNrLmlkOiVzXScsIHRyYWNrLmtpbmQsIHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgICAgICBsb2dnZXIud2Fybignc2VuZCgpIHwgY29kZWMgc2VsZWN0aW9uIGlzIG5vdCBhdmFpbGFibGUgaW4gJXMgaGFuZGxlcicsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gICAgICAgIHRoaXMuX3BjLmFkZFN0cmVhbSh0aGlzLl9zZW5kU3RyZWFtKTtcbiAgICAgICAgbGV0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbGV0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgIGxldCBvZmZlck1lZGlhT2JqZWN0O1xuICAgICAgICBjb25zdCBzZW5kaW5nUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdKTtcbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzID1cbiAgICAgICAgICAgIG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPVxuICAgICAgICAgICAgb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ3ZpZGVvJyAmJiBlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgc2ltdWxjYXN0Jyk7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAgICAgLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ3ZpZGVvJyk7XG4gICAgICAgICAgICBzZHBQbGFuQlV0aWxzLmFkZExlZ2FjeVNpbXVsY2FzdCh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICBudW1TdHJlYW1zOiBlbmNvZGluZ3MubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gdHJhY2sua2luZCk7XG4gICAgICAgIC8vIFNldCBSVENQIENOQU1FLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lID1cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmdldENuYW1lKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9XG4gICAgICAgICAgICBzZHBQbGFuQlV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QsIHRyYWNrIH0pO1xuICAgICAgICAvLyBDb21wbGV0ZSBlbmNvZGluZ3Mgd2l0aCBnaXZlbiB2YWx1ZXMuXG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nc1tpZHhdKVxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdLCBlbmNvZGluZ3NbaWR4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgVlA4IG9yIEgyNjQgYW5kIHRoZXJlIGlzIGVmZmVjdGl2ZSBzaW11bGNhc3QsIGFkZCBzY2FsYWJpbGl0eU1vZGUgdG9cbiAgICAgICAgLy8gZWFjaCBlbmNvZGluZy5cbiAgICAgICAgaWYgKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDgnIHx8XG4gICAgICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby9oMjY0JykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2Ygc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gJ1MxVDMnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYW5zd2VyUnRwUGFyYW1ldGVyczogc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBjb2RlY09wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IFN0cmluZyh0aGlzLl9uZXh0U2VuZExvY2FsSWQpO1xuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQrKztcbiAgICAgICAgLy8gSW5zZXJ0IGludG8gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRUcmFjay5zZXQobG9jYWxJZCwgdHJhY2spO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZDogbG9jYWxJZCxcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy5fbWFwU2VuZExvY2FsSWRUcmFjay5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhY2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYWNrIG5vdCBmb3VuZCcpO1xuICAgICAgICB0aGlzLl9tYXBTZW5kTG9jYWxJZFRyYWNrLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgICAgIHRoaXMuX3BjLmFkZFN0cmVhbSh0aGlzLl9zZW5kU3RyZWFtKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBJZiB0aGVyZSBhcmUgbm8gc2VuZGluZyB0cmFja3MsIHNldExvY2FsRGVzY3JpcHRpb24oKSB3aWxsIGZhaWwgd2l0aFxuICAgICAgICAgICAgLy8gXCJGYWlsZWQgdG8gY3JlYXRlIGNoYW5uZWxzXCIuIElmIHNvLCBpZ25vcmUgaXQuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2VuZFN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2Fybignc3RvcFNlbmRpbmcoKSB8IGlnbm9yaW5nIGV4cGVjdGVkIGVycm9yIGR1ZSBubyBzZW5kaW5nIHRyYWNrczogJXMnLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2soXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGxvY2FsSWQsIHRyYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIHNldE1heFNwYXRpYWxMYXllcihsb2NhbElkLCBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGxvY2FsSWQsIHBhcmFtcykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZERhdGFDaGFubmVsKHsgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCwgcHJvdG9jb2wsIHByaW9yaXR5IH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRUaW1lOiBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICBwcmlvcml0eVxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgICAgIC5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgc3RyZWFtSWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICBvcmRlcmVkOiBvcHRpb25zLm9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiBvcHRpb25zLm1heFJldHJhbnNtaXRzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKHsgdHJhY2tJZCwga2luZCwgcnRwUGFyYW1ldGVycyB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFja0lkO1xuICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICBsZXQgc3RyZWFtSWQgPSBydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWU7XG4gICAgICAgIC8vIE5PVEU6IEluIFJlYWN0LU5hdGl2ZSB3ZSBjYW5ub3QgcmV1c2UgdGhlIHNhbWUgcmVtb3RlIE1lZGlhU3RyZWFtIGZvciBuZXdcbiAgICAgICAgLy8gcmVtb3RlIHRyYWNrcy4gVGhpcyBpcyBiZWNhdXNlIHJlYWN0LW5hdGl2ZS13ZWJydGMgZG9lcyBub3QgcmVhY3Qgb24gbmV3XG4gICAgICAgIC8vIHRyYWNrcyBnZW5lcmF0ZWQgd2l0aGluIGFscmVhZHkgZXhpc3Rpbmcgc3RyZWFtcywgc28gZm9yY2UgdGhlIHN0cmVhbUlkXG4gICAgICAgIC8vIHRvIGJlIGRpZmZlcmVudC5cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBmb3JjaW5nIGEgcmFuZG9tIHJlbW90ZSBzdHJlYW1JZCB0byBhdm9pZCB3ZWxsIGtub3duIGJ1ZyBpbiByZWFjdC1uYXRpdmUtd2VicnRjJyk7XG4gICAgICAgIHN0cmVhbUlkICs9IGAtaGFjay0ke3V0aWxzLmdlbmVyYXRlUmFuZG9tTnVtYmVyKCl9YDtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmUoe1xuICAgICAgICAgICAgbWlkLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgdHJhY2tJZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IG1pZCk7XG4gICAgICAgIC8vIE1heSBuZWVkIHRvIG1vZGlmeSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBhbnN3ZXIgYmFzZWQgb24gY29kZWNcbiAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9wYy5nZXRSZW1vdGVTdHJlYW1zKClcbiAgICAgICAgICAgIC5maW5kKChzKSA9PiBzLmlkID09PSBzdHJlYW1JZCk7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gc3RyZWFtLmdldFRyYWNrQnlJZChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFjaylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3RlIHRyYWNrIG5vdCBmb3VuZCcpO1xuICAgICAgICAvLyBJbnNlcnQgaW50byB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uc2V0KGxvY2FsSWQsIHsgbWlkLCBydHBQYXJhbWV0ZXJzIH0pO1xuICAgICAgICByZXR1cm4geyBsb2NhbElkLCB0cmFjayB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgeyBtaWQsIHJ0cFBhcmFtZXRlcnMgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgfHwge307XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wbGFuQlN0b3BSZWNlaXZpbmcoeyBtaWQ6IG1pZCwgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzIH0pO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cyB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdFRpbWU6IG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oeyBvbGREYXRhQ2hhbm5lbFNwZWM6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KVxuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoeyBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgX2Fzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUmVhY3ROYXRpdmUgPSBSZWFjdE5hdGl2ZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/ReactNative.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Safari11.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Safari11.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\nconst ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\nconst sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\nconst sdpPlanBUtils = __webpack_require__(/*! ./sdp/planBUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\");\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst logger = new Logger_1.Logger('Safari11');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Safari11 extends HandlerInterface_1.HandlerInterface {\n    constructor() {\n        super();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Map of RTCRtpSender indexed by localId.\n        this._mapSendLocalIdRtpSender = new Map();\n        // Next sending localId.\n        this._nextSendLocalId = 0;\n        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n        // Value is an Object with mid, rtpParameters and rtpReceiver.\n        this._mapRecvLocalIdInfo = new Map();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Safari11();\n    }\n    get name() {\n        return 'Safari11';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b'\n        });\n        try {\n            const offer = await pc.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true\n            });\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            planB: true\n        });\n        this._sendingRtpParametersByKind =\n            {\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._sendingRemoteRtpParametersByKind =\n            {\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            ...additionalSettings\n        }, proprietaryConstraints);\n        // Handle RTCPeerConnection connection status.\n        this._pc.addEventListener('iceconnectionstatechange', () => {\n            switch (this._pc.iceConnectionState) {\n                case 'checking':\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                case 'connected':\n                case 'completed':\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                case 'failed':\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                case 'disconnected':\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                case 'closed':\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n            }\n        });\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady)\n            return;\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec }) {\n        this._assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (codec) {\n            logger.warn('send() | codec selection is not available in %s handler', this.name);\n        }\n        this._sendStream.addTrack(track);\n        this._pc.addTrack(track, this._sendStream);\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        sendingRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRtpParameters.codecs);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        sendingRemoteRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n        if (track.kind === 'video' && encodings && encodings.length > 1) {\n            logger.debug('send() | enabling simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');\n            sdpPlanBUtils.addLegacySimulcast({\n                offerMediaObject,\n                track,\n                numStreams: encodings.length\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media\n            .find((m) => m.type === track.kind);\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname =\n            sdpCommonUtils.getCname({ offerMediaObject });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings =\n            sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx])\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n            }\n        }\n        // If VP8 and there is effective simulcast, add scalabilityMode to each\n        // encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'S1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        const localId = String(this._nextSendLocalId);\n        this._nextSendLocalId++;\n        const rtpSender = this._pc.getSenders()\n            .find((s) => s.track === track);\n        // Insert into the map.\n        this._mapSendLocalIdRtpSender.set(localId, rtpSender);\n        return {\n            localId: localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender\n        };\n    }\n    async stopSending(localId) {\n        this._assertSendDirection();\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        if (rtpSender.track)\n            this._sendStream.removeTrack(rtpSender.track);\n        this._mapSendLocalIdRtpSender.delete(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        try {\n            await this._pc.setLocalDescription(offer);\n        }\n        catch (error) {\n            // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n            // \"Failed to create channels\". If so, ignore it.\n            if (this._sendStream.getTracks().length === 0) {\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n                return;\n            }\n            throw error;\n        }\n        if (this._pc.signalingState === 'stable')\n            return;\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this._assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        const oldTrack = rtpSender.track;\n        await rtpSender.replaceTrack(track);\n        // Remove the old track from the local stream.\n        if (oldTrack)\n            this._sendStream.removeTrack(oldTrack);\n        // Add the new track to the local stream.\n        if (track)\n            this._sendStream.addTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this._assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer)\n                encoding.active = true;\n            else\n                encoding.active = false;\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this._assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async getSenderStats(localId) {\n        this._assertSendDirection();\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        return rtpSender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\n        this._assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n            priority\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'application');\n            if (!this._transportReady)\n                await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive({ trackId, kind, rtpParameters }) {\n        this._assertRecvDirection();\n        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n        const localId = trackId;\n        const mid = kind;\n        this._remoteSdp.receive({\n            mid,\n            kind,\n            offerRtpParameters: rtpParameters,\n            streamId: rtpParameters.rtcp.cname,\n            trackId\n        });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        const answerMediaObject = localSdpObject.media\n            .find((m) => String(m.mid) === mid);\n        // May need to modify codec parameters in the answer based on codec\n        // parameters in the offer.\n        sdpCommonUtils.applyCodecParameters({\n            offerRtpParameters: rtpParameters,\n            answerMediaObject\n        });\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        const rtpReceiver = this._pc.getReceivers()\n            .find((r) => r.track && r.track.id === localId);\n        if (!rtpReceiver)\n            throw new Error('new RTCRtpReceiver not');\n        // Insert into the map.\n        this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters, rtpReceiver });\n        return {\n            localId,\n            track: rtpReceiver.track,\n            rtpReceiver\n        };\n    }\n    async stopReceiving(localId) {\n        this._assertRecvDirection();\n        logger.debug('stopReceiving() [localId:%s]', localId);\n        const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\n        // Remove from the map.\n        this._mapRecvLocalIdInfo.delete(localId);\n        this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this._assertRecvDirection();\n        const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};\n        if (!rtpReceiver)\n            throw new Error('associated RTCRtpReceiver not found');\n        return rtpReceiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {\n        this._assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async _setupTransport({ localDtlsRole, localSdpObject }) {\n        if (!localSdpObject)\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await this.safeEmitAsPromise('@connect', { dtlsParameters });\n        this._transportReady = true;\n    }\n    _assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    _assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Safari11 = Safari11;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvU2FmYXJpMTEuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvU2FmYXJpMTEuanM/ZmU5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBvcnRjID0gcmVxdWlyZShcIi4uL29ydGNcIik7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKTtcbmNvbnN0IHNkcFBsYW5CVXRpbHMgPSByZXF1aXJlKFwiLi9zZHAvcGxhbkJVdGlsc1wiKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdTYWZhcmkxMScpO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDEwMjQsIE1JUzogMTAyNCB9O1xuY2xhc3MgU2FmYXJpMTEgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBNYXAgb2YgUlRDUnRwU2VuZGVyIGluZGV4ZWQgYnkgbG9jYWxJZC5cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE5leHQgc2VuZGluZyBsb2NhbElkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQgPSAwO1xuICAgICAgICAvLyBNYXAgb2YgTUlELCBSVFAgcGFyYW1ldGVycyBhbmQgUlRDUnRwUmVjZWl2ZXIgaW5kZXhlZCBieSBsb2NhbCBpZC5cbiAgICAgICAgLy8gVmFsdWUgaXMgYW4gT2JqZWN0IHdpdGggbWlkLCBydHBQYXJhbWV0ZXJzIGFuZCBydHBSZWNlaXZlci5cbiAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBTYWZhcmkxMSgpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdTYWZhcmkxMSc7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICdwbGFuLWInXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcih7XG4gICAgICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVBdWRpbzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvZmZlclRvUmVjZWl2ZVZpZGVvOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoeyBzZHBPYmplY3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogU0NUUF9OVU1fU1RSRUFNU1xuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcGxhbkI6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyB8fCBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5IHx8ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsU2V0dGluZ3NcbiAgICAgICAgfSwgcHJvcHJpZXRhcnlDb25zdHJhaW50cyk7XG4gICAgICAgIC8vIEhhbmRsZSBSVENQZWVyQ29ubmVjdGlvbiBjb25uZWN0aW9uIHN0YXR1cy5cbiAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2luZyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUljZVNlcnZlcnMoaWNlU2VydmVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3VwZGF0ZUljZVNlcnZlcnMoKScpO1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5fcGMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgICBjb25maWd1cmF0aW9uLmljZVNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB0aGlzLl9wYy5zZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBhc3luYyByZXN0YXJ0SWNlKGljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcbiAgICAgICAgLy8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUljZVBhcmFtZXRlcnMoaWNlUGFyYW1ldGVycyk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09ICdzZW5kJykge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcih7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc3BvcnRTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQoeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSBba2luZDolcywgdHJhY2suaWQ6JXNdJywgdHJhY2sua2luZCwgdHJhY2suaWQpO1xuICAgICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdzZW5kKCkgfCBjb2RlYyBzZWxlY3Rpb24gaXMgbm90IGF2YWlsYWJsZSBpbiAlcyBoYW5kbGVyJywgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkVHJhY2sodHJhY2ssIHRoaXMuX3NlbmRTdHJlYW0pO1xuICAgICAgICBsZXQgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgbGV0IG9mZmVyTWVkaWFPYmplY3Q7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPVxuICAgICAgICAgICAgb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzKTtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9XG4gICAgICAgICAgICBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnc2VydmVyJywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSAndmlkZW8nICYmIGVuY29kaW5ncyAmJiBlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBlbmFibGluZyBzaW11bGNhc3QnKTtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWEuZmluZCgobSkgPT4gbS50eXBlID09PSAndmlkZW8nKTtcbiAgICAgICAgICAgIHNkcFBsYW5CVXRpbHMuYWRkTGVnYWN5U2ltdWxjYXN0KHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICAgICAgICAgIG51bVN0cmVhbXM6IGVuY29kaW5ncy5sZW5ndGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAuZmluZCgobSkgPT4gbS50eXBlID09PSB0cmFjay5raW5kKTtcbiAgICAgICAgLy8gU2V0IFJUQ1AgQ05BTUUuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUgPVxuICAgICAgICAgICAgc2RwQ29tbW9uVXRpbHMuZ2V0Q25hbWUoeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncy5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID1cbiAgICAgICAgICAgIHNkcFBsYW5CVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHsgb2ZmZXJNZWRpYU9iamVjdCwgdHJhY2sgfSk7XG4gICAgICAgIC8vIENvbXBsZXRlIGVuY29kaW5ncyB3aXRoIGdpdmVuIHZhbHVlcy5cbiAgICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RpbmdzW2lkeF0pXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0sIGVuY29kaW5nc1tpZHhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggYW5kIHRoZXJlIGlzIGVmZmVjdGl2ZSBzaW11bGNhc3QsIGFkZCBzY2FsYWJpbGl0eU1vZGUgdG8gZWFjaFxuICAgICAgICAvLyBlbmNvZGluZy5cbiAgICAgICAgaWYgKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2Ygc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gJ1MxVDMnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYW5zd2VyUnRwUGFyYW1ldGVyczogc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBjb2RlY09wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IFN0cmluZyh0aGlzLl9uZXh0U2VuZExvY2FsSWQpO1xuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQrKztcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcGMuZ2V0U2VuZGVycygpXG4gICAgICAgICAgICAuZmluZCgocykgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgICAvLyBJbnNlcnQgaW50byB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5zZXQobG9jYWxJZCwgcnRwU2VuZGVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQ6IGxvY2FsSWQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJ0cFNlbmRlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIGlmIChydHBTZW5kZXIudHJhY2spXG4gICAgICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLnJlbW92ZVRyYWNrKHJ0cFNlbmRlci50cmFjayk7XG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBJZiB0aGVyZSBhcmUgbm8gc2VuZGluZyB0cmFja3MsIHNldExvY2FsRGVzY3JpcHRpb24oKSB3aWxsIGZhaWwgd2l0aFxuICAgICAgICAgICAgLy8gXCJGYWlsZWQgdG8gY3JlYXRlIGNoYW5uZWxzXCIuIElmIHNvLCBpZ25vcmUgaXQuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2VuZFN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2Fybignc3RvcFNlbmRpbmcoKSB8IGlnbm9yaW5nIGV4cGVjdGVkIGVycm9yIGR1ZSBubyBzZW5kaW5nIHRyYWNrczogJXMnLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2sobG9jYWxJZCwgdHJhY2spIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBjb25zdCBvbGRUcmFjayA9IHJ0cFNlbmRlci50cmFjaztcbiAgICAgICAgYXdhaXQgcnRwU2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgb2xkIHRyYWNrIGZyb20gdGhlIGxvY2FsIHN0cmVhbS5cbiAgICAgICAgaWYgKG9sZFRyYWNrKVxuICAgICAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5yZW1vdmVUcmFjayhvbGRUcmFjayk7XG4gICAgICAgIC8vIEFkZCB0aGUgbmV3IHRyYWNrIHRvIHRoZSBsb2NhbCBzdHJlYW0uXG4gICAgICAgIGlmICh0cmFjaylcbiAgICAgICAgICAgIHRoaXMuX3NlbmRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuICAgIH1cbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIobG9jYWxJZCwgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSBbbG9jYWxJZDolcywgc3BhdGlhbExheWVyOiVzXScsIGxvY2FsSWQsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gcnRwU2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA8PSBzcGF0aWFsTGF5ZXIpXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSBbbG9jYWxJZDolcywgcGFyYW1zOiVvXScsIGxvY2FsSWQsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gcnRwU2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSA9IHsgLi4uZW5jb2RpbmcsIC4uLnBhcmFtcyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcnRwU2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHJ0cFNlbmRlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCwgcHJpb3JpdHkgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgIHByaW9yaXR5XG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAgICAgLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUoeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSBbdHJhY2tJZDolcywga2luZDolc10nLCB0cmFja0lkLCBraW5kKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IHRyYWNrSWQ7XG4gICAgICAgIGNvbnN0IG1pZCA9IGtpbmQ7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlKHtcbiAgICAgICAgICAgIG1pZCxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzdHJlYW1JZDogcnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgdHJhY2tJZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IG1pZCk7XG4gICAgICAgIC8vIE1heSBuZWVkIHRvIG1vZGlmeSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBhbnN3ZXIgYmFzZWQgb24gY29kZWNcbiAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBjb25zdCBydHBSZWNlaXZlciA9IHRoaXMuX3BjLmdldFJlY2VpdmVycygpXG4gICAgICAgICAgICAuZmluZCgocikgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSBsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBSZWNlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3IFJUQ1J0cFJlY2VpdmVyIG5vdCcpO1xuICAgICAgICAvLyBJbnNlcnQgaW50byB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uc2V0KGxvY2FsSWQsIHsgbWlkLCBydHBQYXJhbWV0ZXJzLCBydHBSZWNlaXZlciB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICB0cmFjazogcnRwUmVjZWl2ZXIudHJhY2ssXG4gICAgICAgICAgICBydHBSZWNlaXZlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgeyBtaWQsIHJ0cFBhcmFtZXRlcnMgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgfHwge307XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wbGFuQlN0b3BSZWNlaXZpbmcoeyBtaWQ6IG1pZCwgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzIH0pO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBydHBSZWNlaXZlciB9ID0gdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLmdldChsb2NhbElkKSB8fCB7fTtcbiAgICAgICAgaWYgKCFydHBSZWNlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBSZWNlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHJ0cFJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cyB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oeyBvbGREYXRhQ2hhbm5lbFNwZWM6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KVxuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoeyBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgX2Fzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2FmYXJpMTEgPSBTYWZhcmkxMTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/Safari11.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Safari12.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Safari12.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\nconst ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\nconst sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\nconst sdpUnifiedPlanUtils = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\");\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\nconst logger = new Logger_1.Logger('Safari12');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Safari12 extends HandlerInterface_1.HandlerInterface {\n    constructor() {\n        super();\n        // Map of RTCTransceivers indexed by MID.\n        this._mapMidTransceiver = new Map();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Safari12();\n    }\n    get name() {\n        return 'Safari12';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require'\n        });\n        try {\n            pc.addTransceiver('audio');\n            pc.addTransceiver('video');\n            const offer = await pc.createOffer();\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters\n        });\n        this._sendingRtpParametersByKind =\n            {\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._sendingRemoteRtpParametersByKind =\n            {\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._pc = new RTCPeerConnection({\n            iceServers: iceServers || [],\n            iceTransportPolicy: iceTransportPolicy || 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            ...additionalSettings\n        }, proprietaryConstraints);\n        // Handle RTCPeerConnection connection status.\n        this._pc.addEventListener('iceconnectionstatechange', () => {\n            switch (this._pc.iceConnectionState) {\n                case 'checking':\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                case 'connected':\n                case 'completed':\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                case 'failed':\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                case 'disconnected':\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                case 'closed':\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n            }\n        });\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady)\n            return;\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec }) {\n        this._assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n        // This may throw.\n        sendingRemoteRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\n        const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n        if (encodings && encodings.length > 1) {\n            logger.debug('send() | enabling legacy simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n            sdpUnifiedPlanUtils.addLegacySimulcast({\n                offerMediaObject,\n                numStreams: encodings.length\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        // We can now get the transceiver.mid.\n        const localId = transceiver.mid;\n        // Set MID.\n        sendingRtpParameters.mid = localId;\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname =\n            sdpCommonUtils.getCname({ offerMediaObject });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings =\n            sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx])\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n            }\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'S1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            reuseMid: mediaSectionIdx.reuseMid,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender: transceiver.sender\n        };\n    }\n    async stopSending(localId) {\n        this._assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        transceiver.sender.replaceTrack(null);\n        this._pc.removeTrack(transceiver.sender);\n        this._remoteSdp.closeMediaSection(transceiver.mid);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this._assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        await transceiver.sender.replaceTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this._assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer)\n                encoding.active = true;\n            else\n                encoding.active = false;\n        });\n        await transceiver.sender.setParameters(parameters);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this._assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = { ...encoding, ...params };\n        });\n        await transceiver.sender.setParameters(parameters);\n    }\n    async getSenderStats(localId) {\n        this._assertSendDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        return transceiver.sender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\n        this._assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol,\n            priority\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'application');\n            if (!this._transportReady)\n                await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive({ trackId, kind, rtpParameters }) {\n        this._assertRecvDirection();\n        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n        const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n        this._remoteSdp.receive({\n            mid: localId,\n            kind,\n            offerRtpParameters: rtpParameters,\n            streamId: rtpParameters.rtcp.cname,\n            trackId\n        });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        const answerMediaObject = localSdpObject.media\n            .find((m) => String(m.mid) === localId);\n        // May need to modify codec parameters in the answer based on codec\n        // parameters in the offer.\n        sdpCommonUtils.applyCodecParameters({\n            offerRtpParameters: rtpParameters,\n            answerMediaObject\n        });\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        const transceiver = this._pc.getTransceivers()\n            .find((t) => t.mid === localId);\n        if (!transceiver)\n            throw new Error('new RTCRtpTransceiver not found');\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            track: transceiver.receiver.track,\n            rtpReceiver: transceiver.receiver\n        };\n    }\n    async stopReceiving(localId) {\n        this._assertRecvDirection();\n        logger.debug('stopReceiving() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        this._remoteSdp.closeMediaSection(transceiver.mid);\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this._assertRecvDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        return transceiver.receiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {\n        this._assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation();\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async _setupTransport({ localDtlsRole, localSdpObject }) {\n        if (!localSdpObject)\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await this.safeEmitAsPromise('@connect', { dtlsParameters });\n        this._transportReady = true;\n    }\n    _assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    _assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Safari12 = Safari12;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvU2FmYXJpMTIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvU2FmYXJpMTIuanM/OGQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBvcnRjID0gcmVxdWlyZShcIi4uL29ydGNcIik7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKTtcbmNvbnN0IHNkcFVuaWZpZWRQbGFuVXRpbHMgPSByZXF1aXJlKFwiLi9zZHAvdW5pZmllZFBsYW5VdGlsc1wiKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdTYWZhcmkxMicpO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDEwMjQsIE1JUzogMTAyNCB9O1xuY2xhc3MgU2FmYXJpMTIgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIE1hcCBvZiBSVENUcmFuc2NlaXZlcnMgaW5kZXhlZCBieSBNSUQuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMb2NhbCBzdHJlYW0gZm9yIHNlbmRpbmcuXG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgLy8gV2hldGhlciBhIERhdGFDaGFubmVsIG09YXBwbGljYXRpb24gc2VjdGlvbiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBTZW5kaW5nIERhdGFDaGFubmVsIGlkIHZhbHVlIGNvdW50ZXIuIEluY3JlbWVudGVkIGZvciBlYWNoIG5ldyBEYXRhQ2hhbm5lbC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPSAwO1xuICAgICAgICAvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIGFuZCByZW1vdGUgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgU2FmYXJpMTIoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnU2FmYXJpMTInO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIC8vIENsb3NlIFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fcGMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICAgICAgICBwYy5hZGRUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoeyBzZHBPYmplY3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogU0NUUF9OVU1fU1RSRUFNU1xuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmQgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMgfHwgW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSB8fCAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICAgICAgLi4uYWRkaXRpb25hbFNldHRpbmdzXG4gICAgICAgIH0sIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICAvLyBIYW5kbGUgUlRDUGVlckNvbm5lY3Rpb24gY29ubmVjdGlvbiBzdGF0dXMuXG4gICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX3BjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgdGhpcy5fcGMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNwb3J0U3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHsgdHJhY2ssIGVuY29kaW5ncywgY29kZWNPcHRpb25zLCBjb2RlYyB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgW2tpbmQ6JXMsIHRyYWNrLmlkOiVzXScsIHRyYWNrLmtpbmQsIHRyYWNrLmlkKTtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1J0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSk7XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPVxuICAgICAgICAgICAgb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzLCBjb2RlYyk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0pO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzID1cbiAgICAgICAgICAgIG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25JZHggPSB0aGlzLl9yZW1vdGVTZHAuZ2V0TmV4dE1lZGlhU2VjdGlvbklkeCgpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7IGRpcmVjdGlvbjogJ3NlbmRvbmx5Jywgc3RyZWFtczogW3RoaXMuX3NlbmRTdHJlYW1dIH0pO1xuICAgICAgICBsZXQgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgbGV0IG9mZmVyTWVkaWFPYmplY3Q7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAmJiBlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBlbmFibGluZyBsZWdhY3kgc2ltdWxjYXN0Jyk7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAgICAgc2RwVW5pZmllZFBsYW5VdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogZW5jb2RpbmdzLmxlbmd0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgLy8gV2UgY2FuIG5vdyBnZXQgdGhlIHRyYW5zY2VpdmVyLm1pZC5cbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IHRyYW5zY2VpdmVyLm1pZDtcbiAgICAgICAgLy8gU2V0IE1JRC5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMubWlkID0gbG9jYWxJZDtcbiAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFbbWVkaWFTZWN0aW9uSWR4LmlkeF07XG4gICAgICAgIC8vIFNldCBSVENQIENOQU1FLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lID1cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmdldENuYW1lKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9XG4gICAgICAgICAgICBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgIC8vIENvbXBsZXRlIGVuY29kaW5ncyB3aXRoIGdpdmVuIHZhbHVlcy5cbiAgICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RpbmdzW2lkeF0pXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0sIGVuY29kaW5nc1tpZHhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggb3IgSDI2NCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0b1xuICAgICAgICAvLyBlYWNoIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIChzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcgfHxcbiAgICAgICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2gyNjQnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnUzFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIHJldXNlTWlkOiBtZWRpYVNlY3Rpb25JZHgucmV1c2VNaWQsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYW5zd2VyUnRwUGFyYW1ldGVyczogc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBjb2RlY09wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJ0cFNlbmRlcjogdHJhbnNjZWl2ZXIuc2VuZGVyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB0aGlzLl9wYy5yZW1vdmVUcmFjayh0cmFuc2NlaXZlci5zZW5kZXIpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuY2xvc2VNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIubWlkKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKGxvY2FsSWQsIHRyYWNrKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCB0cmFjay5pZDolc10nLCBsb2NhbElkLCB0cmFjay5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCBubyB0cmFja10nLCBsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgfVxuICAgIGFzeW5jIHNldE1heFNwYXRpYWxMYXllcihsb2NhbElkLCBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIFtsb2NhbElkOiVzLCBzcGF0aWFsTGF5ZXI6JXNdJywgbG9jYWxJZCwgc3BhdGlhbExheWVyKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4IDw9IHNwYXRpYWxMYXllcilcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhsb2NhbElkLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIFtsb2NhbElkOiVzLCBwYXJhbXM6JW9dJywgbG9jYWxJZCwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdID0geyAuLi5lbmNvZGluZywgLi4ucGFyYW1zIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2VuZGVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREYXRhQ2hhbm5lbCh7IG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgbGFiZWwsIHByb3RvY29sLCBwcmlvcml0eSB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgcHJpb3JpdHlcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEluY3JlYXNlIG5leHQgaWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID1cbiAgICAgICAgICAgICsrdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgJSBTQ1RQX05VTV9TVFJFQU1TLk1JUztcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBhbnN3ZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFcbiAgICAgICAgICAgICAgICAuZmluZCgobSkgPT4gbS50eXBlID09PSAnYXBwbGljYXRpb24nKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnc2VydmVyJywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmRTY3RwQXNzb2NpYXRpb24oeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3RwU3RyZWFtUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIHN0cmVhbUlkOiBvcHRpb25zLmlkLFxuICAgICAgICAgICAgb3JkZXJlZDogb3B0aW9ucy5vcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IG9wdGlvbnMubWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0czogb3B0aW9ucy5tYXhSZXRyYW5zbWl0c1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZSh7IHRyYWNrSWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIFt0cmFja0lkOiVzLCBraW5kOiVzXScsIHRyYWNrSWQsIGtpbmQpO1xuICAgICAgICBjb25zdCBsb2NhbElkID0gcnRwUGFyYW1ldGVycy5taWQgfHwgU3RyaW5nKHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNpemUpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZSh7XG4gICAgICAgICAgICBtaWQ6IGxvY2FsSWQsXG4gICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSxcbiAgICAgICAgICAgIHRyYWNrSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGxldCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgIGNvbnN0IGFuc3dlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFcbiAgICAgICAgICAgIC5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBsb2NhbElkKTtcbiAgICAgICAgLy8gTWF5IG5lZWQgdG8gbW9kaWZ5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGFuc3dlciBiYXNlZCBvbiBjb2RlY1xuICAgICAgICAvLyBwYXJhbWV0ZXJzIGluIHRoZSBvZmZlci5cbiAgICAgICAgc2RwQ29tbW9uVXRpbHMuYXBwbHlDb2RlY1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYW5zd2VyTWVkaWFPYmplY3RcbiAgICAgICAgfSk7XG4gICAgICAgIGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnY2xpZW50JywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fcGMuZ2V0VHJhbnNjZWl2ZXJzKClcbiAgICAgICAgICAgIC5maW5kKCh0KSA9PiB0Lm1pZCA9PT0gbG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25ldyBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICB0cmFjazogdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2ssXG4gICAgICAgICAgICBydHBSZWNlaXZlcjogdHJhbnNjZWl2ZXIucmVjZWl2ZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFJlY2VpdmluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuY2xvc2VNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIubWlkKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKHsgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsLCBwcm90b2NvbCB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBzdHJlYW1JZCwgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzIH0gPSBzY3RwU3RyZWFtUGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogc3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIG9mZmVyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZVNjdHBBc3NvY2lhdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdjbGllbnQnLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsIH07XG4gICAgfVxuICAgIGFzeW5jIF9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGUsIGxvY2FsU2RwT2JqZWN0IH0pIHtcbiAgICAgICAgaWYgKCFsb2NhbFNkcE9iamVjdClcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgLy8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHsgc2RwT2JqZWN0OiBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBEVExTIHJvbGUuXG4gICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSBsb2NhbER0bHNSb2xlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbW90ZSBEVExTIHJvbGUgaW4gdGhlIFNEUC5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUR0bHNSb2xlKGxvY2FsRHRsc1JvbGUgPT09ICdjbGllbnQnID8gJ3NlcnZlcicgOiAnY2xpZW50Jyk7XG4gICAgICAgIC8vIE5lZWQgdG8gdGVsbCB0aGUgcmVtb3RlIHRyYW5zcG9ydCBhYm91dCBvdXIgcGFyYW1ldGVycy5cbiAgICAgICAgYXdhaXQgdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQGNvbm5lY3QnLCB7IGR0bHNQYXJhbWV0ZXJzIH0pO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG4gICAgfVxuICAgIF9hc3NlcnRTZW5kRGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInNlbmRcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXNzZXJ0UmVjdkRpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJyZWN2XCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNhZmFyaTEyID0gU2FmYXJpMTI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/Safari12.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = __webpack_require__(/*! ../../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n/**\n * Normalize ORTC based Edge's RTCRtpReceiver.getCapabilities() to produce a full\n * compliant ORTC RTCRtpCapabilities.\n */\nfunction getCapabilities() {\n    const nativeCaps = RTCRtpReceiver.getCapabilities();\n    const caps = utils.clone(nativeCaps);\n    for (const codec of caps.codecs) {\n        // Rename numChannels to channels.\n        codec.channels = codec.numChannels;\n        delete codec.numChannels;\n        // Add mimeType.\n        codec.mimeType = codec.mimeType || `${codec.kind}/${codec.name}`;\n        // NOTE: Edge sets some numeric parameters as string rather than number. Fix them.\n        if (codec.parameters) {\n            const parameters = codec.parameters;\n            if (parameters.apt)\n                parameters.apt = Number(parameters.apt);\n            if (parameters['packetization-mode'])\n                parameters['packetization-mode'] = Number(parameters['packetization-mode']);\n        }\n        // Delete emty parameter String in rtcpFeedback.\n        for (const feedback of codec.rtcpFeedback || []) {\n            if (!feedback.parameter)\n                feedback.parameter = '';\n        }\n    }\n    return caps;\n}\nexports.getCapabilities = getCapabilities;\n/**\n * Generate RTCRtpParameters as ORTC based Edge likes.\n */\nfunction mangleRtpParameters(rtpParameters) {\n    const params = utils.clone(rtpParameters);\n    // Rename mid to muxId.\n    if (params.mid) {\n        params.muxId = params.mid;\n        delete params.mid;\n    }\n    for (const codec of params.codecs) {\n        // Rename channels to numChannels.\n        if (codec.channels) {\n            codec.numChannels = codec.channels;\n            delete codec.channels;\n        }\n        // Add codec.name (requried by Edge).\n        if (codec.mimeType && !codec.name)\n            codec.name = codec.mimeType.split('/')[1];\n        // Remove mimeType.\n        delete codec.mimeType;\n    }\n    return params;\n}\nexports.mangleRtpParameters = mangleRtpParameters;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvb3J0Yy9lZGdlVXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvb3J0Yy9lZGdlVXRpbHMuanM/MWExYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuLyoqXG4gKiBOb3JtYWxpemUgT1JUQyBiYXNlZCBFZGdlJ3MgUlRDUnRwUmVjZWl2ZXIuZ2V0Q2FwYWJpbGl0aWVzKCkgdG8gcHJvZHVjZSBhIGZ1bGxcbiAqIGNvbXBsaWFudCBPUlRDIFJUQ1J0cENhcGFiaWxpdGllcy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FwYWJpbGl0aWVzKCkge1xuICAgIGNvbnN0IG5hdGl2ZUNhcHMgPSBSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMoKTtcbiAgICBjb25zdCBjYXBzID0gdXRpbHMuY2xvbmUobmF0aXZlQ2Fwcyk7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjYXBzLmNvZGVjcykge1xuICAgICAgICAvLyBSZW5hbWUgbnVtQ2hhbm5lbHMgdG8gY2hhbm5lbHMuXG4gICAgICAgIGNvZGVjLmNoYW5uZWxzID0gY29kZWMubnVtQ2hhbm5lbHM7XG4gICAgICAgIGRlbGV0ZSBjb2RlYy5udW1DaGFubmVscztcbiAgICAgICAgLy8gQWRkIG1pbWVUeXBlLlxuICAgICAgICBjb2RlYy5taW1lVHlwZSA9IGNvZGVjLm1pbWVUeXBlIHx8IGAke2NvZGVjLmtpbmR9LyR7Y29kZWMubmFtZX1gO1xuICAgICAgICAvLyBOT1RFOiBFZGdlIHNldHMgc29tZSBudW1lcmljIHBhcmFtZXRlcnMgYXMgc3RyaW5nIHJhdGhlciB0aGFuIG51bWJlci4gRml4IHRoZW0uXG4gICAgICAgIGlmIChjb2RlYy5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gY29kZWMucGFyYW1ldGVycztcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmFwdClcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmFwdCA9IE51bWJlcihwYXJhbWV0ZXJzLmFwdCk7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyc1sncGFja2V0aXphdGlvbi1tb2RlJ10pXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyc1sncGFja2V0aXphdGlvbi1tb2RlJ10gPSBOdW1iZXIocGFyYW1ldGVyc1sncGFja2V0aXphdGlvbi1tb2RlJ10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlbGV0ZSBlbXR5IHBhcmFtZXRlciBTdHJpbmcgaW4gcnRjcEZlZWRiYWNrLlxuICAgICAgICBmb3IgKGNvbnN0IGZlZWRiYWNrIG9mIGNvZGVjLnJ0Y3BGZWVkYmFjayB8fCBbXSkge1xuICAgICAgICAgICAgaWYgKCFmZWVkYmFjay5wYXJhbWV0ZXIpXG4gICAgICAgICAgICAgICAgZmVlZGJhY2sucGFyYW1ldGVyID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhcHM7XG59XG5leHBvcnRzLmdldENhcGFiaWxpdGllcyA9IGdldENhcGFiaWxpdGllcztcbi8qKlxuICogR2VuZXJhdGUgUlRDUnRwUGFyYW1ldGVycyBhcyBPUlRDIGJhc2VkIEVkZ2UgbGlrZXMuXG4gKi9cbmZ1bmN0aW9uIG1hbmdsZVJ0cFBhcmFtZXRlcnMocnRwUGFyYW1ldGVycykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHV0aWxzLmNsb25lKHJ0cFBhcmFtZXRlcnMpO1xuICAgIC8vIFJlbmFtZSBtaWQgdG8gbXV4SWQuXG4gICAgaWYgKHBhcmFtcy5taWQpIHtcbiAgICAgICAgcGFyYW1zLm11eElkID0gcGFyYW1zLm1pZDtcbiAgICAgICAgZGVsZXRlIHBhcmFtcy5taWQ7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29kZWMgb2YgcGFyYW1zLmNvZGVjcykge1xuICAgICAgICAvLyBSZW5hbWUgY2hhbm5lbHMgdG8gbnVtQ2hhbm5lbHMuXG4gICAgICAgIGlmIChjb2RlYy5jaGFubmVscykge1xuICAgICAgICAgICAgY29kZWMubnVtQ2hhbm5lbHMgPSBjb2RlYy5jaGFubmVscztcbiAgICAgICAgICAgIGRlbGV0ZSBjb2RlYy5jaGFubmVscztcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgY29kZWMubmFtZSAocmVxdXJpZWQgYnkgRWRnZSkuXG4gICAgICAgIGlmIChjb2RlYy5taW1lVHlwZSAmJiAhY29kZWMubmFtZSlcbiAgICAgICAgICAgIGNvZGVjLm5hbWUgPSBjb2RlYy5taW1lVHlwZS5zcGxpdCgnLycpWzFdO1xuICAgICAgICAvLyBSZW1vdmUgbWltZVR5cGUuXG4gICAgICAgIGRlbGV0ZSBjb2RlYy5taW1lVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cbmV4cG9ydHMubWFuZ2xlUnRwUGFyYW1ldGVycyA9IG1hbmdsZVJ0cFBhcmFtZXRlcnM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js":
/*!************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = __webpack_require__(/*! ../../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\nclass MediaSection {\n    constructor({ iceParameters, iceCandidates, dtlsParameters, planB = false }) {\n        this._mediaObject = {};\n        this._planB = planB;\n        if (iceParameters) {\n            this.setIceParameters(iceParameters);\n        }\n        if (iceCandidates) {\n            this._mediaObject.candidates = [];\n            for (const candidate of iceCandidates) {\n                const candidateObject = {};\n                // mediasoup does mandates rtcp-mux so candidates component is always\n                // RTP (1).\n                candidateObject.component = 1;\n                candidateObject.foundation = candidate.foundation;\n                candidateObject.ip = candidate.ip;\n                candidateObject.port = candidate.port;\n                candidateObject.priority = candidate.priority;\n                candidateObject.transport = candidate.protocol;\n                candidateObject.type = candidate.type;\n                if (candidate.tcpType)\n                    candidateObject.tcptype = candidate.tcpType;\n                this._mediaObject.candidates.push(candidateObject);\n            }\n            this._mediaObject.endOfCandidates = 'end-of-candidates';\n            this._mediaObject.iceOptions = 'renomination';\n        }\n        if (dtlsParameters) {\n            this.setDtlsRole(dtlsParameters.role);\n        }\n    }\n    get mid() {\n        return String(this._mediaObject.mid);\n    }\n    get closed() {\n        return this._mediaObject.port === 0;\n    }\n    getObject() {\n        return this._mediaObject;\n    }\n    setIceParameters(iceParameters) {\n        this._mediaObject.iceUfrag = iceParameters.usernameFragment;\n        this._mediaObject.icePwd = iceParameters.password;\n    }\n    disable() {\n        this._mediaObject.direction = 'inactive';\n        delete this._mediaObject.ext;\n        delete this._mediaObject.ssrcs;\n        delete this._mediaObject.ssrcGroups;\n        delete this._mediaObject.simulcast;\n        delete this._mediaObject.simulcast_03;\n        delete this._mediaObject.rids;\n    }\n    close() {\n        this._mediaObject.direction = 'inactive';\n        this._mediaObject.port = 0;\n        delete this._mediaObject.ext;\n        delete this._mediaObject.ssrcs;\n        delete this._mediaObject.ssrcGroups;\n        delete this._mediaObject.simulcast;\n        delete this._mediaObject.simulcast_03;\n        delete this._mediaObject.rids;\n        delete this._mediaObject.extmapAllowMixed;\n    }\n}\nexports.MediaSection = MediaSection;\nclass AnswerMediaSection extends MediaSection {\n    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {\n        super({ iceParameters, iceCandidates, dtlsParameters, planB });\n        this._mediaObject.mid = String(offerMediaObject.mid);\n        this._mediaObject.type = offerMediaObject.type;\n        this._mediaObject.protocol = offerMediaObject.protocol;\n        if (!plainRtpParameters) {\n            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };\n            this._mediaObject.port = 7;\n        }\n        else {\n            this._mediaObject.connection =\n                {\n                    ip: plainRtpParameters.ip,\n                    version: plainRtpParameters.ipVersion\n                };\n            this._mediaObject.port = plainRtpParameters.port;\n        }\n        switch (offerMediaObject.type) {\n            case 'audio':\n            case 'video':\n                {\n                    this._mediaObject.direction = 'recvonly';\n                    this._mediaObject.rtp = [];\n                    this._mediaObject.rtcpFb = [];\n                    this._mediaObject.fmtp = [];\n                    for (const codec of answerRtpParameters.codecs) {\n                        const rtp = {\n                            payload: codec.payloadType,\n                            codec: getCodecName(codec),\n                            rate: codec.clockRate\n                        };\n                        if (codec.channels > 1)\n                            rtp.encoding = codec.channels;\n                        this._mediaObject.rtp.push(rtp);\n                        const codecParameters = utils.clone(codec.parameters || {});\n                        if (codecOptions) {\n                            const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusPtime, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate } = codecOptions;\n                            const offerCodec = offerRtpParameters.codecs\n                                .find((c) => (c.payloadType === codec.payloadType));\n                            switch (codec.mimeType.toLowerCase()) {\n                                case 'audio/opus':\n                                    {\n                                        if (opusStereo !== undefined) {\n                                            offerCodec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;\n                                            codecParameters.stereo = opusStereo ? 1 : 0;\n                                        }\n                                        if (opusFec !== undefined) {\n                                            offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;\n                                            codecParameters.useinbandfec = opusFec ? 1 : 0;\n                                        }\n                                        if (opusDtx !== undefined) {\n                                            offerCodec.parameters.usedtx = opusDtx ? 1 : 0;\n                                            codecParameters.usedtx = opusDtx ? 1 : 0;\n                                        }\n                                        if (opusMaxPlaybackRate !== undefined) {\n                                            codecParameters.maxplaybackrate = opusMaxPlaybackRate;\n                                        }\n                                        if (opusPtime !== undefined) {\n                                            offerCodec.parameters.ptime = opusPtime;\n                                            codecParameters.ptime = opusPtime;\n                                        }\n                                        break;\n                                    }\n                                case 'video/vp8':\n                                case 'video/vp9':\n                                case 'video/h264':\n                                case 'video/h265':\n                                    {\n                                        if (videoGoogleStartBitrate !== undefined)\n                                            codecParameters['x-google-start-bitrate'] = videoGoogleStartBitrate;\n                                        if (videoGoogleMaxBitrate !== undefined)\n                                            codecParameters['x-google-max-bitrate'] = videoGoogleMaxBitrate;\n                                        if (videoGoogleMinBitrate !== undefined)\n                                            codecParameters['x-google-min-bitrate'] = videoGoogleMinBitrate;\n                                        break;\n                                    }\n                            }\n                        }\n                        const fmtp = {\n                            payload: codec.payloadType,\n                            config: ''\n                        };\n                        for (const key of Object.keys(codecParameters)) {\n                            if (fmtp.config)\n                                fmtp.config += ';';\n                            fmtp.config += `${key}=${codecParameters[key]}`;\n                        }\n                        if (fmtp.config)\n                            this._mediaObject.fmtp.push(fmtp);\n                        for (const fb of codec.rtcpFeedback) {\n                            this._mediaObject.rtcpFb.push({\n                                payload: codec.payloadType,\n                                type: fb.type,\n                                subtype: fb.parameter\n                            });\n                        }\n                    }\n                    this._mediaObject.payloads = answerRtpParameters.codecs\n                        .map((codec) => codec.payloadType)\n                        .join(' ');\n                    this._mediaObject.ext = [];\n                    for (const ext of answerRtpParameters.headerExtensions) {\n                        // Don't add a header extension if not present in the offer.\n                        const found = (offerMediaObject.ext || [])\n                            .some((localExt) => localExt.uri === ext.uri);\n                        if (!found)\n                            continue;\n                        this._mediaObject.ext.push({\n                            uri: ext.uri,\n                            value: ext.id\n                        });\n                    }\n                    // Allow both 1 byte and 2 bytes length header extensions.\n                    if (extmapAllowMixed &&\n                        offerMediaObject.extmapAllowMixed === 'extmap-allow-mixed') {\n                        this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';\n                    }\n                    // Simulcast.\n                    if (offerMediaObject.simulcast) {\n                        this._mediaObject.simulcast =\n                            {\n                                dir1: 'recv',\n                                list1: offerMediaObject.simulcast.list1\n                            };\n                        this._mediaObject.rids = [];\n                        for (const rid of offerMediaObject.rids || []) {\n                            if (rid.direction !== 'send')\n                                continue;\n                            this._mediaObject.rids.push({\n                                id: rid.id,\n                                direction: 'recv'\n                            });\n                        }\n                    }\n                    // Simulcast (draft version 03).\n                    else if (offerMediaObject.simulcast_03) {\n                        // eslint-disable-next-line camelcase\n                        this._mediaObject.simulcast_03 =\n                            {\n                                value: offerMediaObject.simulcast_03.value.replace(/send/g, 'recv')\n                            };\n                        this._mediaObject.rids = [];\n                        for (const rid of offerMediaObject.rids || []) {\n                            if (rid.direction !== 'send')\n                                continue;\n                            this._mediaObject.rids.push({\n                                id: rid.id,\n                                direction: 'recv'\n                            });\n                        }\n                    }\n                    this._mediaObject.rtcpMux = 'rtcp-mux';\n                    this._mediaObject.rtcpRsize = 'rtcp-rsize';\n                    if (this._planB && this._mediaObject.type === 'video')\n                        this._mediaObject.xGoogleFlag = 'conference';\n                    break;\n                }\n            case 'application':\n                {\n                    // New spec.\n                    if (typeof offerMediaObject.sctpPort === 'number') {\n                        this._mediaObject.payloads = 'webrtc-datachannel';\n                        this._mediaObject.sctpPort = sctpParameters.port;\n                        this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;\n                    }\n                    // Old spec.\n                    else if (offerMediaObject.sctpmap) {\n                        this._mediaObject.payloads = sctpParameters.port;\n                        this._mediaObject.sctpmap =\n                            {\n                                app: 'webrtc-datachannel',\n                                sctpmapNumber: sctpParameters.port,\n                                maxMessageSize: sctpParameters.maxMessageSize\n                            };\n                    }\n                    break;\n                }\n        }\n    }\n    setDtlsRole(role) {\n        switch (role) {\n            case 'client':\n                this._mediaObject.setup = 'active';\n                break;\n            case 'server':\n                this._mediaObject.setup = 'passive';\n                break;\n            case 'auto':\n                this._mediaObject.setup = 'actpass';\n                break;\n        }\n    }\n}\nexports.AnswerMediaSection = AnswerMediaSection;\nclass OfferMediaSection extends MediaSection {\n    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, mid, kind, offerRtpParameters, streamId, trackId, oldDataChannelSpec = false }) {\n        super({ iceParameters, iceCandidates, dtlsParameters, planB });\n        this._mediaObject.mid = String(mid);\n        this._mediaObject.type = kind;\n        if (!plainRtpParameters) {\n            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };\n            if (!sctpParameters)\n                this._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF';\n            else\n                this._mediaObject.protocol = 'UDP/DTLS/SCTP';\n            this._mediaObject.port = 7;\n        }\n        else {\n            this._mediaObject.connection =\n                {\n                    ip: plainRtpParameters.ip,\n                    version: plainRtpParameters.ipVersion\n                };\n            this._mediaObject.protocol = 'RTP/AVP';\n            this._mediaObject.port = plainRtpParameters.port;\n        }\n        switch (kind) {\n            case 'audio':\n            case 'video':\n                {\n                    this._mediaObject.direction = 'sendonly';\n                    this._mediaObject.rtp = [];\n                    this._mediaObject.rtcpFb = [];\n                    this._mediaObject.fmtp = [];\n                    if (!this._planB)\n                        this._mediaObject.msid = `${streamId || '-'} ${trackId}`;\n                    for (const codec of offerRtpParameters.codecs) {\n                        const rtp = {\n                            payload: codec.payloadType,\n                            codec: getCodecName(codec),\n                            rate: codec.clockRate\n                        };\n                        if (codec.channels > 1)\n                            rtp.encoding = codec.channels;\n                        this._mediaObject.rtp.push(rtp);\n                        const fmtp = {\n                            payload: codec.payloadType,\n                            config: ''\n                        };\n                        for (const key of Object.keys(codec.parameters)) {\n                            if (fmtp.config)\n                                fmtp.config += ';';\n                            fmtp.config += `${key}=${codec.parameters[key]}`;\n                        }\n                        if (fmtp.config)\n                            this._mediaObject.fmtp.push(fmtp);\n                        for (const fb of codec.rtcpFeedback) {\n                            this._mediaObject.rtcpFb.push({\n                                payload: codec.payloadType,\n                                type: fb.type,\n                                subtype: fb.parameter\n                            });\n                        }\n                    }\n                    this._mediaObject.payloads = offerRtpParameters.codecs\n                        .map((codec) => codec.payloadType)\n                        .join(' ');\n                    this._mediaObject.ext = [];\n                    for (const ext of offerRtpParameters.headerExtensions) {\n                        this._mediaObject.ext.push({\n                            uri: ext.uri,\n                            value: ext.id\n                        });\n                    }\n                    this._mediaObject.rtcpMux = 'rtcp-mux';\n                    this._mediaObject.rtcpRsize = 'rtcp-rsize';\n                    const encoding = offerRtpParameters.encodings[0];\n                    const ssrc = encoding.ssrc;\n                    const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)\n                        ? encoding.rtx.ssrc\n                        : undefined;\n                    this._mediaObject.ssrcs = [];\n                    this._mediaObject.ssrcGroups = [];\n                    if (offerRtpParameters.rtcp.cname) {\n                        this._mediaObject.ssrcs.push({\n                            id: ssrc,\n                            attribute: 'cname',\n                            value: offerRtpParameters.rtcp.cname\n                        });\n                    }\n                    if (this._planB) {\n                        this._mediaObject.ssrcs.push({\n                            id: ssrc,\n                            attribute: 'msid',\n                            value: `${streamId || '-'} ${trackId}`\n                        });\n                    }\n                    if (rtxSsrc) {\n                        if (offerRtpParameters.rtcp.cname) {\n                            this._mediaObject.ssrcs.push({\n                                id: rtxSsrc,\n                                attribute: 'cname',\n                                value: offerRtpParameters.rtcp.cname\n                            });\n                        }\n                        if (this._planB) {\n                            this._mediaObject.ssrcs.push({\n                                id: rtxSsrc,\n                                attribute: 'msid',\n                                value: `${streamId || '-'} ${trackId}`\n                            });\n                        }\n                        // Associate original and retransmission SSRCs.\n                        this._mediaObject.ssrcGroups.push({\n                            semantics: 'FID',\n                            ssrcs: `${ssrc} ${rtxSsrc}`\n                        });\n                    }\n                    break;\n                }\n            case 'application':\n                {\n                    // New spec.\n                    if (!oldDataChannelSpec) {\n                        this._mediaObject.payloads = 'webrtc-datachannel';\n                        this._mediaObject.sctpPort = sctpParameters.port;\n                        this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;\n                    }\n                    // Old spec.\n                    else {\n                        this._mediaObject.payloads = sctpParameters.port;\n                        this._mediaObject.sctpmap =\n                            {\n                                app: 'webrtc-datachannel',\n                                sctpmapNumber: sctpParameters.port,\n                                maxMessageSize: sctpParameters.maxMessageSize\n                            };\n                    }\n                    break;\n                }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setDtlsRole(role) {\n        // Always 'actpass'.\n        this._mediaObject.setup = 'actpass';\n    }\n    planBReceive({ offerRtpParameters, streamId, trackId }) {\n        const encoding = offerRtpParameters.encodings[0];\n        const ssrc = encoding.ssrc;\n        const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)\n            ? encoding.rtx.ssrc\n            : undefined;\n        if (offerRtpParameters.rtcp.cname) {\n            this._mediaObject.ssrcs.push({\n                id: ssrc,\n                attribute: 'cname',\n                value: offerRtpParameters.rtcp.cname\n            });\n        }\n        this._mediaObject.ssrcs.push({\n            id: ssrc,\n            attribute: 'msid',\n            value: `${streamId || '-'} ${trackId}`\n        });\n        if (rtxSsrc) {\n            if (offerRtpParameters.rtcp.cname) {\n                this._mediaObject.ssrcs.push({\n                    id: rtxSsrc,\n                    attribute: 'cname',\n                    value: offerRtpParameters.rtcp.cname\n                });\n            }\n            this._mediaObject.ssrcs.push({\n                id: rtxSsrc,\n                attribute: 'msid',\n                value: `${streamId || '-'} ${trackId}`\n            });\n            // Associate original and retransmission SSRCs.\n            this._mediaObject.ssrcGroups.push({\n                semantics: 'FID',\n                ssrcs: `${ssrc} ${rtxSsrc}`\n            });\n        }\n    }\n    planBStopReceiving({ offerRtpParameters }) {\n        const encoding = offerRtpParameters.encodings[0];\n        const ssrc = encoding.ssrc;\n        const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)\n            ? encoding.rtx.ssrc\n            : undefined;\n        this._mediaObject.ssrcs = this._mediaObject.ssrcs\n            .filter((s) => s.id !== ssrc && s.id !== rtxSsrc);\n        if (rtxSsrc) {\n            this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups\n                .filter((group) => group.ssrcs !== `${ssrc} ${rtxSsrc}`);\n        }\n    }\n}\nexports.OfferMediaSection = OfferMediaSection;\nfunction getCodecName(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch)\n        throw new TypeError('invalid codec.mimeType');\n    return mimeTypeMatch[2];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvc2RwL01lZGlhU2VjdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3J4X3NvY2tldGlvX2NsaWVudC8uL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9zZHAvTWVkaWFTZWN0aW9uLmpzPzQ3YmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNsYXNzIE1lZGlhU2VjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoeyBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgcGxhbkIgPSBmYWxzZSB9KSB7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0ID0ge307XG4gICAgICAgIHRoaXMuX3BsYW5CID0gcGxhbkI7XG4gICAgICAgIGlmIChpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnNldEljZVBhcmFtZXRlcnMoaWNlUGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGljZUNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGljZUNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5kaWRhdGVPYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICAvLyBtZWRpYXNvdXAgZG9lcyBtYW5kYXRlcyBydGNwLW11eCBzbyBjYW5kaWRhdGVzIGNvbXBvbmVudCBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICAvLyBSVFAgKDEpLlxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU9iamVjdC5jb21wb25lbnQgPSAxO1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU9iamVjdC5mb3VuZGF0aW9uID0gY2FuZGlkYXRlLmZvdW5kYXRpb247XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlT2JqZWN0LmlwID0gY2FuZGlkYXRlLmlwO1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU9iamVjdC5wb3J0ID0gY2FuZGlkYXRlLnBvcnQ7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlT2JqZWN0LnByaW9yaXR5ID0gY2FuZGlkYXRlLnByaW9yaXR5O1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU9iamVjdC50cmFuc3BvcnQgPSBjYW5kaWRhdGUucHJvdG9jb2w7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlT2JqZWN0LnR5cGUgPSBjYW5kaWRhdGUudHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlLnRjcFR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU9iamVjdC50Y3B0eXBlID0gY2FuZGlkYXRlLnRjcFR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuY2FuZGlkYXRlcy5wdXNoKGNhbmRpZGF0ZU9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5lbmRPZkNhbmRpZGF0ZXMgPSAnZW5kLW9mLWNhbmRpZGF0ZXMnO1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuaWNlT3B0aW9ucyA9ICdyZW5vbWluYXRpb24nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkdGxzUGFyYW1ldGVycykge1xuICAgICAgICAgICAgdGhpcy5zZXREdGxzUm9sZShkdGxzUGFyYW1ldGVycy5yb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbWlkKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMuX21lZGlhT2JqZWN0Lm1pZCk7XG4gICAgfVxuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYU9iamVjdC5wb3J0ID09PSAwO1xuICAgIH1cbiAgICBnZXRPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYU9iamVjdDtcbiAgICB9XG4gICAgc2V0SWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmljZVVmcmFnID0gaWNlUGFyYW1ldGVycy51c2VybmFtZUZyYWdtZW50O1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5pY2VQd2QgPSBpY2VQYXJhbWV0ZXJzLnBhc3N3b3JkO1xuICAgIH1cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICBkZWxldGUgdGhpcy5fbWVkaWFPYmplY3QuZXh0O1xuICAgICAgICBkZWxldGUgdGhpcy5fbWVkaWFPYmplY3Quc3NyY3M7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5zc3JjR3JvdXBzO1xuICAgICAgICBkZWxldGUgdGhpcy5fbWVkaWFPYmplY3Quc2ltdWxjYXN0O1xuICAgICAgICBkZWxldGUgdGhpcy5fbWVkaWFPYmplY3Quc2ltdWxjYXN0XzAzO1xuICAgICAgICBkZWxldGUgdGhpcy5fbWVkaWFPYmplY3QucmlkcztcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBvcnQgPSAwO1xuICAgICAgICBkZWxldGUgdGhpcy5fbWVkaWFPYmplY3QuZXh0O1xuICAgICAgICBkZWxldGUgdGhpcy5fbWVkaWFPYmplY3Quc3NyY3M7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5zc3JjR3JvdXBzO1xuICAgICAgICBkZWxldGUgdGhpcy5fbWVkaWFPYmplY3Quc2ltdWxjYXN0O1xuICAgICAgICBkZWxldGUgdGhpcy5fbWVkaWFPYmplY3Quc2ltdWxjYXN0XzAzO1xuICAgICAgICBkZWxldGUgdGhpcy5fbWVkaWFPYmplY3QucmlkcztcbiAgICAgICAgZGVsZXRlIHRoaXMuX21lZGlhT2JqZWN0LmV4dG1hcEFsbG93TWl4ZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5NZWRpYVNlY3Rpb24gPSBNZWRpYVNlY3Rpb247XG5jbGFzcyBBbnN3ZXJNZWRpYVNlY3Rpb24gZXh0ZW5kcyBNZWRpYVNlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHsgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBwbGFpblJ0cFBhcmFtZXRlcnMsIHBsYW5CID0gZmFsc2UsIG9mZmVyTWVkaWFPYmplY3QsIG9mZmVyUnRwUGFyYW1ldGVycywgYW5zd2VyUnRwUGFyYW1ldGVycywgY29kZWNPcHRpb25zLCBleHRtYXBBbGxvd01peGVkID0gZmFsc2UgfSkge1xuICAgICAgICBzdXBlcih7IGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBwbGFuQiB9KTtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QubWlkID0gU3RyaW5nKG9mZmVyTWVkaWFPYmplY3QubWlkKTtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QudHlwZSA9IG9mZmVyTWVkaWFPYmplY3QudHlwZTtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucHJvdG9jb2wgPSBvZmZlck1lZGlhT2JqZWN0LnByb3RvY29sO1xuICAgICAgICBpZiAoIXBsYWluUnRwUGFyYW1ldGVycykge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuY29ubmVjdGlvbiA9IHsgaXA6ICcxMjcuMC4wLjEnLCB2ZXJzaW9uOiA0IH07XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wb3J0ID0gNztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmNvbm5lY3Rpb24gPVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaXA6IHBsYWluUnRwUGFyYW1ldGVycy5pcCxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogcGxhaW5SdHBQYXJhbWV0ZXJzLmlwVmVyc2lvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wb3J0ID0gcGxhaW5SdHBQYXJhbWV0ZXJzLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChvZmZlck1lZGlhT2JqZWN0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmRpcmVjdGlvbiA9ICdyZWN2b25seSc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0cCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5ydGNwRmIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZm10cCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGFuc3dlclJ0cFBhcmFtZXRlcnMuY29kZWNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBydHAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWM6IGdldENvZGVjTmFtZShjb2RlYyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0ZTogY29kZWMuY2xvY2tSYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVjLmNoYW5uZWxzID4gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydHAuZW5jb2RpbmcgPSBjb2RlYy5jaGFubmVscztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0cC5wdXNoKHJ0cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlY1BhcmFtZXRlcnMgPSB1dGlscy5jbG9uZShjb2RlYy5wYXJhbWV0ZXJzIHx8IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlY09wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9wdXNTdGVyZW8sIG9wdXNGZWMsIG9wdXNEdHgsIG9wdXNNYXhQbGF5YmFja1JhdGUsIG9wdXNQdGltZSwgdmlkZW9Hb29nbGVTdGFydEJpdHJhdGUsIHZpZGVvR29vZ2xlTWF4Qml0cmF0ZSwgdmlkZW9Hb29nbGVNaW5CaXRyYXRlIH0gPSBjb2RlY09wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2ZmZXJDb2RlYyA9IG9mZmVyUnRwUGFyYW1ldGVycy5jb2RlY3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoKGMpID0+IChjLnBheWxvYWRUeXBlID09PSBjb2RlYy5wYXlsb2FkVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZWMubWltZVR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhdWRpby9vcHVzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c1N0ZXJlbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZmVyQ29kZWMucGFyYW1ldGVyc1snc3Byb3Atc3RlcmVvJ10gPSBvcHVzU3RlcmVvID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVycy5zdGVyZW8gPSBvcHVzU3RlcmVvID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHVzRmVjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZmZXJDb2RlYy5wYXJhbWV0ZXJzLnVzZWluYmFuZGZlYyA9IG9wdXNGZWMgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNQYXJhbWV0ZXJzLnVzZWluYmFuZGZlYyA9IG9wdXNGZWMgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdXNEdHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZlckNvZGVjLnBhcmFtZXRlcnMudXNlZHR4ID0gb3B1c0R0eCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlY1BhcmFtZXRlcnMudXNlZHR4ID0gb3B1c0R0eCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c01heFBsYXliYWNrUmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVycy5tYXhwbGF5YmFja3JhdGUgPSBvcHVzTWF4UGxheWJhY2tSYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c1B0aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZmZXJDb2RlYy5wYXJhbWV0ZXJzLnB0aW1lID0gb3B1c1B0aW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlY1BhcmFtZXRlcnMucHRpbWUgPSBvcHVzUHRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2aWRlby92cDgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2aWRlby92cDknOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2aWRlby9oMjY0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndmlkZW8vaDI2NSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpZGVvR29vZ2xlU3RhcnRCaXRyYXRlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVyc1sneC1nb29nbGUtc3RhcnQtYml0cmF0ZSddID0gdmlkZW9Hb29nbGVTdGFydEJpdHJhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpZGVvR29vZ2xlTWF4Qml0cmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlY1BhcmFtZXRlcnNbJ3gtZ29vZ2xlLW1heC1iaXRyYXRlJ10gPSB2aWRlb0dvb2dsZU1heEJpdHJhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpZGVvR29vZ2xlTWluQml0cmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlY1BhcmFtZXRlcnNbJ3gtZ29vZ2xlLW1pbi1iaXRyYXRlJ10gPSB2aWRlb0dvb2dsZU1pbkJpdHJhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm10cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29kZWNQYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbXRwLmNvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10cC5jb25maWcgKz0gJzsnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IGAke2tleX09JHtjb2RlY1BhcmFtZXRlcnNba2V5XX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZtdHAuY29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmZtdHAucHVzaChmbXRwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmIgb2YgY29kZWMucnRjcEZlZWRiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRjcEZiLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZmIudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZTogZmIucGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucGF5bG9hZHMgPSBhbnN3ZXJSdHBQYXJhbWV0ZXJzLmNvZGVjc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoY29kZWMpID0+IGNvZGVjLnBheWxvYWRUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZXh0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXh0IG9mIGFuc3dlclJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIGEgaGVhZGVyIGV4dGVuc2lvbiBpZiBub3QgcHJlc2VudCBpbiB0aGUgb2ZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IChvZmZlck1lZGlhT2JqZWN0LmV4dCB8fCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29tZSgobG9jYWxFeHQpID0+IGxvY2FsRXh0LnVyaSA9PT0gZXh0LnVyaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZXh0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVyaTogZXh0LnVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXh0LmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBib3RoIDEgYnl0ZSBhbmQgMiBieXRlcyBsZW5ndGggaGVhZGVyIGV4dGVuc2lvbnMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRtYXBBbGxvd01peGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LmV4dG1hcEFsbG93TWl4ZWQgPT09ICdleHRtYXAtYWxsb3ctbWl4ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5leHRtYXBBbGxvd01peGVkID0gJ2V4dG1hcC1hbGxvdy1taXhlZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2ltdWxjYXN0LlxuICAgICAgICAgICAgICAgICAgICBpZiAob2ZmZXJNZWRpYU9iamVjdC5zaW11bGNhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNpbXVsY2FzdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXIxOiAncmVjdicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QxOiBvZmZlck1lZGlhT2JqZWN0LnNpbXVsY2FzdC5saXN0MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5yaWRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJpZCBvZiBvZmZlck1lZGlhT2JqZWN0LnJpZHMgfHwgW10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlkLmRpcmVjdGlvbiAhPT0gJ3NlbmQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5yaWRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcmlkLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbXVsY2FzdCAoZHJhZnQgdmVyc2lvbiAwMykuXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9mZmVyTWVkaWFPYmplY3Quc2ltdWxjYXN0XzAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zaW11bGNhc3RfMDMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9mZmVyTWVkaWFPYmplY3Quc2ltdWxjYXN0XzAzLnZhbHVlLnJlcGxhY2UoL3NlbmQvZywgJ3JlY3YnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5yaWRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJpZCBvZiBvZmZlck1lZGlhT2JqZWN0LnJpZHMgfHwgW10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlkLmRpcmVjdGlvbiAhPT0gJ3NlbmQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5yaWRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcmlkLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BNdXggPSAncnRjcC1tdXgnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5ydGNwUnNpemUgPSAncnRjcC1yc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wbGFuQiAmJiB0aGlzLl9tZWRpYU9iamVjdC50eXBlID09PSAndmlkZW8nKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QueEdvb2dsZUZsYWcgPSAnY29uZmVyZW5jZSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBzcGVjLlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZmVyTWVkaWFPYmplY3Quc2N0cFBvcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wYXlsb2FkcyA9ICd3ZWJydGMtZGF0YWNoYW5uZWwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2N0cFBvcnQgPSBzY3RwUGFyYW1ldGVycy5wb3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QubWF4TWVzc2FnZVNpemUgPSBzY3RwUGFyYW1ldGVycy5tYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBPbGQgc3BlYy5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2ZmZXJNZWRpYU9iamVjdC5zY3RwbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wYXlsb2FkcyA9IHNjdHBQYXJhbWV0ZXJzLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zY3RwbWFwID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcDogJ3dlYnJ0Yy1kYXRhY2hhbm5lbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjdHBtYXBOdW1iZXI6IHNjdHBQYXJhbWV0ZXJzLnBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VTaXplOiBzY3RwUGFyYW1ldGVycy5tYXhNZXNzYWdlU2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldER0bHNSb2xlKHJvbGUpIHtcbiAgICAgICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICAgICAgICBjYXNlICdjbGllbnQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNldHVwID0gJ2FjdGl2ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZXJ2ZXInOlxuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNldHVwID0gJ3Bhc3NpdmUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXV0byc6XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2V0dXAgPSAnYWN0cGFzcyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFuc3dlck1lZGlhU2VjdGlvbiA9IEFuc3dlck1lZGlhU2VjdGlvbjtcbmNsYXNzIE9mZmVyTWVkaWFTZWN0aW9uIGV4dGVuZHMgTWVkaWFTZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgcGxhaW5SdHBQYXJhbWV0ZXJzLCBwbGFuQiA9IGZhbHNlLCBtaWQsIGtpbmQsIG9mZmVyUnRwUGFyYW1ldGVycywgc3RyZWFtSWQsIHRyYWNrSWQsIG9sZERhdGFDaGFubmVsU3BlYyA9IGZhbHNlIH0pIHtcbiAgICAgICAgc3VwZXIoeyBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgcGxhbkIgfSk7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0Lm1pZCA9IFN0cmluZyhtaWQpO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC50eXBlID0ga2luZDtcbiAgICAgICAgaWYgKCFwbGFpblJ0cFBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmNvbm5lY3Rpb24gPSB7IGlwOiAnMTI3LjAuMC4xJywgdmVyc2lvbjogNCB9O1xuICAgICAgICAgICAgaWYgKCFzY3RwUGFyYW1ldGVycylcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wcm90b2NvbCA9ICdVRFAvVExTL1JUUC9TQVZQRic7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucHJvdG9jb2wgPSAnVURQL0RUTFMvU0NUUCc7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wb3J0ID0gNztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmNvbm5lY3Rpb24gPVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaXA6IHBsYWluUnRwUGFyYW1ldGVycy5pcCxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogcGxhaW5SdHBQYXJhbWV0ZXJzLmlwVmVyc2lvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wcm90b2NvbCA9ICdSVFAvQVZQJztcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBvcnQgPSBwbGFpblJ0cFBhcmFtZXRlcnMucG9ydDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0cCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5ydGNwRmIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZm10cCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BsYW5CKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QubXNpZCA9IGAke3N0cmVhbUlkIHx8ICctJ30gJHt0cmFja0lkfWA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29kZWMgb2Ygb2ZmZXJSdHBQYXJhbWV0ZXJzLmNvZGVjcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnRwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjOiBnZXRDb2RlY05hbWUoY29kZWMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGU6IGNvZGVjLmNsb2NrUmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlYy5jaGFubmVscyA+IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnRwLmVuY29kaW5nID0gY29kZWMuY2hhbm5lbHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5ydHAucHVzaChydHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm10cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm10cC5jb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9ICc7JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBgJHtrZXl9PSR7Y29kZWMucGFyYW1ldGVyc1trZXldfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm10cC5jb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZm10cC5wdXNoKGZtdHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmYiBvZiBjb2RlYy5ydGNwRmVlZGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5ydGNwRmIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBmYi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlOiBmYi5wYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wYXlsb2FkcyA9IG9mZmVyUnRwUGFyYW1ldGVycy5jb2RlY3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGNvZGVjKSA9PiBjb2RlYy5wYXlsb2FkVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmV4dCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV4dCBvZiBvZmZlclJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZXh0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVyaTogZXh0LnVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXh0LmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5ydGNwTXV4ID0gJ3J0Y3AtbXV4JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRjcFJzaXplID0gJ3J0Y3AtcnNpemUnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGluZyA9IG9mZmVyUnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNzcmMgPSBlbmNvZGluZy5zc3JjO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBydHhTc3JjID0gKGVuY29kaW5nLnJ0eCAmJiBlbmNvZGluZy5ydHguc3NyYylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZW5jb2RpbmcucnR4LnNzcmNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3JjcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3JjR3JvdXBzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZlclJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNzcmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiAnY25hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvZmZlclJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BsYW5CKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogc3NyYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6ICdtc2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYCR7c3RyZWFtSWQgfHwgJy0nfSAke3RyYWNrSWR9YFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ0eFNzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZlclJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcnR4U3NyYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiAnY25hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb2ZmZXJSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wbGFuQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcnR4U3NyYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiAnbXNpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZCB8fCAnLSd9ICR7dHJhY2tJZH1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NvY2lhdGUgb3JpZ2luYWwgYW5kIHJldHJhbnNtaXNzaW9uIFNTUkNzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY0dyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW1hbnRpY3M6ICdGSUQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNzcmNzOiBgJHtzc3JjfSAke3J0eFNzcmN9YFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYXBwbGljYXRpb24nOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IHNwZWMuXG4gICAgICAgICAgICAgICAgICAgIGlmICghb2xkRGF0YUNoYW5uZWxTcGVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wYXlsb2FkcyA9ICd3ZWJydGMtZGF0YWNoYW5uZWwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2N0cFBvcnQgPSBzY3RwUGFyYW1ldGVycy5wb3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QubWF4TWVzc2FnZVNpemUgPSBzY3RwUGFyYW1ldGVycy5tYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBPbGQgc3BlYy5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wYXlsb2FkcyA9IHNjdHBQYXJhbWV0ZXJzLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zY3RwbWFwID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcDogJ3dlYnJ0Yy1kYXRhY2hhbm5lbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjdHBtYXBOdW1iZXI6IHNjdHBQYXJhbWV0ZXJzLnBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VTaXplOiBzY3RwUGFyYW1ldGVycy5tYXhNZXNzYWdlU2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBzZXREdGxzUm9sZShyb2xlKSB7XG4gICAgICAgIC8vIEFsd2F5cyAnYWN0cGFzcycuXG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNldHVwID0gJ2FjdHBhc3MnO1xuICAgIH1cbiAgICBwbGFuQlJlY2VpdmUoeyBvZmZlclJ0cFBhcmFtZXRlcnMsIHN0cmVhbUlkLCB0cmFja0lkIH0pIHtcbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBvZmZlclJ0cFBhcmFtZXRlcnMuZW5jb2RpbmdzWzBdO1xuICAgICAgICBjb25zdCBzc3JjID0gZW5jb2Rpbmcuc3NyYztcbiAgICAgICAgY29uc3QgcnR4U3NyYyA9IChlbmNvZGluZy5ydHggJiYgZW5jb2RpbmcucnR4LnNzcmMpXG4gICAgICAgICAgICA/IGVuY29kaW5nLnJ0eC5zc3JjXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogc3NyYyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBzc3JjLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnbXNpZCcsXG4gICAgICAgICAgICB2YWx1ZTogYCR7c3RyZWFtSWQgfHwgJy0nfSAke3RyYWNrSWR9YFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJ0eFNzcmMpIHtcbiAgICAgICAgICAgIGlmIChvZmZlclJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogcnR4U3NyYyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiAnY25hbWUnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb2ZmZXJSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBydHhTc3JjLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogJ21zaWQnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZCB8fCAnLSd9ICR7dHJhY2tJZH1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFzc29jaWF0ZSBvcmlnaW5hbCBhbmQgcmV0cmFuc21pc3Npb24gU1NSQ3MuXG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3JjR3JvdXBzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlbWFudGljczogJ0ZJRCcsXG4gICAgICAgICAgICAgICAgc3NyY3M6IGAke3NzcmN9ICR7cnR4U3NyY31gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwbGFuQlN0b3BSZWNlaXZpbmcoeyBvZmZlclJ0cFBhcmFtZXRlcnMgfSkge1xuICAgICAgICBjb25zdCBlbmNvZGluZyA9IG9mZmVyUnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbMF07XG4gICAgICAgIGNvbnN0IHNzcmMgPSBlbmNvZGluZy5zc3JjO1xuICAgICAgICBjb25zdCBydHhTc3JjID0gKGVuY29kaW5nLnJ0eCAmJiBlbmNvZGluZy5ydHguc3NyYylcbiAgICAgICAgICAgID8gZW5jb2RpbmcucnR4LnNzcmNcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3JjcyA9IHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzXG4gICAgICAgICAgICAuZmlsdGVyKChzKSA9PiBzLmlkICE9PSBzc3JjICYmIHMuaWQgIT09IHJ0eFNzcmMpO1xuICAgICAgICBpZiAocnR4U3NyYykge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY0dyb3VwcyA9IHRoaXMuX21lZGlhT2JqZWN0LnNzcmNHcm91cHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChncm91cCkgPT4gZ3JvdXAuc3NyY3MgIT09IGAke3NzcmN9ICR7cnR4U3NyY31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuT2ZmZXJNZWRpYVNlY3Rpb24gPSBPZmZlck1lZGlhU2VjdGlvbjtcbmZ1bmN0aW9uIGdldENvZGVjTmFtZShjb2RlYykge1xuICAgIGNvbnN0IE1pbWVUeXBlUmVnZXggPSBuZXcgUmVnRXhwKCdeKGF1ZGlvfHZpZGVvKS8oLispJywgJ2knKTtcbiAgICBjb25zdCBtaW1lVHlwZU1hdGNoID0gTWltZVR5cGVSZWdleC5leGVjKGNvZGVjLm1pbWVUeXBlKTtcbiAgICBpZiAoIW1pbWVUeXBlTWF0Y2gpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY29kZWMubWltZVR5cGUnKTtcbiAgICByZXR1cm4gbWltZVR5cGVNYXRjaFsyXTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nconst Logger_1 = __webpack_require__(/*! ../../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\nconst MediaSection_1 = __webpack_require__(/*! ./MediaSection */ \"./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js\");\nconst logger = new Logger_1.Logger('RemoteSdp');\nclass RemoteSdp {\n    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false }) {\n        // MediaSection instances.\n        this._mediaSections = [];\n        // MediaSection indices indexed by MID.\n        this._midToIndex = new Map();\n        this._iceParameters = iceParameters;\n        this._iceCandidates = iceCandidates;\n        this._dtlsParameters = dtlsParameters;\n        this._sctpParameters = sctpParameters;\n        this._plainRtpParameters = plainRtpParameters;\n        this._planB = planB;\n        this._sdpObject =\n            {\n                version: 0,\n                origin: {\n                    address: '0.0.0.0',\n                    ipVer: 4,\n                    netType: 'IN',\n                    sessionId: 10000,\n                    sessionVersion: 0,\n                    username: 'mediasoup-client'\n                },\n                name: '-',\n                timing: { start: 0, stop: 0 },\n                media: []\n            };\n        // If ICE parameters are given, add ICE-Lite indicator.\n        if (iceParameters && iceParameters.iceLite) {\n            this._sdpObject.icelite = 'ice-lite';\n        }\n        // If DTLS parameters are given, assume WebRTC and BUNDLE.\n        if (dtlsParameters) {\n            this._sdpObject.msidSemantic = { semantic: 'WMS', token: '*' };\n            // NOTE: We take the latest fingerprint.\n            const numFingerprints = this._dtlsParameters.fingerprints.length;\n            this._sdpObject.fingerprint =\n                {\n                    type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,\n                    hash: dtlsParameters.fingerprints[numFingerprints - 1].value\n                };\n            this._sdpObject.groups = [{ type: 'BUNDLE', mids: '' }];\n        }\n        // If there are plain RPT parameters, override SDP origin.\n        if (plainRtpParameters) {\n            this._sdpObject.origin.address = plainRtpParameters.ip;\n            this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;\n        }\n    }\n    updateIceParameters(iceParameters) {\n        logger.debug('updateIceParameters() [iceParameters:%o]', iceParameters);\n        this._iceParameters = iceParameters;\n        this._sdpObject.icelite = iceParameters.iceLite ? 'ice-lite' : undefined;\n        for (const mediaSection of this._mediaSections) {\n            mediaSection.setIceParameters(iceParameters);\n        }\n    }\n    updateDtlsRole(role) {\n        logger.debug('updateDtlsRole() [role:%s]', role);\n        this._dtlsParameters.role = role;\n        for (const mediaSection of this._mediaSections) {\n            mediaSection.setDtlsRole(role);\n        }\n    }\n    getNextMediaSectionIdx() {\n        // If a closed media section is found, return its index.\n        for (let idx = 0; idx < this._mediaSections.length; ++idx) {\n            const mediaSection = this._mediaSections[idx];\n            if (mediaSection.closed)\n                return { idx, reuseMid: mediaSection.mid };\n        }\n        // If no closed media section is found, return next one.\n        return { idx: this._mediaSections.length };\n    }\n    send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {\n        const mediaSection = new MediaSection_1.AnswerMediaSection({\n            iceParameters: this._iceParameters,\n            iceCandidates: this._iceCandidates,\n            dtlsParameters: this._dtlsParameters,\n            plainRtpParameters: this._plainRtpParameters,\n            planB: this._planB,\n            offerMediaObject,\n            offerRtpParameters,\n            answerRtpParameters,\n            codecOptions,\n            extmapAllowMixed\n        });\n        // Unified-Plan with closed media section replacement.\n        if (reuseMid) {\n            this._replaceMediaSection(mediaSection, reuseMid);\n        }\n        // Unified-Plan or Plan-B with different media kind.\n        else if (!this._midToIndex.has(mediaSection.mid)) {\n            this._addMediaSection(mediaSection);\n        }\n        // Plan-B with same media kind.\n        else {\n            this._replaceMediaSection(mediaSection);\n        }\n    }\n    receive({ mid, kind, offerRtpParameters, streamId, trackId }) {\n        const idx = this._midToIndex.get(mid);\n        let mediaSection;\n        if (idx !== undefined)\n            mediaSection = this._mediaSections[idx];\n        // Unified-Plan or different media kind.\n        if (!mediaSection) {\n            mediaSection = new MediaSection_1.OfferMediaSection({\n                iceParameters: this._iceParameters,\n                iceCandidates: this._iceCandidates,\n                dtlsParameters: this._dtlsParameters,\n                plainRtpParameters: this._plainRtpParameters,\n                planB: this._planB,\n                mid,\n                kind,\n                offerRtpParameters,\n                streamId,\n                trackId\n            });\n            this._addMediaSection(mediaSection);\n        }\n        // Plan-B.\n        else {\n            mediaSection.planBReceive({ offerRtpParameters, streamId, trackId });\n            this._replaceMediaSection(mediaSection);\n        }\n    }\n    disableMediaSection(mid) {\n        const idx = this._midToIndex.get(mid);\n        if (idx === undefined) {\n            throw new Error(`no media section found with mid '${mid}'`);\n        }\n        const mediaSection = this._mediaSections[idx];\n        mediaSection.disable();\n    }\n    closeMediaSection(mid) {\n        const idx = this._midToIndex.get(mid);\n        if (idx === undefined) {\n            throw new Error(`no media section found with mid '${mid}'`);\n        }\n        const mediaSection = this._mediaSections[idx];\n        // NOTE: Closing the first m section is a pain since it invalidates the\n        // bundled transport, so let's avoid it.\n        if (mid === this._firstMid) {\n            logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', mid);\n            this.disableMediaSection(mid);\n            return;\n        }\n        mediaSection.close();\n        // Regenerate BUNDLE mids.\n        this._regenerateBundleMids();\n    }\n    planBStopReceiving({ mid, offerRtpParameters }) {\n        const idx = this._midToIndex.get(mid);\n        if (idx === undefined) {\n            throw new Error(`no media section found with mid '${mid}'`);\n        }\n        const mediaSection = this._mediaSections[idx];\n        mediaSection.planBStopReceiving({ offerRtpParameters });\n        this._replaceMediaSection(mediaSection);\n    }\n    sendSctpAssociation({ offerMediaObject }) {\n        const mediaSection = new MediaSection_1.AnswerMediaSection({\n            iceParameters: this._iceParameters,\n            iceCandidates: this._iceCandidates,\n            dtlsParameters: this._dtlsParameters,\n            sctpParameters: this._sctpParameters,\n            plainRtpParameters: this._plainRtpParameters,\n            offerMediaObject\n        });\n        this._addMediaSection(mediaSection);\n    }\n    receiveSctpAssociation({ oldDataChannelSpec = false } = {}) {\n        const mediaSection = new MediaSection_1.OfferMediaSection({\n            iceParameters: this._iceParameters,\n            iceCandidates: this._iceCandidates,\n            dtlsParameters: this._dtlsParameters,\n            sctpParameters: this._sctpParameters,\n            plainRtpParameters: this._plainRtpParameters,\n            mid: 'datachannel',\n            kind: 'application',\n            oldDataChannelSpec\n        });\n        this._addMediaSection(mediaSection);\n    }\n    getSdp() {\n        // Increase SDP version.\n        this._sdpObject.origin.sessionVersion++;\n        return sdpTransform.write(this._sdpObject);\n    }\n    _addMediaSection(newMediaSection) {\n        if (!this._firstMid)\n            this._firstMid = newMediaSection.mid;\n        // Add to the vector.\n        this._mediaSections.push(newMediaSection);\n        // Add to the map.\n        this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);\n        // Add to the SDP object.\n        this._sdpObject.media.push(newMediaSection.getObject());\n        // Regenerate BUNDLE mids.\n        this._regenerateBundleMids();\n    }\n    _replaceMediaSection(newMediaSection, reuseMid) {\n        // Store it in the map.\n        if (typeof reuseMid === 'string') {\n            const idx = this._midToIndex.get(reuseMid);\n            if (idx === undefined) {\n                throw new Error(`no media section found for reuseMid '${reuseMid}'`);\n            }\n            const oldMediaSection = this._mediaSections[idx];\n            // Replace the index in the vector with the new media section.\n            this._mediaSections[idx] = newMediaSection;\n            // Update the map.\n            this._midToIndex.delete(oldMediaSection.mid);\n            this._midToIndex.set(newMediaSection.mid, idx);\n            // Update the SDP object.\n            this._sdpObject.media[idx] = newMediaSection.getObject();\n            // Regenerate BUNDLE mids.\n            this._regenerateBundleMids();\n        }\n        else {\n            const idx = this._midToIndex.get(newMediaSection.mid);\n            if (idx === undefined) {\n                throw new Error(`no media section found with mid '${newMediaSection.mid}'`);\n            }\n            // Replace the index in the vector with the new media section.\n            this._mediaSections[idx] = newMediaSection;\n            // Update the SDP object.\n            this._sdpObject.media[idx] = newMediaSection.getObject();\n        }\n    }\n    _regenerateBundleMids() {\n        if (!this._dtlsParameters)\n            return;\n        this._sdpObject.groups[0].mids = this._mediaSections\n            .filter((mediaSection) => !mediaSection.closed)\n            .map((mediaSection) => mediaSection.mid)\n            .join(' ');\n    }\n}\nexports.RemoteSdp = RemoteSdp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvc2RwL1JlbW90ZVNkcC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3J4X3NvY2tldGlvX2NsaWVudC8uL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9zZHAvUmVtb3RlU2RwLmpzPzE5ZjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBzZHBUcmFuc2Zvcm0gPSByZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uLy4uL0xvZ2dlclwiKTtcbmNvbnN0IE1lZGlhU2VjdGlvbl8xID0gcmVxdWlyZShcIi4vTWVkaWFTZWN0aW9uXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignUmVtb3RlU2RwJyk7XG5jbGFzcyBSZW1vdGVTZHAge1xuICAgIGNvbnN0cnVjdG9yKHsgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBwbGFpblJ0cFBhcmFtZXRlcnMsIHBsYW5CID0gZmFsc2UgfSkge1xuICAgICAgICAvLyBNZWRpYVNlY3Rpb24gaW5zdGFuY2VzLlxuICAgICAgICB0aGlzLl9tZWRpYVNlY3Rpb25zID0gW107XG4gICAgICAgIC8vIE1lZGlhU2VjdGlvbiBpbmRpY2VzIGluZGV4ZWQgYnkgTUlELlxuICAgICAgICB0aGlzLl9taWRUb0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9pY2VQYXJhbWV0ZXJzID0gaWNlUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5faWNlQ2FuZGlkYXRlcyA9IGljZUNhbmRpZGF0ZXM7XG4gICAgICAgIHRoaXMuX2R0bHNQYXJhbWV0ZXJzID0gZHRsc1BhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuX3NjdHBQYXJhbWV0ZXJzID0gc2N0cFBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuX3BsYWluUnRwUGFyYW1ldGVycyA9IHBsYWluUnRwUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fcGxhbkIgPSBwbGFuQjtcbiAgICAgICAgdGhpcy5fc2RwT2JqZWN0ID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICAgICAgICAgIG9yaWdpbjoge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiAnMC4wLjAuMCcsXG4gICAgICAgICAgICAgICAgICAgIGlwVmVyOiA0LFxuICAgICAgICAgICAgICAgICAgICBuZXRUeXBlOiAnSU4nLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IDEwMDAwLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uVmVyc2lvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6ICdtZWRpYXNvdXAtY2xpZW50J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmFtZTogJy0nLFxuICAgICAgICAgICAgICAgIHRpbWluZzogeyBzdGFydDogMCwgc3RvcDogMCB9LFxuICAgICAgICAgICAgICAgIG1lZGlhOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgSUNFIHBhcmFtZXRlcnMgYXJlIGdpdmVuLCBhZGQgSUNFLUxpdGUgaW5kaWNhdG9yLlxuICAgICAgICBpZiAoaWNlUGFyYW1ldGVycyAmJiBpY2VQYXJhbWV0ZXJzLmljZUxpdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NkcE9iamVjdC5pY2VsaXRlID0gJ2ljZS1saXRlJztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBEVExTIHBhcmFtZXRlcnMgYXJlIGdpdmVuLCBhc3N1bWUgV2ViUlRDIGFuZCBCVU5ETEUuXG4gICAgICAgIGlmIChkdGxzUGFyYW1ldGVycykge1xuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm1zaWRTZW1hbnRpYyA9IHsgc2VtYW50aWM6ICdXTVMnLCB0b2tlbjogJyonIH07XG4gICAgICAgICAgICAvLyBOT1RFOiBXZSB0YWtlIHRoZSBsYXRlc3QgZmluZ2VycHJpbnQuXG4gICAgICAgICAgICBjb25zdCBudW1GaW5nZXJwcmludHMgPSB0aGlzLl9kdGxzUGFyYW1ldGVycy5maW5nZXJwcmludHMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0LmZpbmdlcnByaW50ID1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50c1tudW1GaW5nZXJwcmludHMgLSAxXS5hbGdvcml0aG0sXG4gICAgICAgICAgICAgICAgICAgIGhhc2g6IGR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50c1tudW1GaW5nZXJwcmludHMgLSAxXS52YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9zZHBPYmplY3QuZ3JvdXBzID0gW3sgdHlwZTogJ0JVTkRMRScsIG1pZHM6ICcnIH1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBwbGFpbiBSUFQgcGFyYW1ldGVycywgb3ZlcnJpZGUgU0RQIG9yaWdpbi5cbiAgICAgICAgaWYgKHBsYWluUnRwUGFyYW1ldGVycykge1xuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm9yaWdpbi5hZGRyZXNzID0gcGxhaW5SdHBQYXJhbWV0ZXJzLmlwO1xuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm9yaWdpbi5pcFZlciA9IHBsYWluUnRwUGFyYW1ldGVycy5pcFZlcnNpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlUGFyYW1ldGVycygpIFtpY2VQYXJhbWV0ZXJzOiVvXScsIGljZVBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9pY2VQYXJhbWV0ZXJzID0gaWNlUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fc2RwT2JqZWN0LmljZWxpdGUgPSBpY2VQYXJhbWV0ZXJzLmljZUxpdGUgPyAnaWNlLWxpdGUnIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IG1lZGlhU2VjdGlvbiBvZiB0aGlzLl9tZWRpYVNlY3Rpb25zKSB7XG4gICAgICAgICAgICBtZWRpYVNlY3Rpb24uc2V0SWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVEdGxzUm9sZShyb2xlKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlRHRsc1JvbGUoKSBbcm9sZTolc10nLCByb2xlKTtcbiAgICAgICAgdGhpcy5fZHRsc1BhcmFtZXRlcnMucm9sZSA9IHJvbGU7XG4gICAgICAgIGZvciAoY29uc3QgbWVkaWFTZWN0aW9uIG9mIHRoaXMuX21lZGlhU2VjdGlvbnMpIHtcbiAgICAgICAgICAgIG1lZGlhU2VjdGlvbi5zZXREdGxzUm9sZShyb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXROZXh0TWVkaWFTZWN0aW9uSWR4KCkge1xuICAgICAgICAvLyBJZiBhIGNsb3NlZCBtZWRpYSBzZWN0aW9uIGlzIGZvdW5kLCByZXR1cm4gaXRzIGluZGV4LlxuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLl9tZWRpYVNlY3Rpb25zLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbiA9IHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XTtcbiAgICAgICAgICAgIGlmIChtZWRpYVNlY3Rpb24uY2xvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGlkeCwgcmV1c2VNaWQ6IG1lZGlhU2VjdGlvbi5taWQgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBjbG9zZWQgbWVkaWEgc2VjdGlvbiBpcyBmb3VuZCwgcmV0dXJuIG5leHQgb25lLlxuICAgICAgICByZXR1cm4geyBpZHg6IHRoaXMuX21lZGlhU2VjdGlvbnMubGVuZ3RoIH07XG4gICAgfVxuICAgIHNlbmQoeyBvZmZlck1lZGlhT2JqZWN0LCByZXVzZU1pZCwgb2ZmZXJSdHBQYXJhbWV0ZXJzLCBhbnN3ZXJSdHBQYXJhbWV0ZXJzLCBjb2RlY09wdGlvbnMsIGV4dG1hcEFsbG93TWl4ZWQgPSBmYWxzZSB9KSB7XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbiA9IG5ldyBNZWRpYVNlY3Rpb25fMS5BbnN3ZXJNZWRpYVNlY3Rpb24oe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVyczogdGhpcy5faWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXM6IHRoaXMuX2ljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogdGhpcy5fZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBwbGFpblJ0cFBhcmFtZXRlcnM6IHRoaXMuX3BsYWluUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHBsYW5COiB0aGlzLl9wbGFuQixcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29kZWNPcHRpb25zLFxuICAgICAgICAgICAgZXh0bWFwQWxsb3dNaXhlZFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVW5pZmllZC1QbGFuIHdpdGggY2xvc2VkIG1lZGlhIHNlY3Rpb24gcmVwbGFjZW1lbnQuXG4gICAgICAgIGlmIChyZXVzZU1pZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwbGFjZU1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24sIHJldXNlTWlkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVbmlmaWVkLVBsYW4gb3IgUGxhbi1CIHdpdGggZGlmZmVyZW50IG1lZGlhIGtpbmQuXG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9taWRUb0luZGV4LmhhcyhtZWRpYVNlY3Rpb24ubWlkKSkge1xuICAgICAgICAgICAgdGhpcy5fYWRkTWVkaWFTZWN0aW9uKG1lZGlhU2VjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGxhbi1CIHdpdGggc2FtZSBtZWRpYSBraW5kLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWNlaXZlKHsgbWlkLCBraW5kLCBvZmZlclJ0cFBhcmFtZXRlcnMsIHN0cmVhbUlkLCB0cmFja0lkIH0pIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fbWlkVG9JbmRleC5nZXQobWlkKTtcbiAgICAgICAgbGV0IG1lZGlhU2VjdGlvbjtcbiAgICAgICAgaWYgKGlkeCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgbWVkaWFTZWN0aW9uID0gdGhpcy5fbWVkaWFTZWN0aW9uc1tpZHhdO1xuICAgICAgICAvLyBVbmlmaWVkLVBsYW4gb3IgZGlmZmVyZW50IG1lZGlhIGtpbmQuXG4gICAgICAgIGlmICghbWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBtZWRpYVNlY3Rpb24gPSBuZXcgTWVkaWFTZWN0aW9uXzEuT2ZmZXJNZWRpYVNlY3Rpb24oe1xuICAgICAgICAgICAgICAgIGljZVBhcmFtZXRlcnM6IHRoaXMuX2ljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgaWNlQ2FuZGlkYXRlczogdGhpcy5faWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogdGhpcy5fZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcGxhaW5SdHBQYXJhbWV0ZXJzOiB0aGlzLl9wbGFpblJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcGxhbkI6IHRoaXMuX3BsYW5CLFxuICAgICAgICAgICAgICAgIG1pZCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgICB0cmFja0lkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBsYW4tQi5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZWRpYVNlY3Rpb24ucGxhbkJSZWNlaXZlKHsgb2ZmZXJSdHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCwgdHJhY2tJZCB9KTtcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNhYmxlTWVkaWFTZWN0aW9uKG1pZCkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9taWRUb0luZGV4LmdldChtaWQpO1xuICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gbWVkaWEgc2VjdGlvbiBmb3VuZCB3aXRoIG1pZCAnJHttaWR9J2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbiA9IHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XTtcbiAgICAgICAgbWVkaWFTZWN0aW9uLmRpc2FibGUoKTtcbiAgICB9XG4gICAgY2xvc2VNZWRpYVNlY3Rpb24obWlkKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX21pZFRvSW5kZXguZ2V0KG1pZCk7XG4gICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBtZWRpYSBzZWN0aW9uIGZvdW5kIHdpdGggbWlkICcke21pZH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uID0gdGhpcy5fbWVkaWFTZWN0aW9uc1tpZHhdO1xuICAgICAgICAvLyBOT1RFOiBDbG9zaW5nIHRoZSBmaXJzdCBtIHNlY3Rpb24gaXMgYSBwYWluIHNpbmNlIGl0IGludmFsaWRhdGVzIHRoZVxuICAgICAgICAvLyBidW5kbGVkIHRyYW5zcG9ydCwgc28gbGV0J3MgYXZvaWQgaXQuXG4gICAgICAgIGlmIChtaWQgPT09IHRoaXMuX2ZpcnN0TWlkKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlTWVkaWFTZWN0aW9uKCkgfCBjYW5ub3QgY2xvc2UgZmlyc3QgbWVkaWEgc2VjdGlvbiwgZGlzYWJsaW5nIGl0IGluc3RlYWQgW21pZDolc10nLCBtaWQpO1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlTWVkaWFTZWN0aW9uKG1pZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWVkaWFTZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgIC8vIFJlZ2VuZXJhdGUgQlVORExFIG1pZHMuXG4gICAgICAgIHRoaXMuX3JlZ2VuZXJhdGVCdW5kbGVNaWRzKCk7XG4gICAgfVxuICAgIHBsYW5CU3RvcFJlY2VpdmluZyh7IG1pZCwgb2ZmZXJSdHBQYXJhbWV0ZXJzIH0pIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fbWlkVG9JbmRleC5nZXQobWlkKTtcbiAgICAgICAgaWYgKGlkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIG1lZGlhIHNlY3Rpb24gZm91bmQgd2l0aCBtaWQgJyR7bWlkfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb24gPSB0aGlzLl9tZWRpYVNlY3Rpb25zW2lkeF07XG4gICAgICAgIG1lZGlhU2VjdGlvbi5wbGFuQlN0b3BSZWNlaXZpbmcoeyBvZmZlclJ0cFBhcmFtZXRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICB9XG4gICAgc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSkge1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb24gPSBuZXcgTWVkaWFTZWN0aW9uXzEuQW5zd2VyTWVkaWFTZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnM6IHRoaXMuX2ljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzOiB0aGlzLl9pY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnM6IHRoaXMuX2R0bHNQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2N0cFBhcmFtZXRlcnM6IHRoaXMuX3NjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcGxhaW5SdHBQYXJhbWV0ZXJzOiB0aGlzLl9wbGFpblJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hZGRNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICB9XG4gICAgcmVjZWl2ZVNjdHBBc3NvY2lhdGlvbih7IG9sZERhdGFDaGFubmVsU3BlYyA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb24gPSBuZXcgTWVkaWFTZWN0aW9uXzEuT2ZmZXJNZWRpYVNlY3Rpb24oe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVyczogdGhpcy5faWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXM6IHRoaXMuX2ljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogdGhpcy5fZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVyczogdGhpcy5fc2N0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBwbGFpblJ0cFBhcmFtZXRlcnM6IHRoaXMuX3BsYWluUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIG1pZDogJ2RhdGFjaGFubmVsJyxcbiAgICAgICAgICAgIGtpbmQ6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgICAgICBvbGREYXRhQ2hhbm5lbFNwZWNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2FkZE1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24pO1xuICAgIH1cbiAgICBnZXRTZHAoKSB7XG4gICAgICAgIC8vIEluY3JlYXNlIFNEUCB2ZXJzaW9uLlxuICAgICAgICB0aGlzLl9zZHBPYmplY3Qub3JpZ2luLnNlc3Npb25WZXJzaW9uKys7XG4gICAgICAgIHJldHVybiBzZHBUcmFuc2Zvcm0ud3JpdGUodGhpcy5fc2RwT2JqZWN0KTtcbiAgICB9XG4gICAgX2FkZE1lZGlhU2VjdGlvbihuZXdNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maXJzdE1pZClcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0TWlkID0gbmV3TWVkaWFTZWN0aW9uLm1pZDtcbiAgICAgICAgLy8gQWRkIHRvIHRoZSB2ZWN0b3IuXG4gICAgICAgIHRoaXMuX21lZGlhU2VjdGlvbnMucHVzaChuZXdNZWRpYVNlY3Rpb24pO1xuICAgICAgICAvLyBBZGQgdG8gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWlkVG9JbmRleC5zZXQobmV3TWVkaWFTZWN0aW9uLm1pZCwgdGhpcy5fbWVkaWFTZWN0aW9ucy5sZW5ndGggLSAxKTtcbiAgICAgICAgLy8gQWRkIHRvIHRoZSBTRFAgb2JqZWN0LlxuICAgICAgICB0aGlzLl9zZHBPYmplY3QubWVkaWEucHVzaChuZXdNZWRpYVNlY3Rpb24uZ2V0T2JqZWN0KCkpO1xuICAgICAgICAvLyBSZWdlbmVyYXRlIEJVTkRMRSBtaWRzLlxuICAgICAgICB0aGlzLl9yZWdlbmVyYXRlQnVuZGxlTWlkcygpO1xuICAgIH1cbiAgICBfcmVwbGFjZU1lZGlhU2VjdGlvbihuZXdNZWRpYVNlY3Rpb24sIHJldXNlTWlkKSB7XG4gICAgICAgIC8vIFN0b3JlIGl0IGluIHRoZSBtYXAuXG4gICAgICAgIGlmICh0eXBlb2YgcmV1c2VNaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9taWRUb0luZGV4LmdldChyZXVzZU1pZCk7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIG1lZGlhIHNlY3Rpb24gZm91bmQgZm9yIHJldXNlTWlkICcke3JldXNlTWlkfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9sZE1lZGlhU2VjdGlvbiA9IHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XTtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGluZGV4IGluIHRoZSB2ZWN0b3Igd2l0aCB0aGUgbmV3IG1lZGlhIHNlY3Rpb24uXG4gICAgICAgICAgICB0aGlzLl9tZWRpYVNlY3Rpb25zW2lkeF0gPSBuZXdNZWRpYVNlY3Rpb247XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX21pZFRvSW5kZXguZGVsZXRlKG9sZE1lZGlhU2VjdGlvbi5taWQpO1xuICAgICAgICAgICAgdGhpcy5fbWlkVG9JbmRleC5zZXQobmV3TWVkaWFTZWN0aW9uLm1pZCwgaWR4KTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgU0RQIG9iamVjdC5cbiAgICAgICAgICAgIHRoaXMuX3NkcE9iamVjdC5tZWRpYVtpZHhdID0gbmV3TWVkaWFTZWN0aW9uLmdldE9iamVjdCgpO1xuICAgICAgICAgICAgLy8gUmVnZW5lcmF0ZSBCVU5ETEUgbWlkcy5cbiAgICAgICAgICAgIHRoaXMuX3JlZ2VuZXJhdGVCdW5kbGVNaWRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9taWRUb0luZGV4LmdldChuZXdNZWRpYVNlY3Rpb24ubWlkKTtcbiAgICAgICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gbWVkaWEgc2VjdGlvbiBmb3VuZCB3aXRoIG1pZCAnJHtuZXdNZWRpYVNlY3Rpb24ubWlkfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGluZGV4IGluIHRoZSB2ZWN0b3Igd2l0aCB0aGUgbmV3IG1lZGlhIHNlY3Rpb24uXG4gICAgICAgICAgICB0aGlzLl9tZWRpYVNlY3Rpb25zW2lkeF0gPSBuZXdNZWRpYVNlY3Rpb247XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIFNEUCBvYmplY3QuXG4gICAgICAgICAgICB0aGlzLl9zZHBPYmplY3QubWVkaWFbaWR4XSA9IG5ld01lZGlhU2VjdGlvbi5nZXRPYmplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVnZW5lcmF0ZUJ1bmRsZU1pZHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZHRsc1BhcmFtZXRlcnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3NkcE9iamVjdC5ncm91cHNbMF0ubWlkcyA9IHRoaXMuX21lZGlhU2VjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoKG1lZGlhU2VjdGlvbikgPT4gIW1lZGlhU2VjdGlvbi5jbG9zZWQpXG4gICAgICAgICAgICAubWFwKChtZWRpYVNlY3Rpb24pID0+IG1lZGlhU2VjdGlvbi5taWQpXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVtb3RlU2RwID0gUmVtb3RlU2RwO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nfunction extractRtpCapabilities({ sdpObject }) {\n    // Map of RtpCodecParameters indexed by payload type.\n    const codecsMap = new Map();\n    // Array of RtpHeaderExtensions.\n    const headerExtensions = [];\n    // Whether a m=audio/video section has been already found.\n    let gotAudio = false;\n    let gotVideo = false;\n    for (const m of sdpObject.media) {\n        const kind = m.type;\n        switch (kind) {\n            case 'audio':\n                {\n                    if (gotAudio)\n                        continue;\n                    gotAudio = true;\n                    break;\n                }\n            case 'video':\n                {\n                    if (gotVideo)\n                        continue;\n                    gotVideo = true;\n                    break;\n                }\n            default:\n                {\n                    continue;\n                }\n        }\n        // Get codecs.\n        for (const rtp of m.rtp) {\n            const codec = {\n                kind: kind,\n                mimeType: `${kind}/${rtp.codec}`,\n                preferredPayloadType: rtp.payload,\n                clockRate: rtp.rate,\n                channels: rtp.encoding,\n                parameters: {},\n                rtcpFeedback: []\n            };\n            codecsMap.set(codec.preferredPayloadType, codec);\n        }\n        // Get codec parameters.\n        for (const fmtp of m.fmtp || []) {\n            const parameters = sdpTransform.parseParams(fmtp.config);\n            const codec = codecsMap.get(fmtp.payload);\n            if (!codec)\n                continue;\n            // Specials case to convert parameter value to string.\n            if (parameters && parameters['profile-level-id'])\n                parameters['profile-level-id'] = String(parameters['profile-level-id']);\n            codec.parameters = parameters;\n        }\n        // Get RTCP feedback for each codec.\n        for (const fb of m.rtcpFb || []) {\n            const codec = codecsMap.get(fb.payload);\n            if (!codec)\n                continue;\n            const feedback = {\n                type: fb.type,\n                parameter: fb.subtype\n            };\n            if (!feedback.parameter)\n                delete feedback.parameter;\n            codec.rtcpFeedback.push(feedback);\n        }\n        // Get RTP header extensions.\n        for (const ext of m.ext || []) {\n            // Ignore encrypted extensions (not yet supported in mediasoup).\n            if (ext['encrypt-uri'])\n                continue;\n            const headerExtension = {\n                kind: kind,\n                uri: ext.uri,\n                preferredId: ext.value\n            };\n            headerExtensions.push(headerExtension);\n        }\n    }\n    const rtpCapabilities = {\n        codecs: Array.from(codecsMap.values()),\n        headerExtensions: headerExtensions\n    };\n    return rtpCapabilities;\n}\nexports.extractRtpCapabilities = extractRtpCapabilities;\nfunction extractDtlsParameters({ sdpObject }) {\n    const mediaObject = (sdpObject.media || [])\n        .find((m) => (m.iceUfrag && m.port !== 0));\n    if (!mediaObject)\n        throw new Error('no active media section found');\n    const fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;\n    let role;\n    switch (mediaObject.setup) {\n        case 'active':\n            role = 'client';\n            break;\n        case 'passive':\n            role = 'server';\n            break;\n        case 'actpass':\n            role = 'auto';\n            break;\n    }\n    const dtlsParameters = {\n        role,\n        fingerprints: [\n            {\n                algorithm: fingerprint.type,\n                value: fingerprint.hash\n            }\n        ]\n    };\n    return dtlsParameters;\n}\nexports.extractDtlsParameters = extractDtlsParameters;\nfunction getCname({ offerMediaObject }) {\n    const ssrcCnameLine = (offerMediaObject.ssrcs || [])\n        .find((line) => line.attribute === 'cname');\n    if (!ssrcCnameLine)\n        return '';\n    return ssrcCnameLine.value;\n}\nexports.getCname = getCname;\n/**\n * Apply codec parameters in the given SDP m= section answer based on the\n * given RTP parameters of an offer.\n */\nfunction applyCodecParameters({ offerRtpParameters, answerMediaObject }) {\n    for (const codec of offerRtpParameters.codecs) {\n        const mimeType = codec.mimeType.toLowerCase();\n        // Avoid parsing codec parameters for unhandled codecs.\n        if (mimeType !== 'audio/opus')\n            continue;\n        const rtp = (answerMediaObject.rtp || [])\n            .find((r) => r.payload === codec.payloadType);\n        if (!rtp)\n            continue;\n        // Just in case.\n        answerMediaObject.fmtp = answerMediaObject.fmtp || [];\n        let fmtp = answerMediaObject.fmtp\n            .find((f) => f.payload === codec.payloadType);\n        if (!fmtp) {\n            fmtp = { payload: codec.payloadType, config: '' };\n            answerMediaObject.fmtp.push(fmtp);\n        }\n        const parameters = sdpTransform.parseParams(fmtp.config);\n        switch (mimeType) {\n            case 'audio/opus':\n                {\n                    const spropStereo = codec.parameters['sprop-stereo'];\n                    if (spropStereo !== undefined)\n                        parameters.stereo = spropStereo ? 1 : 0;\n                    break;\n                }\n        }\n        // Write the codec fmtp.config back.\n        fmtp.config = '';\n        for (const key of Object.keys(parameters)) {\n            if (fmtp.config)\n                fmtp.config += ';';\n            fmtp.config += `${key}=${parameters[key]}`;\n        }\n    }\n}\nexports.applyCodecParameters = applyCodecParameters;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvc2RwL2NvbW1vblV0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC9jb21tb25VdGlscy5qcz82MzAzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc2RwVHJhbnNmb3JtID0gcmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIik7XG5mdW5jdGlvbiBleHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHsgc2RwT2JqZWN0IH0pIHtcbiAgICAvLyBNYXAgb2YgUnRwQ29kZWNQYXJhbWV0ZXJzIGluZGV4ZWQgYnkgcGF5bG9hZCB0eXBlLlxuICAgIGNvbnN0IGNvZGVjc01hcCA9IG5ldyBNYXAoKTtcbiAgICAvLyBBcnJheSBvZiBSdHBIZWFkZXJFeHRlbnNpb25zLlxuICAgIGNvbnN0IGhlYWRlckV4dGVuc2lvbnMgPSBbXTtcbiAgICAvLyBXaGV0aGVyIGEgbT1hdWRpby92aWRlbyBzZWN0aW9uIGhhcyBiZWVuIGFscmVhZHkgZm91bmQuXG4gICAgbGV0IGdvdEF1ZGlvID0gZmFsc2U7XG4gICAgbGV0IGdvdFZpZGVvID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBtIG9mIHNkcE9iamVjdC5tZWRpYSkge1xuICAgICAgICBjb25zdCBraW5kID0gbS50eXBlO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnb3RBdWRpbylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBnb3RBdWRpbyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnb3RWaWRlbylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBnb3RWaWRlbyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGNvZGVjcy5cbiAgICAgICAgZm9yIChjb25zdCBydHAgb2YgbS5ydHApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IGAke2tpbmR9LyR7cnRwLmNvZGVjfWAsXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkUGF5bG9hZFR5cGU6IHJ0cC5wYXlsb2FkLFxuICAgICAgICAgICAgICAgIGNsb2NrUmF0ZTogcnRwLnJhdGUsXG4gICAgICAgICAgICAgICAgY2hhbm5lbHM6IHJ0cC5lbmNvZGluZyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29kZWNzTWFwLnNldChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSwgY29kZWMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBjb2RlYyBwYXJhbWV0ZXJzLlxuICAgICAgICBmb3IgKGNvbnN0IGZtdHAgb2YgbS5mbXRwIHx8IFtdKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gc2RwVHJhbnNmb3JtLnBhcnNlUGFyYW1zKGZtdHAuY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gY29kZWNzTWFwLmdldChmbXRwLnBheWxvYWQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlYylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIFNwZWNpYWxzIGNhc2UgdG8gY29udmVydCBwYXJhbWV0ZXIgdmFsdWUgdG8gc3RyaW5nLlxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMgJiYgcGFyYW1ldGVyc1sncHJvZmlsZS1sZXZlbC1pZCddKVxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXSA9IFN0cmluZyhwYXJhbWV0ZXJzWydwcm9maWxlLWxldmVsLWlkJ10pO1xuICAgICAgICAgICAgY29kZWMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IFJUQ1AgZmVlZGJhY2sgZm9yIGVhY2ggY29kZWMuXG4gICAgICAgIGZvciAoY29uc3QgZmIgb2YgbS5ydGNwRmIgfHwgW10pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gY29kZWNzTWFwLmdldChmYi5wYXlsb2FkKTtcbiAgICAgICAgICAgIGlmICghY29kZWMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBmZWVkYmFjayA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBmYi50eXBlLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcjogZmIuc3VidHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghZmVlZGJhY2sucGFyYW1ldGVyKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBmZWVkYmFjay5wYXJhbWV0ZXI7XG4gICAgICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sucHVzaChmZWVkYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IFJUUCBoZWFkZXIgZXh0ZW5zaW9ucy5cbiAgICAgICAgZm9yIChjb25zdCBleHQgb2YgbS5leHQgfHwgW10pIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlbmNyeXB0ZWQgZXh0ZW5zaW9ucyAobm90IHlldCBzdXBwb3J0ZWQgaW4gbWVkaWFzb3VwKS5cbiAgICAgICAgICAgIGlmIChleHRbJ2VuY3J5cHQtdXJpJ10pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJFeHRlbnNpb24gPSB7XG4gICAgICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgICAgICB1cmk6IGV4dC51cmksXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkSWQ6IGV4dC52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlYWRlckV4dGVuc2lvbnMucHVzaChoZWFkZXJFeHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJ0cENhcGFiaWxpdGllcyA9IHtcbiAgICAgICAgY29kZWNzOiBBcnJheS5mcm9tKGNvZGVjc01hcC52YWx1ZXMoKSksXG4gICAgICAgIGhlYWRlckV4dGVuc2lvbnM6IGhlYWRlckV4dGVuc2lvbnNcbiAgICB9O1xuICAgIHJldHVybiBydHBDYXBhYmlsaXRpZXM7XG59XG5leHBvcnRzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMgPSBleHRyYWN0UnRwQ2FwYWJpbGl0aWVzO1xuZnVuY3Rpb24gZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHsgc2RwT2JqZWN0IH0pIHtcbiAgICBjb25zdCBtZWRpYU9iamVjdCA9IChzZHBPYmplY3QubWVkaWEgfHwgW10pXG4gICAgICAgIC5maW5kKChtKSA9PiAobS5pY2VVZnJhZyAmJiBtLnBvcnQgIT09IDApKTtcbiAgICBpZiAoIW1lZGlhT2JqZWN0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGFjdGl2ZSBtZWRpYSBzZWN0aW9uIGZvdW5kJyk7XG4gICAgY29uc3QgZmluZ2VycHJpbnQgPSBtZWRpYU9iamVjdC5maW5nZXJwcmludCB8fCBzZHBPYmplY3QuZmluZ2VycHJpbnQ7XG4gICAgbGV0IHJvbGU7XG4gICAgc3dpdGNoIChtZWRpYU9iamVjdC5zZXR1cCkge1xuICAgICAgICBjYXNlICdhY3RpdmUnOlxuICAgICAgICAgICAgcm9sZSA9ICdjbGllbnQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Bhc3NpdmUnOlxuICAgICAgICAgICAgcm9sZSA9ICdzZXJ2ZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FjdHBhc3MnOlxuICAgICAgICAgICAgcm9sZSA9ICdhdXRvJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHtcbiAgICAgICAgcm9sZSxcbiAgICAgICAgZmluZ2VycHJpbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBmaW5nZXJwcmludC50eXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmaW5nZXJwcmludC5oYXNoXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9O1xuICAgIHJldHVybiBkdGxzUGFyYW1ldGVycztcbn1cbmV4cG9ydHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzID0gZXh0cmFjdER0bHNQYXJhbWV0ZXJzO1xuZnVuY3Rpb24gZ2V0Q25hbWUoeyBvZmZlck1lZGlhT2JqZWN0IH0pIHtcbiAgICBjb25zdCBzc3JjQ25hbWVMaW5lID0gKG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW10pXG4gICAgICAgIC5maW5kKChsaW5lKSA9PiBsaW5lLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJyk7XG4gICAgaWYgKCFzc3JjQ25hbWVMaW5lKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgcmV0dXJuIHNzcmNDbmFtZUxpbmUudmFsdWU7XG59XG5leHBvcnRzLmdldENuYW1lID0gZ2V0Q25hbWU7XG4vKipcbiAqIEFwcGx5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGdpdmVuIFNEUCBtPSBzZWN0aW9uIGFuc3dlciBiYXNlZCBvbiB0aGVcbiAqIGdpdmVuIFJUUCBwYXJhbWV0ZXJzIG9mIGFuIG9mZmVyLlxuICovXG5mdW5jdGlvbiBhcHBseUNvZGVjUGFyYW1ldGVycyh7IG9mZmVyUnRwUGFyYW1ldGVycywgYW5zd2VyTWVkaWFPYmplY3QgfSkge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2Ygb2ZmZXJSdHBQYXJhbWV0ZXJzLmNvZGVjcykge1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGNvZGVjLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIEF2b2lkIHBhcnNpbmcgY29kZWMgcGFyYW1ldGVycyBmb3IgdW5oYW5kbGVkIGNvZGVjcy5cbiAgICAgICAgaWYgKG1pbWVUeXBlICE9PSAnYXVkaW8vb3B1cycpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgcnRwID0gKGFuc3dlck1lZGlhT2JqZWN0LnJ0cCB8fCBbXSlcbiAgICAgICAgICAgIC5maW5kKChyKSA9PiByLnBheWxvYWQgPT09IGNvZGVjLnBheWxvYWRUeXBlKTtcbiAgICAgICAgaWYgKCFydHApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gSnVzdCBpbiBjYXNlLlxuICAgICAgICBhbnN3ZXJNZWRpYU9iamVjdC5mbXRwID0gYW5zd2VyTWVkaWFPYmplY3QuZm10cCB8fCBbXTtcbiAgICAgICAgbGV0IGZtdHAgPSBhbnN3ZXJNZWRpYU9iamVjdC5mbXRwXG4gICAgICAgICAgICAuZmluZCgoZikgPT4gZi5wYXlsb2FkID09PSBjb2RlYy5wYXlsb2FkVHlwZSk7XG4gICAgICAgIGlmICghZm10cCkge1xuICAgICAgICAgICAgZm10cCA9IHsgcGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsIGNvbmZpZzogJycgfTtcbiAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LmZtdHAucHVzaChmbXRwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gc2RwVHJhbnNmb3JtLnBhcnNlUGFyYW1zKGZtdHAuY29uZmlnKTtcbiAgICAgICAgc3dpdGNoIChtaW1lVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYXVkaW8vb3B1cyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcHJvcFN0ZXJlbyA9IGNvZGVjLnBhcmFtZXRlcnNbJ3Nwcm9wLXN0ZXJlbyddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Byb3BTdGVyZW8gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc3RlcmVvID0gc3Byb3BTdGVyZW8gPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdyaXRlIHRoZSBjb2RlYyBmbXRwLmNvbmZpZyBiYWNrLlxuICAgICAgICBmbXRwLmNvbmZpZyA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgaWYgKGZtdHAuY29uZmlnKVxuICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9ICc7JztcbiAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IGAke2tleX09JHtwYXJhbWV0ZXJzW2tleV19YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuYXBwbHlDb2RlY1BhcmFtZXRlcnMgPSBhcHBseUNvZGVjUGFyYW1ldGVycztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getRtpEncodings({ offerMediaObject, track }) {\n    // First media SSRC (or the only one).\n    let firstSsrc;\n    const ssrcs = new Set();\n    for (const line of offerMediaObject.ssrcs || []) {\n        if (line.attribute !== 'msid')\n            continue;\n        const trackId = line.value.split(' ')[1];\n        if (trackId === track.id) {\n            const ssrc = line.id;\n            ssrcs.add(ssrc);\n            if (!firstSsrc)\n                firstSsrc = ssrc;\n        }\n    }\n    if (ssrcs.size === 0)\n        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);\n    const ssrcToRtxSsrc = new Map();\n    // First assume RTX is used.\n    for (const line of offerMediaObject.ssrcGroups || []) {\n        if (line.semantics !== 'FID')\n            continue;\n        let [ssrc, rtxSsrc] = line.ssrcs.split(/\\s+/);\n        ssrc = Number(ssrc);\n        rtxSsrc = Number(rtxSsrc);\n        if (ssrcs.has(ssrc)) {\n            // Remove both the SSRC and RTX SSRC from the set so later we know that they\n            // are already handled.\n            ssrcs.delete(ssrc);\n            ssrcs.delete(rtxSsrc);\n            // Add to the map.\n            ssrcToRtxSsrc.set(ssrc, rtxSsrc);\n        }\n    }\n    // If the set of SSRCs is not empty it means that RTX is not being used, so take\n    // media SSRCs from there.\n    for (const ssrc of ssrcs) {\n        // Add to the map.\n        ssrcToRtxSsrc.set(ssrc, null);\n    }\n    const encodings = [];\n    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {\n        const encoding = { ssrc };\n        if (rtxSsrc)\n            encoding.rtx = { ssrc: rtxSsrc };\n        encodings.push(encoding);\n    }\n    return encodings;\n}\nexports.getRtpEncodings = getRtpEncodings;\n/**\n * Adds multi-ssrc based simulcast into the given SDP media section offer.\n */\nfunction addLegacySimulcast({ offerMediaObject, track, numStreams }) {\n    if (numStreams <= 1)\n        throw new TypeError('numStreams must be greater than 1');\n    let firstSsrc;\n    let firstRtxSsrc;\n    let streamId;\n    // Get the SSRC.\n    const ssrcMsidLine = (offerMediaObject.ssrcs || [])\n        .find((line) => {\n        if (line.attribute !== 'msid')\n            return false;\n        const trackId = line.value.split(' ')[1];\n        if (trackId === track.id) {\n            firstSsrc = line.id;\n            streamId = line.value.split(' ')[0];\n            return true;\n        }\n        else {\n            return false;\n        }\n    });\n    if (!ssrcMsidLine)\n        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);\n    // Get the SSRC for RTX.\n    (offerMediaObject.ssrcGroups || [])\n        .some((line) => {\n        if (line.semantics !== 'FID')\n            return false;\n        const ssrcs = line.ssrcs.split(/\\s+/);\n        if (Number(ssrcs[0]) === firstSsrc) {\n            firstRtxSsrc = Number(ssrcs[1]);\n            return true;\n        }\n        else {\n            return false;\n        }\n    });\n    const ssrcCnameLine = offerMediaObject.ssrcs\n        .find((line) => (line.attribute === 'cname' && line.id === firstSsrc));\n    if (!ssrcCnameLine)\n        throw new Error(`a=ssrc line with cname information not found [track.id:${track.id}]`);\n    const cname = ssrcCnameLine.value;\n    const ssrcs = [];\n    const rtxSsrcs = [];\n    for (let i = 0; i < numStreams; ++i) {\n        ssrcs.push(firstSsrc + i);\n        if (firstRtxSsrc)\n            rtxSsrcs.push(firstRtxSsrc + i);\n    }\n    offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];\n    offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];\n    offerMediaObject.ssrcGroups.push({\n        semantics: 'SIM',\n        ssrcs: ssrcs.join(' ')\n    });\n    for (let i = 0; i < ssrcs.length; ++i) {\n        const ssrc = ssrcs[i];\n        offerMediaObject.ssrcs.push({\n            id: ssrc,\n            attribute: 'cname',\n            value: cname\n        });\n        offerMediaObject.ssrcs.push({\n            id: ssrc,\n            attribute: 'msid',\n            value: `${streamId} ${track.id}`\n        });\n    }\n    for (let i = 0; i < rtxSsrcs.length; ++i) {\n        const ssrc = ssrcs[i];\n        const rtxSsrc = rtxSsrcs[i];\n        offerMediaObject.ssrcs.push({\n            id: rtxSsrc,\n            attribute: 'cname',\n            value: cname\n        });\n        offerMediaObject.ssrcs.push({\n            id: rtxSsrc,\n            attribute: 'msid',\n            value: `${streamId} ${track.id}`\n        });\n        offerMediaObject.ssrcGroups.push({\n            semantics: 'FID',\n            ssrcs: `${ssrc} ${rtxSsrc}`\n        });\n    }\n}\nexports.addLegacySimulcast = addLegacySimulcast;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvc2RwL3BsYW5CVXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvc2RwL3BsYW5CVXRpbHMuanM/YjEyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QsIHRyYWNrIH0pIHtcbiAgICAvLyBGaXJzdCBtZWRpYSBTU1JDIChvciB0aGUgb25seSBvbmUpLlxuICAgIGxldCBmaXJzdFNzcmM7XG4gICAgY29uc3Qgc3NyY3MgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW10pIHtcbiAgICAgICAgaWYgKGxpbmUuYXR0cmlidXRlICE9PSAnbXNpZCcpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdHJhY2tJZCA9IGxpbmUudmFsdWUuc3BsaXQoJyAnKVsxXTtcbiAgICAgICAgaWYgKHRyYWNrSWQgPT09IHRyYWNrLmlkKSB7XG4gICAgICAgICAgICBjb25zdCBzc3JjID0gbGluZS5pZDtcbiAgICAgICAgICAgIHNzcmNzLmFkZChzc3JjKTtcbiAgICAgICAgICAgIGlmICghZmlyc3RTc3JjKVxuICAgICAgICAgICAgICAgIGZpcnN0U3NyYyA9IHNzcmM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNzcmNzLnNpemUgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYT1zc3JjIGxpbmUgd2l0aCBtc2lkIGluZm9ybWF0aW9uIG5vdCBmb3VuZCBbdHJhY2suaWQ6JHt0cmFjay5pZH1dYCk7XG4gICAgY29uc3Qgc3NyY1RvUnR4U3NyYyA9IG5ldyBNYXAoKTtcbiAgICAvLyBGaXJzdCBhc3N1bWUgUlRYIGlzIHVzZWQuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIG9mZmVyTWVkaWFPYmplY3Quc3NyY0dyb3VwcyB8fCBbXSkge1xuICAgICAgICBpZiAobGluZS5zZW1hbnRpY3MgIT09ICdGSUQnKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBbc3NyYywgcnR4U3NyY10gPSBsaW5lLnNzcmNzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIHNzcmMgPSBOdW1iZXIoc3NyYyk7XG4gICAgICAgIHJ0eFNzcmMgPSBOdW1iZXIocnR4U3NyYyk7XG4gICAgICAgIGlmIChzc3Jjcy5oYXMoc3NyYykpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBib3RoIHRoZSBTU1JDIGFuZCBSVFggU1NSQyBmcm9tIHRoZSBzZXQgc28gbGF0ZXIgd2Uga25vdyB0aGF0IHRoZXlcbiAgICAgICAgICAgIC8vIGFyZSBhbHJlYWR5IGhhbmRsZWQuXG4gICAgICAgICAgICBzc3Jjcy5kZWxldGUoc3NyYyk7XG4gICAgICAgICAgICBzc3Jjcy5kZWxldGUocnR4U3NyYyk7XG4gICAgICAgICAgICAvLyBBZGQgdG8gdGhlIG1hcC5cbiAgICAgICAgICAgIHNzcmNUb1J0eFNzcmMuc2V0KHNzcmMsIHJ0eFNzcmMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBzZXQgb2YgU1NSQ3MgaXMgbm90IGVtcHR5IGl0IG1lYW5zIHRoYXQgUlRYIGlzIG5vdCBiZWluZyB1c2VkLCBzbyB0YWtlXG4gICAgLy8gbWVkaWEgU1NSQ3MgZnJvbSB0aGVyZS5cbiAgICBmb3IgKGNvbnN0IHNzcmMgb2Ygc3NyY3MpIHtcbiAgICAgICAgLy8gQWRkIHRvIHRoZSBtYXAuXG4gICAgICAgIHNzcmNUb1J0eFNzcmMuc2V0KHNzcmMsIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGluZ3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtzc3JjLCBydHhTc3JjXSBvZiBzc3JjVG9SdHhTc3JjKSB7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0geyBzc3JjIH07XG4gICAgICAgIGlmIChydHhTc3JjKVxuICAgICAgICAgICAgZW5jb2RpbmcucnR4ID0geyBzc3JjOiBydHhTc3JjIH07XG4gICAgICAgIGVuY29kaW5ncy5wdXNoKGVuY29kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kaW5ncztcbn1cbmV4cG9ydHMuZ2V0UnRwRW5jb2RpbmdzID0gZ2V0UnRwRW5jb2RpbmdzO1xuLyoqXG4gKiBBZGRzIG11bHRpLXNzcmMgYmFzZWQgc2ltdWxjYXN0IGludG8gdGhlIGdpdmVuIFNEUCBtZWRpYSBzZWN0aW9uIG9mZmVyLlxuICovXG5mdW5jdGlvbiBhZGRMZWdhY3lTaW11bGNhc3QoeyBvZmZlck1lZGlhT2JqZWN0LCB0cmFjaywgbnVtU3RyZWFtcyB9KSB7XG4gICAgaWYgKG51bVN0cmVhbXMgPD0gMSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbnVtU3RyZWFtcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgbGV0IGZpcnN0U3NyYztcbiAgICBsZXQgZmlyc3RSdHhTc3JjO1xuICAgIGxldCBzdHJlYW1JZDtcbiAgICAvLyBHZXQgdGhlIFNTUkMuXG4gICAgY29uc3Qgc3NyY01zaWRMaW5lID0gKG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW10pXG4gICAgICAgIC5maW5kKChsaW5lKSA9PiB7XG4gICAgICAgIGlmIChsaW5lLmF0dHJpYnV0ZSAhPT0gJ21zaWQnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB0cmFja0lkID0gbGluZS52YWx1ZS5zcGxpdCgnICcpWzFdO1xuICAgICAgICBpZiAodHJhY2tJZCA9PT0gdHJhY2suaWQpIHtcbiAgICAgICAgICAgIGZpcnN0U3NyYyA9IGxpbmUuaWQ7XG4gICAgICAgICAgICBzdHJlYW1JZCA9IGxpbmUudmFsdWUuc3BsaXQoJyAnKVswXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFzc3JjTXNpZExpbmUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYT1zc3JjIGxpbmUgd2l0aCBtc2lkIGluZm9ybWF0aW9uIG5vdCBmb3VuZCBbdHJhY2suaWQ6JHt0cmFjay5pZH1dYCk7XG4gICAgLy8gR2V0IHRoZSBTU1JDIGZvciBSVFguXG4gICAgKG9mZmVyTWVkaWFPYmplY3Quc3NyY0dyb3VwcyB8fCBbXSlcbiAgICAgICAgLnNvbWUoKGxpbmUpID0+IHtcbiAgICAgICAgaWYgKGxpbmUuc2VtYW50aWNzICE9PSAnRklEJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3NyY3MgPSBsaW5lLnNzcmNzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGlmIChOdW1iZXIoc3NyY3NbMF0pID09PSBmaXJzdFNzcmMpIHtcbiAgICAgICAgICAgIGZpcnN0UnR4U3NyYyA9IE51bWJlcihzc3Jjc1sxXSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNzcmNDbmFtZUxpbmUgPSBvZmZlck1lZGlhT2JqZWN0LnNzcmNzXG4gICAgICAgIC5maW5kKChsaW5lKSA9PiAobGluZS5hdHRyaWJ1dGUgPT09ICdjbmFtZScgJiYgbGluZS5pZCA9PT0gZmlyc3RTc3JjKSk7XG4gICAgaWYgKCFzc3JjQ25hbWVMaW5lKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGE9c3NyYyBsaW5lIHdpdGggY25hbWUgaW5mb3JtYXRpb24gbm90IGZvdW5kIFt0cmFjay5pZDoke3RyYWNrLmlkfV1gKTtcbiAgICBjb25zdCBjbmFtZSA9IHNzcmNDbmFtZUxpbmUudmFsdWU7XG4gICAgY29uc3Qgc3NyY3MgPSBbXTtcbiAgICBjb25zdCBydHhTc3JjcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU3RyZWFtczsgKytpKSB7XG4gICAgICAgIHNzcmNzLnB1c2goZmlyc3RTc3JjICsgaSk7XG4gICAgICAgIGlmIChmaXJzdFJ0eFNzcmMpXG4gICAgICAgICAgICBydHhTc3Jjcy5wdXNoKGZpcnN0UnR4U3NyYyArIGkpO1xuICAgIH1cbiAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMgPSBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMgfHwgW107XG4gICAgb2ZmZXJNZWRpYU9iamVjdC5zc3JjcyA9IG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW107XG4gICAgb2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzLnB1c2goe1xuICAgICAgICBzZW1hbnRpY3M6ICdTSU0nLFxuICAgICAgICBzc3Jjczogc3NyY3Muam9pbignICcpXG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzc3Jjcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzc3JjID0gc3NyY3NbaV07XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICBpZDogc3NyYyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogJ2NuYW1lJyxcbiAgICAgICAgICAgIHZhbHVlOiBjbmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBzc3JjLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnbXNpZCcsXG4gICAgICAgICAgICB2YWx1ZTogYCR7c3RyZWFtSWR9ICR7dHJhY2suaWR9YFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydHhTc3Jjcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzc3JjID0gc3NyY3NbaV07XG4gICAgICAgIGNvbnN0IHJ0eFNzcmMgPSBydHhTc3Jjc1tpXTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBydHhTc3JjLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnY25hbWUnLFxuICAgICAgICAgICAgdmFsdWU6IGNuYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHJ0eFNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdtc2lkJyxcbiAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZH0gJHt0cmFjay5pZH1gXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMucHVzaCh7XG4gICAgICAgICAgICBzZW1hbnRpY3M6ICdGSUQnLFxuICAgICAgICAgICAgc3NyY3M6IGAke3NzcmN9ICR7cnR4U3NyY31gXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuYWRkTGVnYWN5U2ltdWxjYXN0ID0gYWRkTGVnYWN5U2ltdWxjYXN0O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getRtpEncodings({ offerMediaObject }) {\n    const ssrcs = new Set();\n    for (const line of offerMediaObject.ssrcs || []) {\n        const ssrc = line.id;\n        ssrcs.add(ssrc);\n    }\n    if (ssrcs.size === 0)\n        throw new Error('no a=ssrc lines found');\n    const ssrcToRtxSsrc = new Map();\n    // First assume RTX is used.\n    for (const line of offerMediaObject.ssrcGroups || []) {\n        if (line.semantics !== 'FID')\n            continue;\n        let [ssrc, rtxSsrc] = line.ssrcs.split(/\\s+/);\n        ssrc = Number(ssrc);\n        rtxSsrc = Number(rtxSsrc);\n        if (ssrcs.has(ssrc)) {\n            // Remove both the SSRC and RTX SSRC from the set so later we know that they\n            // are already handled.\n            ssrcs.delete(ssrc);\n            ssrcs.delete(rtxSsrc);\n            // Add to the map.\n            ssrcToRtxSsrc.set(ssrc, rtxSsrc);\n        }\n    }\n    // If the set of SSRCs is not empty it means that RTX is not being used, so take\n    // media SSRCs from there.\n    for (const ssrc of ssrcs) {\n        // Add to the map.\n        ssrcToRtxSsrc.set(ssrc, null);\n    }\n    const encodings = [];\n    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {\n        const encoding = { ssrc };\n        if (rtxSsrc)\n            encoding.rtx = { ssrc: rtxSsrc };\n        encodings.push(encoding);\n    }\n    return encodings;\n}\nexports.getRtpEncodings = getRtpEncodings;\n/**\n * Adds multi-ssrc based simulcast into the given SDP media section offer.\n */\nfunction addLegacySimulcast({ offerMediaObject, numStreams }) {\n    if (numStreams <= 1)\n        throw new TypeError('numStreams must be greater than 1');\n    // Get the SSRC.\n    const ssrcMsidLine = (offerMediaObject.ssrcs || [])\n        .find((line) => line.attribute === 'msid');\n    if (!ssrcMsidLine)\n        throw new Error('a=ssrc line with msid information not found');\n    const [streamId, trackId] = ssrcMsidLine.value.split(' ')[0];\n    const firstSsrc = ssrcMsidLine.id;\n    let firstRtxSsrc;\n    // Get the SSRC for RTX.\n    (offerMediaObject.ssrcGroups || [])\n        .some((line) => {\n        if (line.semantics !== 'FID')\n            return false;\n        const ssrcs = line.ssrcs.split(/\\s+/);\n        if (Number(ssrcs[0]) === firstSsrc) {\n            firstRtxSsrc = Number(ssrcs[1]);\n            return true;\n        }\n        else {\n            return false;\n        }\n    });\n    const ssrcCnameLine = offerMediaObject.ssrcs\n        .find((line) => line.attribute === 'cname');\n    if (!ssrcCnameLine)\n        throw new Error('a=ssrc line with cname information not found');\n    const cname = ssrcCnameLine.value;\n    const ssrcs = [];\n    const rtxSsrcs = [];\n    for (let i = 0; i < numStreams; ++i) {\n        ssrcs.push(firstSsrc + i);\n        if (firstRtxSsrc)\n            rtxSsrcs.push(firstRtxSsrc + i);\n    }\n    offerMediaObject.ssrcGroups = [];\n    offerMediaObject.ssrcs = [];\n    offerMediaObject.ssrcGroups.push({\n        semantics: 'SIM',\n        ssrcs: ssrcs.join(' ')\n    });\n    for (let i = 0; i < ssrcs.length; ++i) {\n        const ssrc = ssrcs[i];\n        offerMediaObject.ssrcs.push({\n            id: ssrc,\n            attribute: 'cname',\n            value: cname\n        });\n        offerMediaObject.ssrcs.push({\n            id: ssrc,\n            attribute: 'msid',\n            value: `${streamId} ${trackId}`\n        });\n    }\n    for (let i = 0; i < rtxSsrcs.length; ++i) {\n        const ssrc = ssrcs[i];\n        const rtxSsrc = rtxSsrcs[i];\n        offerMediaObject.ssrcs.push({\n            id: rtxSsrc,\n            attribute: 'cname',\n            value: cname\n        });\n        offerMediaObject.ssrcs.push({\n            id: rtxSsrc,\n            attribute: 'msid',\n            value: `${streamId} ${trackId}`\n        });\n        offerMediaObject.ssrcGroups.push({\n            semantics: 'FID',\n            ssrcs: `${ssrc} ${rtxSsrc}`\n        });\n    }\n}\nexports.addLegacySimulcast = addLegacySimulcast;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvc2RwL3VuaWZpZWRQbGFuVXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvc2RwL3VuaWZpZWRQbGFuVXRpbHMuanM/ODg3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QgfSkge1xuICAgIGNvbnN0IHNzcmNzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBvZmZlck1lZGlhT2JqZWN0LnNzcmNzIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IHNzcmMgPSBsaW5lLmlkO1xuICAgICAgICBzc3Jjcy5hZGQoc3NyYyk7XG4gICAgfVxuICAgIGlmIChzc3Jjcy5zaXplID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGE9c3NyYyBsaW5lcyBmb3VuZCcpO1xuICAgIGNvbnN0IHNzcmNUb1J0eFNzcmMgPSBuZXcgTWFwKCk7XG4gICAgLy8gRmlyc3QgYXNzdW1lIFJUWCBpcyB1c2VkLlxuICAgIGZvciAoY29uc3QgbGluZSBvZiBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMgfHwgW10pIHtcbiAgICAgICAgaWYgKGxpbmUuc2VtYW50aWNzICE9PSAnRklEJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgW3NzcmMsIHJ0eFNzcmNdID0gbGluZS5zc3Jjcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICBzc3JjID0gTnVtYmVyKHNzcmMpO1xuICAgICAgICBydHhTc3JjID0gTnVtYmVyKHJ0eFNzcmMpO1xuICAgICAgICBpZiAoc3NyY3MuaGFzKHNzcmMpKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYm90aCB0aGUgU1NSQyBhbmQgUlRYIFNTUkMgZnJvbSB0aGUgc2V0IHNvIGxhdGVyIHdlIGtub3cgdGhhdCB0aGV5XG4gICAgICAgICAgICAvLyBhcmUgYWxyZWFkeSBoYW5kbGVkLlxuICAgICAgICAgICAgc3NyY3MuZGVsZXRlKHNzcmMpO1xuICAgICAgICAgICAgc3NyY3MuZGVsZXRlKHJ0eFNzcmMpO1xuICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBtYXAuXG4gICAgICAgICAgICBzc3JjVG9SdHhTc3JjLnNldChzc3JjLCBydHhTc3JjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgc2V0IG9mIFNTUkNzIGlzIG5vdCBlbXB0eSBpdCBtZWFucyB0aGF0IFJUWCBpcyBub3QgYmVpbmcgdXNlZCwgc28gdGFrZVxuICAgIC8vIG1lZGlhIFNTUkNzIGZyb20gdGhlcmUuXG4gICAgZm9yIChjb25zdCBzc3JjIG9mIHNzcmNzKSB7XG4gICAgICAgIC8vIEFkZCB0byB0aGUgbWFwLlxuICAgICAgICBzc3JjVG9SdHhTc3JjLnNldChzc3JjLCBudWxsKTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RpbmdzID0gW107XG4gICAgZm9yIChjb25zdCBbc3NyYywgcnR4U3NyY10gb2Ygc3NyY1RvUnR4U3NyYykge1xuICAgICAgICBjb25zdCBlbmNvZGluZyA9IHsgc3NyYyB9O1xuICAgICAgICBpZiAocnR4U3NyYylcbiAgICAgICAgICAgIGVuY29kaW5nLnJ0eCA9IHsgc3NyYzogcnR4U3NyYyB9O1xuICAgICAgICBlbmNvZGluZ3MucHVzaChlbmNvZGluZyk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGluZ3M7XG59XG5leHBvcnRzLmdldFJ0cEVuY29kaW5ncyA9IGdldFJ0cEVuY29kaW5ncztcbi8qKlxuICogQWRkcyBtdWx0aS1zc3JjIGJhc2VkIHNpbXVsY2FzdCBpbnRvIHRoZSBnaXZlbiBTRFAgbWVkaWEgc2VjdGlvbiBvZmZlci5cbiAqL1xuZnVuY3Rpb24gYWRkTGVnYWN5U2ltdWxjYXN0KHsgb2ZmZXJNZWRpYU9iamVjdCwgbnVtU3RyZWFtcyB9KSB7XG4gICAgaWYgKG51bVN0cmVhbXMgPD0gMSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbnVtU3RyZWFtcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgLy8gR2V0IHRoZSBTU1JDLlxuICAgIGNvbnN0IHNzcmNNc2lkTGluZSA9IChvZmZlck1lZGlhT2JqZWN0LnNzcmNzIHx8IFtdKVxuICAgICAgICAuZmluZCgobGluZSkgPT4gbGluZS5hdHRyaWJ1dGUgPT09ICdtc2lkJyk7XG4gICAgaWYgKCFzc3JjTXNpZExpbmUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYT1zc3JjIGxpbmUgd2l0aCBtc2lkIGluZm9ybWF0aW9uIG5vdCBmb3VuZCcpO1xuICAgIGNvbnN0IFtzdHJlYW1JZCwgdHJhY2tJZF0gPSBzc3JjTXNpZExpbmUudmFsdWUuc3BsaXQoJyAnKVswXTtcbiAgICBjb25zdCBmaXJzdFNzcmMgPSBzc3JjTXNpZExpbmUuaWQ7XG4gICAgbGV0IGZpcnN0UnR4U3NyYztcbiAgICAvLyBHZXQgdGhlIFNTUkMgZm9yIFJUWC5cbiAgICAob2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzIHx8IFtdKVxuICAgICAgICAuc29tZSgobGluZSkgPT4ge1xuICAgICAgICBpZiAobGluZS5zZW1hbnRpY3MgIT09ICdGSUQnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzc3JjcyA9IGxpbmUuc3NyY3Muc3BsaXQoL1xccysvKTtcbiAgICAgICAgaWYgKE51bWJlcihzc3Jjc1swXSkgPT09IGZpcnN0U3NyYykge1xuICAgICAgICAgICAgZmlyc3RSdHhTc3JjID0gTnVtYmVyKHNzcmNzWzFdKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3NyY0NuYW1lTGluZSA9IG9mZmVyTWVkaWFPYmplY3Quc3NyY3NcbiAgICAgICAgLmZpbmQoKGxpbmUpID0+IGxpbmUuYXR0cmlidXRlID09PSAnY25hbWUnKTtcbiAgICBpZiAoIXNzcmNDbmFtZUxpbmUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYT1zc3JjIGxpbmUgd2l0aCBjbmFtZSBpbmZvcm1hdGlvbiBub3QgZm91bmQnKTtcbiAgICBjb25zdCBjbmFtZSA9IHNzcmNDbmFtZUxpbmUudmFsdWU7XG4gICAgY29uc3Qgc3NyY3MgPSBbXTtcbiAgICBjb25zdCBydHhTc3JjcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU3RyZWFtczsgKytpKSB7XG4gICAgICAgIHNzcmNzLnB1c2goZmlyc3RTc3JjICsgaSk7XG4gICAgICAgIGlmIChmaXJzdFJ0eFNzcmMpXG4gICAgICAgICAgICBydHhTc3Jjcy5wdXNoKGZpcnN0UnR4U3NyYyArIGkpO1xuICAgIH1cbiAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMgPSBbXTtcbiAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzID0gW107XG4gICAgb2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzLnB1c2goe1xuICAgICAgICBzZW1hbnRpY3M6ICdTSU0nLFxuICAgICAgICBzc3Jjczogc3NyY3Muam9pbignICcpXG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzc3Jjcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzc3JjID0gc3NyY3NbaV07XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICBpZDogc3NyYyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogJ2NuYW1lJyxcbiAgICAgICAgICAgIHZhbHVlOiBjbmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBzc3JjLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnbXNpZCcsXG4gICAgICAgICAgICB2YWx1ZTogYCR7c3RyZWFtSWR9ICR7dHJhY2tJZH1gXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ0eFNzcmNzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNzcmMgPSBzc3Jjc1tpXTtcbiAgICAgICAgY29uc3QgcnR4U3NyYyA9IHJ0eFNzcmNzW2ldO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHJ0eFNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICB2YWx1ZTogY25hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICBpZDogcnR4U3NyYyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogJ21zaWQnLFxuICAgICAgICAgICAgdmFsdWU6IGAke3N0cmVhbUlkfSAke3RyYWNrSWR9YFxuICAgICAgICB9KTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzLnB1c2goe1xuICAgICAgICAgICAgc2VtYW50aWNzOiAnRklEJyxcbiAgICAgICAgICAgIHNzcmNzOiBgJHtzc3JjfSAke3J0eFNzcmN9YFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmFkZExlZ2FjeVNpbXVsY2FzdCA9IGFkZExlZ2FjeVNpbXVsY2FzdDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Device_1 = __webpack_require__(/*! ./Device */ \"./node_modules/mediasoup-client/lib/Device.js\");\nexports.Device = Device_1.Device;\nexports.detectDevice = Device_1.detectDevice;\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/mediasoup-client/lib/types.js\");\nexports.types = types;\n/**\n * Expose mediasoup-client version.\n */\nexports.version = '3.6.10';\n/**\n * Expose parseScalabilityMode() function.\n */\nvar scalabilityModes_1 = __webpack_require__(/*! ./scalabilityModes */ \"./node_modules/mediasoup-client/lib/scalabilityModes.js\");\nexports.parseScalabilityMode = scalabilityModes_1.parse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaW5kZXguanM/ZGRmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IERldmljZV8xID0gcmVxdWlyZShcIi4vRGV2aWNlXCIpO1xuZXhwb3J0cy5EZXZpY2UgPSBEZXZpY2VfMS5EZXZpY2U7XG5leHBvcnRzLmRldGVjdERldmljZSA9IERldmljZV8xLmRldGVjdERldmljZTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5leHBvcnRzLnR5cGVzID0gdHlwZXM7XG4vKipcbiAqIEV4cG9zZSBtZWRpYXNvdXAtY2xpZW50IHZlcnNpb24uXG4gKi9cbmV4cG9ydHMudmVyc2lvbiA9ICczLjYuMTAnO1xuLyoqXG4gKiBFeHBvc2UgcGFyc2VTY2FsYWJpbGl0eU1vZGUoKSBmdW5jdGlvbi5cbiAqL1xudmFyIHNjYWxhYmlsaXR5TW9kZXNfMSA9IHJlcXVpcmUoXCIuL3NjYWxhYmlsaXR5TW9kZXNcIik7XG5leHBvcnRzLnBhcnNlU2NhbGFiaWxpdHlNb2RlID0gc2NhbGFiaWxpdHlNb2Rlc18xLnBhcnNlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/index.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/ortc.js":
/*!***************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/ortc.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst h264 = __webpack_require__(/*! h264-profile-level-id */ \"./node_modules/h264-profile-level-id/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\nconst RTP_PROBATOR_MID = 'probator';\nconst RTP_PROBATOR_SSRC = 1234;\nconst RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;\n/**\n * Validates RtpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCapabilities(caps) {\n    if (typeof caps !== 'object')\n        throw new TypeError('caps is not an object');\n    // codecs is optional. If unset, fill with an empty array.\n    if (caps.codecs && !Array.isArray(caps.codecs))\n        throw new TypeError('caps.codecs is not an array');\n    else if (!caps.codecs)\n        caps.codecs = [];\n    for (const codec of caps.codecs) {\n        validateRtpCodecCapability(codec);\n    }\n    // headerExtensions is optional. If unset, fill with an empty array.\n    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions))\n        throw new TypeError('caps.headerExtensions is not an array');\n    else if (!caps.headerExtensions)\n        caps.headerExtensions = [];\n    for (const ext of caps.headerExtensions) {\n        validateRtpHeaderExtension(ext);\n    }\n}\nexports.validateRtpCapabilities = validateRtpCapabilities;\n/**\n * Validates RtpCodecCapability. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecCapability(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    if (typeof codec !== 'object')\n        throw new TypeError('codec is not an object');\n    // mimeType is mandatory.\n    if (!codec.mimeType || typeof codec.mimeType !== 'string')\n        throw new TypeError('missing codec.mimeType');\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch)\n        throw new TypeError('invalid codec.mimeType');\n    // Just override kind with media component of mimeType.\n    codec.kind = mimeTypeMatch[1].toLowerCase();\n    // preferredPayloadType is optional.\n    if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number')\n        throw new TypeError('invalid codec.preferredPayloadType');\n    // clockRate is mandatory.\n    if (typeof codec.clockRate !== 'number')\n        throw new TypeError('missing codec.clockRate');\n    // channels is optional. If unset, set it to 1 (just if audio).\n    if (codec.kind === 'audio') {\n        if (typeof codec.channels !== 'number')\n            codec.channels = 1;\n    }\n    else {\n        delete codec.channels;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!codec.parameters || typeof codec.parameters !== 'object')\n        codec.parameters = {};\n    for (const key of Object.keys(codec.parameters)) {\n        let value = codec.parameters[key];\n        if (value === undefined) {\n            codec.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n        }\n        // Specific parameters validation.\n        if (key === 'apt') {\n            if (typeof value !== 'number')\n                throw new TypeError('invalid codec apt parameter');\n        }\n    }\n    // rtcpFeedback is optional. If unset, set it to an empty array.\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))\n        codec.rtcpFeedback = [];\n    for (const fb of codec.rtcpFeedback) {\n        validateRtcpFeedback(fb);\n    }\n}\nexports.validateRtpCodecCapability = validateRtpCodecCapability;\n/**\n * Validates RtcpFeedback. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpFeedback(fb) {\n    if (typeof fb !== 'object')\n        throw new TypeError('fb is not an object');\n    // type is mandatory.\n    if (!fb.type || typeof fb.type !== 'string')\n        throw new TypeError('missing fb.type');\n    // parameter is optional. If unset set it to an empty string.\n    if (!fb.parameter || typeof fb.parameter !== 'string')\n        fb.parameter = '';\n}\nexports.validateRtcpFeedback = validateRtcpFeedback;\n/**\n * Validates RtpHeaderExtension. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtension(ext) {\n    if (typeof ext !== 'object')\n        throw new TypeError('ext is not an object');\n    // kind is optional. If unset set it to an empty string.\n    if (!ext.kind || typeof ext.kind !== 'string')\n        ext.kind = '';\n    if (ext.kind !== '' && ext.kind !== 'audio' && ext.kind !== 'video')\n        throw new TypeError('invalid ext.kind');\n    // uri is mandatory.\n    if (!ext.uri || typeof ext.uri !== 'string')\n        throw new TypeError('missing ext.uri');\n    // preferredId is mandatory.\n    if (typeof ext.preferredId !== 'number')\n        throw new TypeError('missing ext.preferredId');\n    // preferredEncrypt is optional. If unset set it to false.\n    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean')\n        throw new TypeError('invalid ext.preferredEncrypt');\n    else if (!ext.preferredEncrypt)\n        ext.preferredEncrypt = false;\n    // direction is optional. If unset set it to sendrecv.\n    if (ext.direction && typeof ext.direction !== 'string')\n        throw new TypeError('invalid ext.direction');\n    else if (!ext.direction)\n        ext.direction = 'sendrecv';\n}\nexports.validateRtpHeaderExtension = validateRtpHeaderExtension;\n/**\n * Validates RtpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpParameters(params) {\n    if (typeof params !== 'object')\n        throw new TypeError('params is not an object');\n    // mid is optional.\n    if (params.mid && typeof params.mid !== 'string')\n        throw new TypeError('params.mid is not a string');\n    // codecs is mandatory.\n    if (!Array.isArray(params.codecs))\n        throw new TypeError('missing params.codecs');\n    for (const codec of params.codecs) {\n        validateRtpCodecParameters(codec);\n    }\n    // headerExtensions is optional. If unset, fill with an empty array.\n    if (params.headerExtensions && !Array.isArray(params.headerExtensions))\n        throw new TypeError('params.headerExtensions is not an array');\n    else if (!params.headerExtensions)\n        params.headerExtensions = [];\n    for (const ext of params.headerExtensions) {\n        validateRtpHeaderExtensionParameters(ext);\n    }\n    // encodings is optional. If unset, fill with an empty array.\n    if (params.encodings && !Array.isArray(params.encodings))\n        throw new TypeError('params.encodings is not an array');\n    else if (!params.encodings)\n        params.encodings = [];\n    for (const encoding of params.encodings) {\n        validateRtpEncodingParameters(encoding);\n    }\n    // rtcp is optional. If unset, fill with an empty object.\n    if (params.rtcp && typeof params.rtcp !== 'object')\n        throw new TypeError('params.rtcp is not an object');\n    else if (!params.rtcp)\n        params.rtcp = {};\n    validateRtcpParameters(params.rtcp);\n}\nexports.validateRtpParameters = validateRtpParameters;\n/**\n * Validates RtpCodecParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecParameters(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    if (typeof codec !== 'object')\n        throw new TypeError('codec is not an object');\n    // mimeType is mandatory.\n    if (!codec.mimeType || typeof codec.mimeType !== 'string')\n        throw new TypeError('missing codec.mimeType');\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch)\n        throw new TypeError('invalid codec.mimeType');\n    // payloadType is mandatory.\n    if (typeof codec.payloadType !== 'number')\n        throw new TypeError('missing codec.payloadType');\n    // clockRate is mandatory.\n    if (typeof codec.clockRate !== 'number')\n        throw new TypeError('missing codec.clockRate');\n    const kind = mimeTypeMatch[1].toLowerCase();\n    // channels is optional. If unset, set it to 1 (just if audio).\n    if (kind === 'audio') {\n        if (typeof codec.channels !== 'number')\n            codec.channels = 1;\n    }\n    else {\n        delete codec.channels;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!codec.parameters || typeof codec.parameters !== 'object')\n        codec.parameters = {};\n    for (const key of Object.keys(codec.parameters)) {\n        let value = codec.parameters[key];\n        if (value === undefined) {\n            codec.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n        }\n        // Specific parameters validation.\n        if (key === 'apt') {\n            if (typeof value !== 'number')\n                throw new TypeError('invalid codec apt parameter');\n        }\n    }\n    // rtcpFeedback is optional. If unset, set it to an empty array.\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))\n        codec.rtcpFeedback = [];\n    for (const fb of codec.rtcpFeedback) {\n        validateRtcpFeedback(fb);\n    }\n}\nexports.validateRtpCodecParameters = validateRtpCodecParameters;\n/**\n * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtensionParameters(ext) {\n    if (typeof ext !== 'object')\n        throw new TypeError('ext is not an object');\n    // uri is mandatory.\n    if (!ext.uri || typeof ext.uri !== 'string')\n        throw new TypeError('missing ext.uri');\n    // id is mandatory.\n    if (typeof ext.id !== 'number')\n        throw new TypeError('missing ext.id');\n    // encrypt is optional. If unset set it to false.\n    if (ext.encrypt && typeof ext.encrypt !== 'boolean')\n        throw new TypeError('invalid ext.encrypt');\n    else if (!ext.encrypt)\n        ext.encrypt = false;\n    // parameters is optional. If unset, set it to an empty object.\n    if (!ext.parameters || typeof ext.parameters !== 'object')\n        ext.parameters = {};\n    for (const key of Object.keys(ext.parameters)) {\n        let value = ext.parameters[key];\n        if (value === undefined) {\n            ext.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number')\n            throw new TypeError('invalid header extension parameter');\n    }\n}\nexports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;\n/**\n * Validates RtpEncodingParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpEncodingParameters(encoding) {\n    if (typeof encoding !== 'object')\n        throw new TypeError('encoding is not an object');\n    // ssrc is optional.\n    if (encoding.ssrc && typeof encoding.ssrc !== 'number')\n        throw new TypeError('invalid encoding.ssrc');\n    // rid is optional.\n    if (encoding.rid && typeof encoding.rid !== 'string')\n        throw new TypeError('invalid encoding.rid');\n    // rtx is optional.\n    if (encoding.rtx && typeof encoding.rtx !== 'object') {\n        throw new TypeError('invalid encoding.rtx');\n    }\n    else if (encoding.rtx) {\n        // RTX ssrc is mandatory if rtx is present.\n        if (typeof encoding.rtx.ssrc !== 'number')\n            throw new TypeError('missing encoding.rtx.ssrc');\n    }\n    // dtx is optional. If unset set it to false.\n    if (!encoding.dtx || typeof encoding.dtx !== 'boolean')\n        encoding.dtx = false;\n    // scalabilityMode is optional.\n    if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string')\n        throw new TypeError('invalid encoding.scalabilityMode');\n}\nexports.validateRtpEncodingParameters = validateRtpEncodingParameters;\n/**\n * Validates RtcpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpParameters(rtcp) {\n    if (typeof rtcp !== 'object')\n        throw new TypeError('rtcp is not an object');\n    // cname is optional.\n    if (rtcp.cname && typeof rtcp.cname !== 'string')\n        throw new TypeError('invalid rtcp.cname');\n    // reducedSize is optional. If unset set it to true.\n    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean')\n        rtcp.reducedSize = true;\n}\nexports.validateRtcpParameters = validateRtcpParameters;\n/**\n * Validates SctpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpCapabilities(caps) {\n    if (typeof caps !== 'object')\n        throw new TypeError('caps is not an object');\n    // numStreams is mandatory.\n    if (!caps.numStreams || typeof caps.numStreams !== 'object')\n        throw new TypeError('missing caps.numStreams');\n    validateNumSctpStreams(caps.numStreams);\n}\nexports.validateSctpCapabilities = validateSctpCapabilities;\n/**\n * Validates NumSctpStreams. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateNumSctpStreams(numStreams) {\n    if (typeof numStreams !== 'object')\n        throw new TypeError('numStreams is not an object');\n    // OS is mandatory.\n    if (typeof numStreams.OS !== 'number')\n        throw new TypeError('missing numStreams.OS');\n    // MIS is mandatory.\n    if (typeof numStreams.MIS !== 'number')\n        throw new TypeError('missing numStreams.MIS');\n}\nexports.validateNumSctpStreams = validateNumSctpStreams;\n/**\n * Validates SctpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpParameters(params) {\n    if (typeof params !== 'object')\n        throw new TypeError('params is not an object');\n    // port is mandatory.\n    if (typeof params.port !== 'number')\n        throw new TypeError('missing params.port');\n    // OS is mandatory.\n    if (typeof params.OS !== 'number')\n        throw new TypeError('missing params.OS');\n    // MIS is mandatory.\n    if (typeof params.MIS !== 'number')\n        throw new TypeError('missing params.MIS');\n    // maxMessageSize is mandatory.\n    if (typeof params.maxMessageSize !== 'number')\n        throw new TypeError('missing params.maxMessageSize');\n}\nexports.validateSctpParameters = validateSctpParameters;\n/**\n * Validates SctpStreamParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpStreamParameters(params) {\n    if (typeof params !== 'object')\n        throw new TypeError('params is not an object');\n    // streamId is mandatory.\n    if (typeof params.streamId !== 'number')\n        throw new TypeError('missing params.streamId');\n    // ordered is optional.\n    let orderedGiven = false;\n    if (typeof params.ordered === 'boolean')\n        orderedGiven = true;\n    else\n        params.ordered = true;\n    // maxPacketLifeTime is optional.\n    if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number')\n        throw new TypeError('invalid params.maxPacketLifeTime');\n    // maxRetransmits is optional.\n    if (params.maxRetransmits && typeof params.maxRetransmits !== 'number')\n        throw new TypeError('invalid params.maxRetransmits');\n    if (params.maxPacketLifeTime && params.maxRetransmits)\n        throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');\n    if (orderedGiven &&\n        params.ordered &&\n        (params.maxPacketLifeTime || params.maxRetransmits)) {\n        throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');\n    }\n    else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {\n        params.ordered = false;\n    }\n    // priority is optional.\n    if (params.priority && typeof params.priority !== 'string')\n        throw new TypeError('invalid params.priority');\n    // label is optional.\n    if (params.label && typeof params.label !== 'string')\n        throw new TypeError('invalid params.label');\n    // protocol is optional.\n    if (params.protocol && typeof params.protocol !== 'string')\n        throw new TypeError('invalid params.protocol');\n}\nexports.validateSctpStreamParameters = validateSctpStreamParameters;\n/**\n * Generate extended RTP capabilities for sending and receiving.\n */\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps) {\n    const extendedRtpCapabilities = {\n        codecs: [],\n        headerExtensions: []\n    };\n    // Match media codecs and keep the order preferred by remoteCaps.\n    for (const remoteCodec of remoteCaps.codecs || []) {\n        if (isRtxCodec(remoteCodec))\n            continue;\n        const matchingLocalCodec = (localCaps.codecs || [])\n            .find((localCodec) => (matchCodecs(localCodec, remoteCodec, { strict: true, modify: true })));\n        if (!matchingLocalCodec)\n            continue;\n        const extendedCodec = {\n            mimeType: matchingLocalCodec.mimeType,\n            kind: matchingLocalCodec.kind,\n            clockRate: matchingLocalCodec.clockRate,\n            channels: matchingLocalCodec.channels,\n            localPayloadType: matchingLocalCodec.preferredPayloadType,\n            localRtxPayloadType: undefined,\n            remotePayloadType: remoteCodec.preferredPayloadType,\n            remoteRtxPayloadType: undefined,\n            localParameters: matchingLocalCodec.parameters,\n            remoteParameters: remoteCodec.parameters,\n            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)\n        };\n        extendedRtpCapabilities.codecs.push(extendedCodec);\n    }\n    // Match RTX codecs.\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        const matchingLocalRtxCodec = localCaps.codecs\n            .find((localCodec) => (isRtxCodec(localCodec) &&\n            localCodec.parameters.apt === extendedCodec.localPayloadType));\n        const matchingRemoteRtxCodec = remoteCaps.codecs\n            .find((remoteCodec) => (isRtxCodec(remoteCodec) &&\n            remoteCodec.parameters.apt === extendedCodec.remotePayloadType));\n        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {\n            extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;\n            extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;\n        }\n    }\n    // Match header extensions.\n    for (const remoteExt of remoteCaps.headerExtensions) {\n        const matchingLocalExt = localCaps.headerExtensions\n            .find((localExt) => (matchHeaderExtensions(localExt, remoteExt)));\n        if (!matchingLocalExt)\n            continue;\n        const extendedExt = {\n            kind: remoteExt.kind,\n            uri: remoteExt.uri,\n            sendId: matchingLocalExt.preferredId,\n            recvId: remoteExt.preferredId,\n            encrypt: matchingLocalExt.preferredEncrypt,\n            direction: 'sendrecv'\n        };\n        switch (remoteExt.direction) {\n            case 'sendrecv':\n                extendedExt.direction = 'sendrecv';\n                break;\n            case 'recvonly':\n                extendedExt.direction = 'sendonly';\n                break;\n            case 'sendonly':\n                extendedExt.direction = 'recvonly';\n                break;\n            case 'inactive':\n                extendedExt.direction = 'inactive';\n                break;\n        }\n        extendedRtpCapabilities.headerExtensions.push(extendedExt);\n    }\n    return extendedRtpCapabilities;\n}\nexports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;\n/**\n * Generate RTP capabilities for receiving media based on the given extended\n * RTP capabilities.\n */\nfunction getRecvRtpCapabilities(extendedRtpCapabilities) {\n    const rtpCapabilities = {\n        codecs: [],\n        headerExtensions: []\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            kind: extendedCodec.kind,\n            preferredPayloadType: extendedCodec.remotePayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.localParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback\n        };\n        rtpCapabilities.codecs.push(codec);\n        // Add RTX codec.\n        if (!extendedCodec.remoteRtxPayloadType)\n            continue;\n        const rtxCodec = {\n            mimeType: `${extendedCodec.kind}/rtx`,\n            kind: extendedCodec.kind,\n            preferredPayloadType: extendedCodec.remoteRtxPayloadType,\n            clockRate: extendedCodec.clockRate,\n            parameters: {\n                apt: extendedCodec.remotePayloadType\n            },\n            rtcpFeedback: []\n        };\n        rtpCapabilities.codecs.push(rtxCodec);\n        // TODO: In the future, we need to add FEC, CN, etc, codecs.\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions not valid for receiving.\n        if (extendedExtension.direction !== 'sendrecv' &&\n            extendedExtension.direction !== 'recvonly') {\n            continue;\n        }\n        const ext = {\n            kind: extendedExtension.kind,\n            uri: extendedExtension.uri,\n            preferredId: extendedExtension.recvId,\n            preferredEncrypt: extendedExtension.encrypt,\n            direction: extendedExtension.direction\n        };\n        rtpCapabilities.headerExtensions.push(ext);\n    }\n    return rtpCapabilities;\n}\nexports.getRecvRtpCapabilities = getRecvRtpCapabilities;\n/**\n * Generate RTP parameters of the given kind for sending media.\n * NOTE: mid, encodings and rtcp fields are left empty.\n */\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities) {\n    const rtpParameters = {\n        mid: undefined,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [],\n        rtcp: {}\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        if (extendedCodec.kind !== kind)\n            continue;\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            payloadType: extendedCodec.localPayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.localParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback\n        };\n        rtpParameters.codecs.push(codec);\n        // Add RTX codec.\n        if (extendedCodec.localRtxPayloadType) {\n            const rtxCodec = {\n                mimeType: `${extendedCodec.kind}/rtx`,\n                payloadType: extendedCodec.localRtxPayloadType,\n                clockRate: extendedCodec.clockRate,\n                parameters: {\n                    apt: extendedCodec.localPayloadType\n                },\n                rtcpFeedback: []\n            };\n            rtpParameters.codecs.push(rtxCodec);\n        }\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions of a different kind and those not valid for sending.\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\n            (extendedExtension.direction !== 'sendrecv' &&\n                extendedExtension.direction !== 'sendonly')) {\n            continue;\n        }\n        const ext = {\n            uri: extendedExtension.uri,\n            id: extendedExtension.sendId,\n            encrypt: extendedExtension.encrypt,\n            parameters: {}\n        };\n        rtpParameters.headerExtensions.push(ext);\n    }\n    return rtpParameters;\n}\nexports.getSendingRtpParameters = getSendingRtpParameters;\n/**\n * Generate RTP parameters of the given kind suitable for the remote SDP answer.\n */\nfunction getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {\n    const rtpParameters = {\n        mid: undefined,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [],\n        rtcp: {}\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        if (extendedCodec.kind !== kind)\n            continue;\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            payloadType: extendedCodec.localPayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.remoteParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback\n        };\n        rtpParameters.codecs.push(codec);\n        // Add RTX codec.\n        if (extendedCodec.localRtxPayloadType) {\n            const rtxCodec = {\n                mimeType: `${extendedCodec.kind}/rtx`,\n                payloadType: extendedCodec.localRtxPayloadType,\n                clockRate: extendedCodec.clockRate,\n                parameters: {\n                    apt: extendedCodec.localPayloadType\n                },\n                rtcpFeedback: []\n            };\n            rtpParameters.codecs.push(rtxCodec);\n        }\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions of a different kind and those not valid for sending.\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\n            (extendedExtension.direction !== 'sendrecv' &&\n                extendedExtension.direction !== 'sendonly')) {\n            continue;\n        }\n        const ext = {\n            uri: extendedExtension.uri,\n            id: extendedExtension.sendId,\n            encrypt: extendedExtension.encrypt,\n            parameters: {}\n        };\n        rtpParameters.headerExtensions.push(ext);\n    }\n    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.\n    if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01'))) {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\n                .filter((fb) => fb.type !== 'goog-remb');\n        }\n    }\n    else if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time'))) {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\n                .filter((fb) => fb.type !== 'transport-cc');\n        }\n    }\n    else {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\n                .filter((fb) => (fb.type !== 'transport-cc' &&\n                fb.type !== 'goog-remb'));\n        }\n    }\n    return rtpParameters;\n}\nexports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;\n/**\n * Reduce given codecs by returning an array of codecs \"compatible\" with the\n * given capability codec. If no capability codec is given, take the first\n * one(s).\n *\n * Given codecs must be generated by ortc.getSendingRtpParameters() or\n * ortc.getSendingRemoteRtpParameters().\n *\n * The returned array of codecs also include a RTX codec if available.\n */\nfunction reduceCodecs(codecs, capCodec) {\n    const filteredCodecs = [];\n    // If no capability codec is given, take the first one (and RTX).\n    if (!capCodec) {\n        filteredCodecs.push(codecs[0]);\n        if (isRtxCodec(codecs[1]))\n            filteredCodecs.push(codecs[1]);\n    }\n    // Otherwise look for a compatible set of codecs.\n    else {\n        for (let idx = 0; idx < codecs.length; ++idx) {\n            if (matchCodecs(codecs[idx], capCodec)) {\n                filteredCodecs.push(codecs[idx]);\n                if (isRtxCodec(codecs[idx + 1]))\n                    filteredCodecs.push(codecs[idx + 1]);\n                break;\n            }\n        }\n        if (filteredCodecs.length === 0)\n            throw new TypeError('no matching codec found');\n    }\n    return filteredCodecs;\n}\nexports.reduceCodecs = reduceCodecs;\n/**\n * Create RTP parameters for a Consumer for the RTP probator.\n */\nfunction generateProbatorRtpParameters(videoRtpParameters) {\n    // Clone given reference video RTP parameters.\n    videoRtpParameters = utils_1.clone(videoRtpParameters);\n    // This may throw.\n    validateRtpParameters(videoRtpParameters);\n    const rtpParameters = {\n        mid: RTP_PROBATOR_MID,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [{ ssrc: RTP_PROBATOR_SSRC }],\n        rtcp: { cname: 'probator' }\n    };\n    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);\n    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;\n    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;\n    return rtpParameters;\n}\nexports.generateProbatorRtpParameters = generateProbatorRtpParameters;\n/**\n * Whether media can be sent based on the given RTP capabilities.\n */\nfunction canSend(kind, extendedRtpCapabilities) {\n    return extendedRtpCapabilities.codecs.\n        some((codec) => codec.kind === kind);\n}\nexports.canSend = canSend;\n/**\n * Whether the given RTP parameters can be received with the given RTP\n * capabilities.\n */\nfunction canReceive(rtpParameters, extendedRtpCapabilities) {\n    // This may throw.\n    validateRtpParameters(rtpParameters);\n    if (rtpParameters.codecs.length === 0)\n        return false;\n    const firstMediaCodec = rtpParameters.codecs[0];\n    return extendedRtpCapabilities.codecs\n        .some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);\n}\nexports.canReceive = canReceive;\nfunction isRtxCodec(codec) {\n    if (!codec)\n        return false;\n    return /.+\\/rtx$/i.test(codec.mimeType);\n}\nfunction matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {\n    const aMimeType = aCodec.mimeType.toLowerCase();\n    const bMimeType = bCodec.mimeType.toLowerCase();\n    if (aMimeType !== bMimeType)\n        return false;\n    if (aCodec.clockRate !== bCodec.clockRate)\n        return false;\n    if (aCodec.channels !== bCodec.channels)\n        return false;\n    // Per codec special checks.\n    switch (aMimeType) {\n        case 'video/h264':\n            {\n                const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;\n                const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;\n                if (aPacketizationMode !== bPacketizationMode)\n                    return false;\n                // If strict matching check profile-level-id.\n                if (strict) {\n                    if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters))\n                        return false;\n                    let selectedProfileLevelId;\n                    try {\n                        selectedProfileLevelId =\n                            h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);\n                    }\n                    catch (error) {\n                        return false;\n                    }\n                    if (modify) {\n                        if (selectedProfileLevelId)\n                            aCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n                        else\n                            delete aCodec.parameters['profile-level-id'];\n                    }\n                }\n                break;\n            }\n        case 'video/vp9':\n            {\n                // If strict matching check profile-id.\n                if (strict) {\n                    const aProfileId = aCodec.parameters['profile-id'] || 0;\n                    const bProfileId = bCodec.parameters['profile-id'] || 0;\n                    if (aProfileId !== bProfileId)\n                        return false;\n                }\n                break;\n            }\n    }\n    return true;\n}\nfunction matchHeaderExtensions(aExt, bExt) {\n    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind)\n        return false;\n    if (aExt.uri !== bExt.uri)\n        return false;\n    return true;\n}\nfunction reduceRtcpFeedback(codecA, codecB) {\n    const reducedRtcpFeedback = [];\n    for (const aFb of codecA.rtcpFeedback || []) {\n        const matchingBFb = (codecB.rtcpFeedback || [])\n            .find((bFb) => (bFb.type === aFb.type &&\n            (bFb.parameter === aFb.parameter || (!bFb.parameter && !aFb.parameter))));\n        if (matchingBFb)\n            reducedRtcpFeedback.push(matchingBFb);\n    }\n    return reducedRtcpFeedback;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvb3J0Yy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3J4X3NvY2tldGlvX2NsaWVudC8uL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9vcnRjLmpzP2ZlYmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBoMjY0ID0gcmVxdWlyZShcImgyNjQtcHJvZmlsZS1sZXZlbC1pZFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IFJUUF9QUk9CQVRPUl9NSUQgPSAncHJvYmF0b3InO1xuY29uc3QgUlRQX1BST0JBVE9SX1NTUkMgPSAxMjM0O1xuY29uc3QgUlRQX1BST0JBVE9SX0NPREVDX1BBWUxPQURfVFlQRSA9IDEyNztcbi8qKlxuICogVmFsaWRhdGVzIFJ0cENhcGFiaWxpdGllcy4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJ0cENhcGFiaWxpdGllcyhjYXBzKSB7XG4gICAgaWYgKHR5cGVvZiBjYXBzICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FwcyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgLy8gY29kZWNzIGlzIG9wdGlvbmFsLiBJZiB1bnNldCwgZmlsbCB3aXRoIGFuIGVtcHR5IGFycmF5LlxuICAgIGlmIChjYXBzLmNvZGVjcyAmJiAhQXJyYXkuaXNBcnJheShjYXBzLmNvZGVjcykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhcHMuY29kZWNzIGlzIG5vdCBhbiBhcnJheScpO1xuICAgIGVsc2UgaWYgKCFjYXBzLmNvZGVjcylcbiAgICAgICAgY2Fwcy5jb2RlY3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGNhcHMuY29kZWNzKSB7XG4gICAgICAgIHZhbGlkYXRlUnRwQ29kZWNDYXBhYmlsaXR5KGNvZGVjKTtcbiAgICB9XG4gICAgLy8gaGVhZGVyRXh0ZW5zaW9ucyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIGZpbGwgd2l0aCBhbiBlbXB0eSBhcnJheS5cbiAgICBpZiAoY2Fwcy5oZWFkZXJFeHRlbnNpb25zICYmICFBcnJheS5pc0FycmF5KGNhcHMuaGVhZGVyRXh0ZW5zaW9ucykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhcHMuaGVhZGVyRXh0ZW5zaW9ucyBpcyBub3QgYW4gYXJyYXknKTtcbiAgICBlbHNlIGlmICghY2Fwcy5oZWFkZXJFeHRlbnNpb25zKVxuICAgICAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGV4dCBvZiBjYXBzLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICAgICAgdmFsaWRhdGVSdHBIZWFkZXJFeHRlbnNpb24oZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUnRwQ2FwYWJpbGl0aWVzID0gdmFsaWRhdGVSdHBDYXBhYmlsaXRpZXM7XG4vKipcbiAqIFZhbGlkYXRlcyBSdHBDb2RlY0NhcGFiaWxpdHkuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSdHBDb2RlY0NhcGFiaWxpdHkoY29kZWMpIHtcbiAgICBjb25zdCBNaW1lVHlwZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXihhdWRpb3x2aWRlbykvKC4rKScsICdpJyk7XG4gICAgaWYgKHR5cGVvZiBjb2RlYyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvZGVjIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAvLyBtaW1lVHlwZSBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKCFjb2RlYy5taW1lVHlwZSB8fCB0eXBlb2YgY29kZWMubWltZVR5cGUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGNvZGVjLm1pbWVUeXBlJyk7XG4gICAgY29uc3QgbWltZVR5cGVNYXRjaCA9IE1pbWVUeXBlUmVnZXguZXhlYyhjb2RlYy5taW1lVHlwZSk7XG4gICAgaWYgKCFtaW1lVHlwZU1hdGNoKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGNvZGVjLm1pbWVUeXBlJyk7XG4gICAgLy8gSnVzdCBvdmVycmlkZSBraW5kIHdpdGggbWVkaWEgY29tcG9uZW50IG9mIG1pbWVUeXBlLlxuICAgIGNvZGVjLmtpbmQgPSBtaW1lVHlwZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gcHJlZmVycmVkUGF5bG9hZFR5cGUgaXMgb3B0aW9uYWwuXG4gICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICYmIHR5cGVvZiBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUnKTtcbiAgICAvLyBjbG9ja1JhdGUgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgY29kZWMuY2xvY2tSYXRlICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBjb2RlYy5jbG9ja1JhdGUnKTtcbiAgICAvLyBjaGFubmVscyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byAxIChqdXN0IGlmIGF1ZGlvKS5cbiAgICBpZiAoY29kZWMua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBpZiAodHlwZW9mIGNvZGVjLmNoYW5uZWxzICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIGNvZGVjLmNoYW5uZWxzID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBjb2RlYy5jaGFubmVscztcbiAgICB9XG4gICAgLy8gcGFyYW1ldGVycyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byBhbiBlbXB0eSBvYmplY3QuXG4gICAgaWYgKCFjb2RlYy5wYXJhbWV0ZXJzIHx8IHR5cGVvZiBjb2RlYy5wYXJhbWV0ZXJzICE9PSAnb2JqZWN0JylcbiAgICAgICAgY29kZWMucGFyYW1ldGVycyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGNvZGVjLnBhcmFtZXRlcnNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvZGVjLnBhcmFtZXRlcnNba2V5XSA9ICcnO1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGNvZGVjIHBhcmFtZXRlciBba2V5OiR7a2V5fXMsIHZhbHVlOiR7dmFsdWV9XWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwZWNpZmljIHBhcmFtZXRlcnMgdmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2FwdCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY29kZWMgYXB0IHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJ0Y3BGZWVkYmFjayBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byBhbiBlbXB0eSBhcnJheS5cbiAgICBpZiAoIWNvZGVjLnJ0Y3BGZWVkYmFjayB8fCAhQXJyYXkuaXNBcnJheShjb2RlYy5ydGNwRmVlZGJhY2spKVxuICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZiIG9mIGNvZGVjLnJ0Y3BGZWVkYmFjaykge1xuICAgICAgICB2YWxpZGF0ZVJ0Y3BGZWVkYmFjayhmYik7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVJ0cENvZGVjQ2FwYWJpbGl0eSA9IHZhbGlkYXRlUnRwQ29kZWNDYXBhYmlsaXR5O1xuLyoqXG4gKiBWYWxpZGF0ZXMgUnRjcEZlZWRiYWNrLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRjcEZlZWRiYWNrKGZiKSB7XG4gICAgaWYgKHR5cGVvZiBmYiAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZiIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAvLyB0eXBlIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAoIWZiLnR5cGUgfHwgdHlwZW9mIGZiLnR5cGUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGZiLnR5cGUnKTtcbiAgICAvLyBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwuIElmIHVuc2V0IHNldCBpdCB0byBhbiBlbXB0eSBzdHJpbmcuXG4gICAgaWYgKCFmYi5wYXJhbWV0ZXIgfHwgdHlwZW9mIGZiLnBhcmFtZXRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgIGZiLnBhcmFtZXRlciA9ICcnO1xufVxuZXhwb3J0cy52YWxpZGF0ZVJ0Y3BGZWVkYmFjayA9IHZhbGlkYXRlUnRjcEZlZWRiYWNrO1xuLyoqXG4gKiBWYWxpZGF0ZXMgUnRwSGVhZGVyRXh0ZW5zaW9uLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRwSGVhZGVyRXh0ZW5zaW9uKGV4dCkge1xuICAgIGlmICh0eXBlb2YgZXh0ICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXh0IGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAvLyBraW5kIGlzIG9wdGlvbmFsLiBJZiB1bnNldCBzZXQgaXQgdG8gYW4gZW1wdHkgc3RyaW5nLlxuICAgIGlmICghZXh0LmtpbmQgfHwgdHlwZW9mIGV4dC5raW5kICE9PSAnc3RyaW5nJylcbiAgICAgICAgZXh0LmtpbmQgPSAnJztcbiAgICBpZiAoZXh0LmtpbmQgIT09ICcnICYmIGV4dC5raW5kICE9PSAnYXVkaW8nICYmIGV4dC5raW5kICE9PSAndmlkZW8nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGV4dC5raW5kJyk7XG4gICAgLy8gdXJpIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAoIWV4dC51cmkgfHwgdHlwZW9mIGV4dC51cmkgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGV4dC51cmknKTtcbiAgICAvLyBwcmVmZXJyZWRJZCBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKHR5cGVvZiBleHQucHJlZmVycmVkSWQgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGV4dC5wcmVmZXJyZWRJZCcpO1xuICAgIC8vIHByZWZlcnJlZEVuY3J5cHQgaXMgb3B0aW9uYWwuIElmIHVuc2V0IHNldCBpdCB0byBmYWxzZS5cbiAgICBpZiAoZXh0LnByZWZlcnJlZEVuY3J5cHQgJiYgdHlwZW9mIGV4dC5wcmVmZXJyZWRFbmNyeXB0ICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZXh0LnByZWZlcnJlZEVuY3J5cHQnKTtcbiAgICBlbHNlIGlmICghZXh0LnByZWZlcnJlZEVuY3J5cHQpXG4gICAgICAgIGV4dC5wcmVmZXJyZWRFbmNyeXB0ID0gZmFsc2U7XG4gICAgLy8gZGlyZWN0aW9uIGlzIG9wdGlvbmFsLiBJZiB1bnNldCBzZXQgaXQgdG8gc2VuZHJlY3YuXG4gICAgaWYgKGV4dC5kaXJlY3Rpb24gJiYgdHlwZW9mIGV4dC5kaXJlY3Rpb24gIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGV4dC5kaXJlY3Rpb24nKTtcbiAgICBlbHNlIGlmICghZXh0LmRpcmVjdGlvbilcbiAgICAgICAgZXh0LmRpcmVjdGlvbiA9ICdzZW5kcmVjdic7XG59XG5leHBvcnRzLnZhbGlkYXRlUnRwSGVhZGVyRXh0ZW5zaW9uID0gdmFsaWRhdGVSdHBIZWFkZXJFeHRlbnNpb247XG4vKipcbiAqIFZhbGlkYXRlcyBSdHBQYXJhbWV0ZXJzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRwUGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtcyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgLy8gbWlkIGlzIG9wdGlvbmFsLlxuICAgIGlmIChwYXJhbXMubWlkICYmIHR5cGVvZiBwYXJhbXMubWlkICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1zLm1pZCBpcyBub3QgYSBzdHJpbmcnKTtcbiAgICAvLyBjb2RlY3MgaXMgbWFuZGF0b3J5LlxuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMuY29kZWNzKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBwYXJhbXMuY29kZWNzJyk7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBwYXJhbXMuY29kZWNzKSB7XG4gICAgICAgIHZhbGlkYXRlUnRwQ29kZWNQYXJhbWV0ZXJzKGNvZGVjKTtcbiAgICB9XG4gICAgLy8gaGVhZGVyRXh0ZW5zaW9ucyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIGZpbGwgd2l0aCBhbiBlbXB0eSBhcnJheS5cbiAgICBpZiAocGFyYW1zLmhlYWRlckV4dGVuc2lvbnMgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zLmhlYWRlckV4dGVuc2lvbnMpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMuaGVhZGVyRXh0ZW5zaW9ucyBpcyBub3QgYW4gYXJyYXknKTtcbiAgICBlbHNlIGlmICghcGFyYW1zLmhlYWRlckV4dGVuc2lvbnMpXG4gICAgICAgIHBhcmFtcy5oZWFkZXJFeHRlbnNpb25zID0gW107XG4gICAgZm9yIChjb25zdCBleHQgb2YgcGFyYW1zLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICAgICAgdmFsaWRhdGVSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzKGV4dCk7XG4gICAgfVxuICAgIC8vIGVuY29kaW5ncyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIGZpbGwgd2l0aCBhbiBlbXB0eSBhcnJheS5cbiAgICBpZiAocGFyYW1zLmVuY29kaW5ncyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMuZW5jb2RpbmdzKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1zLmVuY29kaW5ncyBpcyBub3QgYW4gYXJyYXknKTtcbiAgICBlbHNlIGlmICghcGFyYW1zLmVuY29kaW5ncylcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IFtdO1xuICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2YgcGFyYW1zLmVuY29kaW5ncykge1xuICAgICAgICB2YWxpZGF0ZVJ0cEVuY29kaW5nUGFyYW1ldGVycyhlbmNvZGluZyk7XG4gICAgfVxuICAgIC8vIHJ0Y3AgaXMgb3B0aW9uYWwuIElmIHVuc2V0LCBmaWxsIHdpdGggYW4gZW1wdHkgb2JqZWN0LlxuICAgIGlmIChwYXJhbXMucnRjcCAmJiB0eXBlb2YgcGFyYW1zLnJ0Y3AgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMucnRjcCBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgZWxzZSBpZiAoIXBhcmFtcy5ydGNwKVxuICAgICAgICBwYXJhbXMucnRjcCA9IHt9O1xuICAgIHZhbGlkYXRlUnRjcFBhcmFtZXRlcnMocGFyYW1zLnJ0Y3ApO1xufVxuZXhwb3J0cy52YWxpZGF0ZVJ0cFBhcmFtZXRlcnMgPSB2YWxpZGF0ZVJ0cFBhcmFtZXRlcnM7XG4vKipcbiAqIFZhbGlkYXRlcyBSdHBDb2RlY1BhcmFtZXRlcnMuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSdHBDb2RlY1BhcmFtZXRlcnMoY29kZWMpIHtcbiAgICBjb25zdCBNaW1lVHlwZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXihhdWRpb3x2aWRlbykvKC4rKScsICdpJyk7XG4gICAgaWYgKHR5cGVvZiBjb2RlYyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvZGVjIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAvLyBtaW1lVHlwZSBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKCFjb2RlYy5taW1lVHlwZSB8fCB0eXBlb2YgY29kZWMubWltZVR5cGUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGNvZGVjLm1pbWVUeXBlJyk7XG4gICAgY29uc3QgbWltZVR5cGVNYXRjaCA9IE1pbWVUeXBlUmVnZXguZXhlYyhjb2RlYy5taW1lVHlwZSk7XG4gICAgaWYgKCFtaW1lVHlwZU1hdGNoKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGNvZGVjLm1pbWVUeXBlJyk7XG4gICAgLy8gcGF5bG9hZFR5cGUgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgY29kZWMucGF5bG9hZFR5cGUgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGNvZGVjLnBheWxvYWRUeXBlJyk7XG4gICAgLy8gY2xvY2tSYXRlIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIGNvZGVjLmNsb2NrUmF0ZSAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgY29kZWMuY2xvY2tSYXRlJyk7XG4gICAgY29uc3Qga2luZCA9IG1pbWVUeXBlTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAvLyBjaGFubmVscyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byAxIChqdXN0IGlmIGF1ZGlvKS5cbiAgICBpZiAoa2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBpZiAodHlwZW9mIGNvZGVjLmNoYW5uZWxzICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIGNvZGVjLmNoYW5uZWxzID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBjb2RlYy5jaGFubmVscztcbiAgICB9XG4gICAgLy8gcGFyYW1ldGVycyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byBhbiBlbXB0eSBvYmplY3QuXG4gICAgaWYgKCFjb2RlYy5wYXJhbWV0ZXJzIHx8IHR5cGVvZiBjb2RlYy5wYXJhbWV0ZXJzICE9PSAnb2JqZWN0JylcbiAgICAgICAgY29kZWMucGFyYW1ldGVycyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGNvZGVjLnBhcmFtZXRlcnNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvZGVjLnBhcmFtZXRlcnNba2V5XSA9ICcnO1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGNvZGVjIHBhcmFtZXRlciBba2V5OiR7a2V5fXMsIHZhbHVlOiR7dmFsdWV9XWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwZWNpZmljIHBhcmFtZXRlcnMgdmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2FwdCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY29kZWMgYXB0IHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJ0Y3BGZWVkYmFjayBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byBhbiBlbXB0eSBhcnJheS5cbiAgICBpZiAoIWNvZGVjLnJ0Y3BGZWVkYmFjayB8fCAhQXJyYXkuaXNBcnJheShjb2RlYy5ydGNwRmVlZGJhY2spKVxuICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZiIG9mIGNvZGVjLnJ0Y3BGZWVkYmFjaykge1xuICAgICAgICB2YWxpZGF0ZVJ0Y3BGZWVkYmFjayhmYik7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVJ0cENvZGVjUGFyYW1ldGVycyA9IHZhbGlkYXRlUnRwQ29kZWNQYXJhbWV0ZXJzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGV0ZXJzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGVycyhleHQpIHtcbiAgICBpZiAodHlwZW9mIGV4dCAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4dCBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgLy8gdXJpIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAoIWV4dC51cmkgfHwgdHlwZW9mIGV4dC51cmkgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGV4dC51cmknKTtcbiAgICAvLyBpZCBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKHR5cGVvZiBleHQuaWQgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGV4dC5pZCcpO1xuICAgIC8vIGVuY3J5cHQgaXMgb3B0aW9uYWwuIElmIHVuc2V0IHNldCBpdCB0byBmYWxzZS5cbiAgICBpZiAoZXh0LmVuY3J5cHQgJiYgdHlwZW9mIGV4dC5lbmNyeXB0ICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZXh0LmVuY3J5cHQnKTtcbiAgICBlbHNlIGlmICghZXh0LmVuY3J5cHQpXG4gICAgICAgIGV4dC5lbmNyeXB0ID0gZmFsc2U7XG4gICAgLy8gcGFyYW1ldGVycyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byBhbiBlbXB0eSBvYmplY3QuXG4gICAgaWYgKCFleHQucGFyYW1ldGVycyB8fCB0eXBlb2YgZXh0LnBhcmFtZXRlcnMgIT09ICdvYmplY3QnKVxuICAgICAgICBleHQucGFyYW1ldGVycyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGV4dC5wYXJhbWV0ZXJzKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBleHQucGFyYW1ldGVyc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXh0LnBhcmFtZXRlcnNba2V5XSA9ICcnO1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBoZWFkZXIgZXh0ZW5zaW9uIHBhcmFtZXRlcicpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzID0gdmFsaWRhdGVSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgUnRwRW5jb2RpbmdQYXJhbWV0ZXJzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGVuY29kaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAvLyBzc3JjIGlzIG9wdGlvbmFsLlxuICAgIGlmIChlbmNvZGluZy5zc3JjICYmIHR5cGVvZiBlbmNvZGluZy5zc3JjICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBlbmNvZGluZy5zc3JjJyk7XG4gICAgLy8gcmlkIGlzIG9wdGlvbmFsLlxuICAgIGlmIChlbmNvZGluZy5yaWQgJiYgdHlwZW9mIGVuY29kaW5nLnJpZCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZW5jb2RpbmcucmlkJyk7XG4gICAgLy8gcnR4IGlzIG9wdGlvbmFsLlxuICAgIGlmIChlbmNvZGluZy5ydHggJiYgdHlwZW9mIGVuY29kaW5nLnJ0eCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBlbmNvZGluZy5ydHgnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5jb2RpbmcucnR4KSB7XG4gICAgICAgIC8vIFJUWCBzc3JjIGlzIG1hbmRhdG9yeSBpZiBydHggaXMgcHJlc2VudC5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5ydHguc3NyYyAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGVuY29kaW5nLnJ0eC5zc3JjJyk7XG4gICAgfVxuICAgIC8vIGR0eCBpcyBvcHRpb25hbC4gSWYgdW5zZXQgc2V0IGl0IHRvIGZhbHNlLlxuICAgIGlmICghZW5jb2RpbmcuZHR4IHx8IHR5cGVvZiBlbmNvZGluZy5kdHggIT09ICdib29sZWFuJylcbiAgICAgICAgZW5jb2RpbmcuZHR4ID0gZmFsc2U7XG4gICAgLy8gc2NhbGFiaWxpdHlNb2RlIGlzIG9wdGlvbmFsLlxuICAgIGlmIChlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgJiYgdHlwZW9mIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlJyk7XG59XG5leHBvcnRzLnZhbGlkYXRlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzID0gdmFsaWRhdGVSdHBFbmNvZGluZ1BhcmFtZXRlcnM7XG4vKipcbiAqIFZhbGlkYXRlcyBSdGNwUGFyYW1ldGVycy4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJ0Y3BQYXJhbWV0ZXJzKHJ0Y3ApIHtcbiAgICBpZiAodHlwZW9mIHJ0Y3AgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdydGNwIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAvLyBjbmFtZSBpcyBvcHRpb25hbC5cbiAgICBpZiAocnRjcC5jbmFtZSAmJiB0eXBlb2YgcnRjcC5jbmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcnRjcC5jbmFtZScpO1xuICAgIC8vIHJlZHVjZWRTaXplIGlzIG9wdGlvbmFsLiBJZiB1bnNldCBzZXQgaXQgdG8gdHJ1ZS5cbiAgICBpZiAoIXJ0Y3AucmVkdWNlZFNpemUgfHwgdHlwZW9mIHJ0Y3AucmVkdWNlZFNpemUgIT09ICdib29sZWFuJylcbiAgICAgICAgcnRjcC5yZWR1Y2VkU2l6ZSA9IHRydWU7XG59XG5leHBvcnRzLnZhbGlkYXRlUnRjcFBhcmFtZXRlcnMgPSB2YWxpZGF0ZVJ0Y3BQYXJhbWV0ZXJzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgU2N0cENhcGFiaWxpdGllcy4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNjdHBDYXBhYmlsaXRpZXMoY2Fwcykge1xuICAgIGlmICh0eXBlb2YgY2FwcyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhcHMgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgIC8vIG51bVN0cmVhbXMgaXMgbWFuZGF0b3J5LlxuICAgIGlmICghY2Fwcy5udW1TdHJlYW1zIHx8IHR5cGVvZiBjYXBzLm51bVN0cmVhbXMgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGNhcHMubnVtU3RyZWFtcycpO1xuICAgIHZhbGlkYXRlTnVtU2N0cFN0cmVhbXMoY2Fwcy5udW1TdHJlYW1zKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVTY3RwQ2FwYWJpbGl0aWVzID0gdmFsaWRhdGVTY3RwQ2FwYWJpbGl0aWVzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgTnVtU2N0cFN0cmVhbXMuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVOdW1TY3RwU3RyZWFtcyhudW1TdHJlYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBudW1TdHJlYW1zICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbnVtU3RyZWFtcyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgLy8gT1MgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgbnVtU3RyZWFtcy5PUyAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgbnVtU3RyZWFtcy5PUycpO1xuICAgIC8vIE1JUyBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKHR5cGVvZiBudW1TdHJlYW1zLk1JUyAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgbnVtU3RyZWFtcy5NSVMnKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVOdW1TY3RwU3RyZWFtcyA9IHZhbGlkYXRlTnVtU2N0cFN0cmVhbXM7XG4vKipcbiAqIFZhbGlkYXRlcyBTY3RwUGFyYW1ldGVycy4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNjdHBQYXJhbWV0ZXJzKHBhcmFtcykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1zIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAvLyBwb3J0IGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5wb3J0ICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBwYXJhbXMucG9ydCcpO1xuICAgIC8vIE9TIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5PUyAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgcGFyYW1zLk9TJyk7XG4gICAgLy8gTUlTIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5NSVMgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIHBhcmFtcy5NSVMnKTtcbiAgICAvLyBtYXhNZXNzYWdlU2l6ZSBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMubWF4TWVzc2FnZVNpemUgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIHBhcmFtcy5tYXhNZXNzYWdlU2l6ZScpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVNjdHBQYXJhbWV0ZXJzID0gdmFsaWRhdGVTY3RwUGFyYW1ldGVycztcbi8qKlxuICogVmFsaWRhdGVzIFNjdHBTdHJlYW1QYXJhbWV0ZXJzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU2N0cFN0cmVhbVBhcmFtZXRlcnMocGFyYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgIC8vIHN0cmVhbUlkIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5zdHJlYW1JZCAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgcGFyYW1zLnN0cmVhbUlkJyk7XG4gICAgLy8gb3JkZXJlZCBpcyBvcHRpb25hbC5cbiAgICBsZXQgb3JkZXJlZEdpdmVuID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMub3JkZXJlZCA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICBvcmRlcmVkR2l2ZW4gPSB0cnVlO1xuICAgIGVsc2VcbiAgICAgICAgcGFyYW1zLm9yZGVyZWQgPSB0cnVlO1xuICAgIC8vIG1heFBhY2tldExpZmVUaW1lIGlzIG9wdGlvbmFsLlxuICAgIGlmIChwYXJhbXMubWF4UGFja2V0TGlmZVRpbWUgJiYgdHlwZW9mIHBhcmFtcy5tYXhQYWNrZXRMaWZlVGltZSAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGFyYW1zLm1heFBhY2tldExpZmVUaW1lJyk7XG4gICAgLy8gbWF4UmV0cmFuc21pdHMgaXMgb3B0aW9uYWwuXG4gICAgaWYgKHBhcmFtcy5tYXhSZXRyYW5zbWl0cyAmJiB0eXBlb2YgcGFyYW1zLm1heFJldHJhbnNtaXRzICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbXMubWF4UmV0cmFuc21pdHMnKTtcbiAgICBpZiAocGFyYW1zLm1heFBhY2tldExpZmVUaW1lICYmIHBhcmFtcy5tYXhSZXRyYW5zbWl0cylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHByb3ZpZGUgYm90aCBtYXhQYWNrZXRMaWZlVGltZSBhbmQgbWF4UmV0cmFuc21pdHMnKTtcbiAgICBpZiAob3JkZXJlZEdpdmVuICYmXG4gICAgICAgIHBhcmFtcy5vcmRlcmVkICYmXG4gICAgICAgIChwYXJhbXMubWF4UGFja2V0TGlmZVRpbWUgfHwgcGFyYW1zLm1heFJldHJhbnNtaXRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgYmUgb3JkZXJlZCB3aXRoIG1heFBhY2tldExpZmVUaW1lIG9yIG1heFJldHJhbnNtaXRzJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvcmRlcmVkR2l2ZW4gJiYgKHBhcmFtcy5tYXhQYWNrZXRMaWZlVGltZSB8fCBwYXJhbXMubWF4UmV0cmFuc21pdHMpKSB7XG4gICAgICAgIHBhcmFtcy5vcmRlcmVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIHByaW9yaXR5IGlzIG9wdGlvbmFsLlxuICAgIGlmIChwYXJhbXMucHJpb3JpdHkgJiYgdHlwZW9mIHBhcmFtcy5wcmlvcml0eSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGFyYW1zLnByaW9yaXR5Jyk7XG4gICAgLy8gbGFiZWwgaXMgb3B0aW9uYWwuXG4gICAgaWYgKHBhcmFtcy5sYWJlbCAmJiB0eXBlb2YgcGFyYW1zLmxhYmVsICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbXMubGFiZWwnKTtcbiAgICAvLyBwcm90b2NvbCBpcyBvcHRpb25hbC5cbiAgICBpZiAocGFyYW1zLnByb3RvY29sICYmIHR5cGVvZiBwYXJhbXMucHJvdG9jb2wgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtcy5wcm90b2NvbCcpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVNjdHBTdHJlYW1QYXJhbWV0ZXJzID0gdmFsaWRhdGVTY3RwU3RyZWFtUGFyYW1ldGVycztcbi8qKlxuICogR2VuZXJhdGUgZXh0ZW5kZWQgUlRQIGNhcGFiaWxpdGllcyBmb3Igc2VuZGluZyBhbmQgcmVjZWl2aW5nLlxuICovXG5mdW5jdGlvbiBnZXRFeHRlbmRlZFJ0cENhcGFiaWxpdGllcyhsb2NhbENhcHMsIHJlbW90ZUNhcHMpIHtcbiAgICBjb25zdCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyA9IHtcbiAgICAgICAgY29kZWNzOiBbXSxcbiAgICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW11cbiAgICB9O1xuICAgIC8vIE1hdGNoIG1lZGlhIGNvZGVjcyBhbmQga2VlcCB0aGUgb3JkZXIgcHJlZmVycmVkIGJ5IHJlbW90ZUNhcHMuXG4gICAgZm9yIChjb25zdCByZW1vdGVDb2RlYyBvZiByZW1vdGVDYXBzLmNvZGVjcyB8fCBbXSkge1xuICAgICAgICBpZiAoaXNSdHhDb2RlYyhyZW1vdGVDb2RlYykpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdMb2NhbENvZGVjID0gKGxvY2FsQ2Fwcy5jb2RlY3MgfHwgW10pXG4gICAgICAgICAgICAuZmluZCgobG9jYWxDb2RlYykgPT4gKG1hdGNoQ29kZWNzKGxvY2FsQ29kZWMsIHJlbW90ZUNvZGVjLCB7IHN0cmljdDogdHJ1ZSwgbW9kaWZ5OiB0cnVlIH0pKSk7XG4gICAgICAgIGlmICghbWF0Y2hpbmdMb2NhbENvZGVjKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGV4dGVuZGVkQ29kZWMgPSB7XG4gICAgICAgICAgICBtaW1lVHlwZTogbWF0Y2hpbmdMb2NhbENvZGVjLm1pbWVUeXBlLFxuICAgICAgICAgICAga2luZDogbWF0Y2hpbmdMb2NhbENvZGVjLmtpbmQsXG4gICAgICAgICAgICBjbG9ja1JhdGU6IG1hdGNoaW5nTG9jYWxDb2RlYy5jbG9ja1JhdGUsXG4gICAgICAgICAgICBjaGFubmVsczogbWF0Y2hpbmdMb2NhbENvZGVjLmNoYW5uZWxzLFxuICAgICAgICAgICAgbG9jYWxQYXlsb2FkVHlwZTogbWF0Y2hpbmdMb2NhbENvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlLFxuICAgICAgICAgICAgbG9jYWxSdHhQYXlsb2FkVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVtb3RlUGF5bG9hZFR5cGU6IHJlbW90ZUNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlLFxuICAgICAgICAgICAgcmVtb3RlUnR4UGF5bG9hZFR5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxvY2FsUGFyYW1ldGVyczogbWF0Y2hpbmdMb2NhbENvZGVjLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICByZW1vdGVQYXJhbWV0ZXJzOiByZW1vdGVDb2RlYy5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRjcEZlZWRiYWNrOiByZWR1Y2VSdGNwRmVlZGJhY2sobWF0Y2hpbmdMb2NhbENvZGVjLCByZW1vdGVDb2RlYylcbiAgICAgICAgfTtcbiAgICAgICAgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzLnB1c2goZXh0ZW5kZWRDb2RlYyk7XG4gICAgfVxuICAgIC8vIE1hdGNoIFJUWCBjb2RlY3MuXG4gICAgZm9yIChjb25zdCBleHRlbmRlZENvZGVjIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0xvY2FsUnR4Q29kZWMgPSBsb2NhbENhcHMuY29kZWNzXG4gICAgICAgICAgICAuZmluZCgobG9jYWxDb2RlYykgPT4gKGlzUnR4Q29kZWMobG9jYWxDb2RlYykgJiZcbiAgICAgICAgICAgIGxvY2FsQ29kZWMucGFyYW1ldGVycy5hcHQgPT09IGV4dGVuZGVkQ29kZWMubG9jYWxQYXlsb2FkVHlwZSkpO1xuICAgICAgICBjb25zdCBtYXRjaGluZ1JlbW90ZVJ0eENvZGVjID0gcmVtb3RlQ2Fwcy5jb2RlY3NcbiAgICAgICAgICAgIC5maW5kKChyZW1vdGVDb2RlYykgPT4gKGlzUnR4Q29kZWMocmVtb3RlQ29kZWMpICYmXG4gICAgICAgICAgICByZW1vdGVDb2RlYy5wYXJhbWV0ZXJzLmFwdCA9PT0gZXh0ZW5kZWRDb2RlYy5yZW1vdGVQYXlsb2FkVHlwZSkpO1xuICAgICAgICBpZiAobWF0Y2hpbmdMb2NhbFJ0eENvZGVjICYmIG1hdGNoaW5nUmVtb3RlUnR4Q29kZWMpIHtcbiAgICAgICAgICAgIGV4dGVuZGVkQ29kZWMubG9jYWxSdHhQYXlsb2FkVHlwZSA9IG1hdGNoaW5nTG9jYWxSdHhDb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICAgICAgICAgIGV4dGVuZGVkQ29kZWMucmVtb3RlUnR4UGF5bG9hZFR5cGUgPSBtYXRjaGluZ1JlbW90ZVJ0eENvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1hdGNoIGhlYWRlciBleHRlbnNpb25zLlxuICAgIGZvciAoY29uc3QgcmVtb3RlRXh0IG9mIHJlbW90ZUNhcHMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0xvY2FsRXh0ID0gbG9jYWxDYXBzLmhlYWRlckV4dGVuc2lvbnNcbiAgICAgICAgICAgIC5maW5kKChsb2NhbEV4dCkgPT4gKG1hdGNoSGVhZGVyRXh0ZW5zaW9ucyhsb2NhbEV4dCwgcmVtb3RlRXh0KSkpO1xuICAgICAgICBpZiAoIW1hdGNoaW5nTG9jYWxFeHQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgZXh0ZW5kZWRFeHQgPSB7XG4gICAgICAgICAgICBraW5kOiByZW1vdGVFeHQua2luZCxcbiAgICAgICAgICAgIHVyaTogcmVtb3RlRXh0LnVyaSxcbiAgICAgICAgICAgIHNlbmRJZDogbWF0Y2hpbmdMb2NhbEV4dC5wcmVmZXJyZWRJZCxcbiAgICAgICAgICAgIHJlY3ZJZDogcmVtb3RlRXh0LnByZWZlcnJlZElkLFxuICAgICAgICAgICAgZW5jcnlwdDogbWF0Y2hpbmdMb2NhbEV4dC5wcmVmZXJyZWRFbmNyeXB0LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAnc2VuZHJlY3YnXG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAocmVtb3RlRXh0LmRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnc2VuZHJlY3YnOlxuICAgICAgICAgICAgICAgIGV4dGVuZGVkRXh0LmRpcmVjdGlvbiA9ICdzZW5kcmVjdic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZWN2b25seSc6XG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRFeHQuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlbmRvbmx5JzpcbiAgICAgICAgICAgICAgICBleHRlbmRlZEV4dC5kaXJlY3Rpb24gPSAncmVjdm9ubHknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5hY3RpdmUnOlxuICAgICAgICAgICAgICAgIGV4dGVuZGVkRXh0LmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKGV4dGVuZGVkRXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzO1xufVxuZXhwb3J0cy5nZXRFeHRlbmRlZFJ0cENhcGFiaWxpdGllcyA9IGdldEV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzO1xuLyoqXG4gKiBHZW5lcmF0ZSBSVFAgY2FwYWJpbGl0aWVzIGZvciByZWNlaXZpbmcgbWVkaWEgYmFzZWQgb24gdGhlIGdpdmVuIGV4dGVuZGVkXG4gKiBSVFAgY2FwYWJpbGl0aWVzLlxuICovXG5mdW5jdGlvbiBnZXRSZWN2UnRwQ2FwYWJpbGl0aWVzKGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSB7XG4gICAgY29uc3QgcnRwQ2FwYWJpbGl0aWVzID0ge1xuICAgICAgICBjb2RlY3M6IFtdLFxuICAgICAgICBoZWFkZXJFeHRlbnNpb25zOiBbXVxuICAgIH07XG4gICAgZm9yIChjb25zdCBleHRlbmRlZENvZGVjIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgICBjb25zdCBjb2RlYyA9IHtcbiAgICAgICAgICAgIG1pbWVUeXBlOiBleHRlbmRlZENvZGVjLm1pbWVUeXBlLFxuICAgICAgICAgICAga2luZDogZXh0ZW5kZWRDb2RlYy5raW5kLFxuICAgICAgICAgICAgcHJlZmVycmVkUGF5bG9hZFR5cGU6IGV4dGVuZGVkQ29kZWMucmVtb3RlUGF5bG9hZFR5cGUsXG4gICAgICAgICAgICBjbG9ja1JhdGU6IGV4dGVuZGVkQ29kZWMuY2xvY2tSYXRlLFxuICAgICAgICAgICAgY2hhbm5lbHM6IGV4dGVuZGVkQ29kZWMuY2hhbm5lbHMsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBleHRlbmRlZENvZGVjLmxvY2FsUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJ0Y3BGZWVkYmFjazogZXh0ZW5kZWRDb2RlYy5ydGNwRmVlZGJhY2tcbiAgICAgICAgfTtcbiAgICAgICAgcnRwQ2FwYWJpbGl0aWVzLmNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICAgICAgLy8gQWRkIFJUWCBjb2RlYy5cbiAgICAgICAgaWYgKCFleHRlbmRlZENvZGVjLnJlbW90ZVJ0eFBheWxvYWRUeXBlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHJ0eENvZGVjID0ge1xuICAgICAgICAgICAgbWltZVR5cGU6IGAke2V4dGVuZGVkQ29kZWMua2luZH0vcnR4YCxcbiAgICAgICAgICAgIGtpbmQ6IGV4dGVuZGVkQ29kZWMua2luZCxcbiAgICAgICAgICAgIHByZWZlcnJlZFBheWxvYWRUeXBlOiBleHRlbmRlZENvZGVjLnJlbW90ZVJ0eFBheWxvYWRUeXBlLFxuICAgICAgICAgICAgY2xvY2tSYXRlOiBleHRlbmRlZENvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBhcHQ6IGV4dGVuZGVkQ29kZWMucmVtb3RlUGF5bG9hZFR5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHJ0cENhcGFiaWxpdGllcy5jb2RlY3MucHVzaChydHhDb2RlYyk7XG4gICAgICAgIC8vIFRPRE86IEluIHRoZSBmdXR1cmUsIHdlIG5lZWQgdG8gYWRkIEZFQywgQ04sIGV0YywgY29kZWNzLlxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV4dGVuZGVkRXh0ZW5zaW9uIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICAgICAgLy8gSWdub3JlIFJUUCBleHRlbnNpb25zIG5vdCB2YWxpZCBmb3IgcmVjZWl2aW5nLlxuICAgICAgICBpZiAoZXh0ZW5kZWRFeHRlbnNpb24uZGlyZWN0aW9uICE9PSAnc2VuZHJlY3YnICYmXG4gICAgICAgICAgICBleHRlbmRlZEV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdyZWN2b25seScpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4dCA9IHtcbiAgICAgICAgICAgIGtpbmQ6IGV4dGVuZGVkRXh0ZW5zaW9uLmtpbmQsXG4gICAgICAgICAgICB1cmk6IGV4dGVuZGVkRXh0ZW5zaW9uLnVyaSxcbiAgICAgICAgICAgIHByZWZlcnJlZElkOiBleHRlbmRlZEV4dGVuc2lvbi5yZWN2SWQsXG4gICAgICAgICAgICBwcmVmZXJyZWRFbmNyeXB0OiBleHRlbmRlZEV4dGVuc2lvbi5lbmNyeXB0LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBleHRlbmRlZEV4dGVuc2lvbi5kaXJlY3Rpb25cbiAgICAgICAgfTtcbiAgICAgICAgcnRwQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnMucHVzaChleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcnRwQ2FwYWJpbGl0aWVzO1xufVxuZXhwb3J0cy5nZXRSZWN2UnRwQ2FwYWJpbGl0aWVzID0gZ2V0UmVjdlJ0cENhcGFiaWxpdGllcztcbi8qKlxuICogR2VuZXJhdGUgUlRQIHBhcmFtZXRlcnMgb2YgdGhlIGdpdmVuIGtpbmQgZm9yIHNlbmRpbmcgbWVkaWEuXG4gKiBOT1RFOiBtaWQsIGVuY29kaW5ncyBhbmQgcnRjcCBmaWVsZHMgYXJlIGxlZnQgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKGtpbmQsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSB7XG4gICAgY29uc3QgcnRwUGFyYW1ldGVycyA9IHtcbiAgICAgICAgbWlkOiB1bmRlZmluZWQsXG4gICAgICAgIGNvZGVjczogW10sXG4gICAgICAgIGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuICAgICAgICBlbmNvZGluZ3M6IFtdLFxuICAgICAgICBydGNwOiB7fVxuICAgIH07XG4gICAgZm9yIChjb25zdCBleHRlbmRlZENvZGVjIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgICBpZiAoZXh0ZW5kZWRDb2RlYy5raW5kICE9PSBraW5kKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGNvZGVjID0ge1xuICAgICAgICAgICAgbWltZVR5cGU6IGV4dGVuZGVkQ29kZWMubWltZVR5cGUsXG4gICAgICAgICAgICBwYXlsb2FkVHlwZTogZXh0ZW5kZWRDb2RlYy5sb2NhbFBheWxvYWRUeXBlLFxuICAgICAgICAgICAgY2xvY2tSYXRlOiBleHRlbmRlZENvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgIGNoYW5uZWxzOiBleHRlbmRlZENvZGVjLmNoYW5uZWxzLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogZXh0ZW5kZWRDb2RlYy5sb2NhbFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydGNwRmVlZGJhY2s6IGV4dGVuZGVkQ29kZWMucnRjcEZlZWRiYWNrXG4gICAgICAgIH07XG4gICAgICAgIHJ0cFBhcmFtZXRlcnMuY29kZWNzLnB1c2goY29kZWMpO1xuICAgICAgICAvLyBBZGQgUlRYIGNvZGVjLlxuICAgICAgICBpZiAoZXh0ZW5kZWRDb2RlYy5sb2NhbFJ0eFBheWxvYWRUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBydHhDb2RlYyA9IHtcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogYCR7ZXh0ZW5kZWRDb2RlYy5raW5kfS9ydHhgLFxuICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlOiBleHRlbmRlZENvZGVjLmxvY2FsUnR4UGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgY2xvY2tSYXRlOiBleHRlbmRlZENvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGFwdDogZXh0ZW5kZWRDb2RlYy5sb2NhbFBheWxvYWRUeXBlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcnRwUGFyYW1ldGVycy5jb2RlY3MucHVzaChydHhDb2RlYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBleHRlbmRlZEV4dGVuc2lvbiBvZiBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICAgIC8vIElnbm9yZSBSVFAgZXh0ZW5zaW9ucyBvZiBhIGRpZmZlcmVudCBraW5kIGFuZCB0aG9zZSBub3QgdmFsaWQgZm9yIHNlbmRpbmcuXG4gICAgICAgIGlmICgoZXh0ZW5kZWRFeHRlbnNpb24ua2luZCAmJiBleHRlbmRlZEV4dGVuc2lvbi5raW5kICE9PSBraW5kKSB8fFxuICAgICAgICAgICAgKGV4dGVuZGVkRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2JyAmJlxuICAgICAgICAgICAgICAgIGV4dGVuZGVkRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRvbmx5JykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4dCA9IHtcbiAgICAgICAgICAgIHVyaTogZXh0ZW5kZWRFeHRlbnNpb24udXJpLFxuICAgICAgICAgICAgaWQ6IGV4dGVuZGVkRXh0ZW5zaW9uLnNlbmRJZCxcbiAgICAgICAgICAgIGVuY3J5cHQ6IGV4dGVuZGVkRXh0ZW5zaW9uLmVuY3J5cHQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBydHBQYXJhbWV0ZXJzLmhlYWRlckV4dGVuc2lvbnMucHVzaChleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcnRwUGFyYW1ldGVycztcbn1cbmV4cG9ydHMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMgPSBnZXRTZW5kaW5nUnRwUGFyYW1ldGVycztcbi8qKlxuICogR2VuZXJhdGUgUlRQIHBhcmFtZXRlcnMgb2YgdGhlIGdpdmVuIGtpbmQgc3VpdGFibGUgZm9yIHRoZSByZW1vdGUgU0RQIGFuc3dlci5cbiAqL1xuZnVuY3Rpb24gZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoa2luZCwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpIHtcbiAgICBjb25zdCBydHBQYXJhbWV0ZXJzID0ge1xuICAgICAgICBtaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgY29kZWNzOiBbXSxcbiAgICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgICAgIGVuY29kaW5nczogW10sXG4gICAgICAgIHJ0Y3A6IHt9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGV4dGVuZGVkQ29kZWMgb2YgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzKSB7XG4gICAgICAgIGlmIChleHRlbmRlZENvZGVjLmtpbmQgIT09IGtpbmQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgY29kZWMgPSB7XG4gICAgICAgICAgICBtaW1lVHlwZTogZXh0ZW5kZWRDb2RlYy5taW1lVHlwZSxcbiAgICAgICAgICAgIHBheWxvYWRUeXBlOiBleHRlbmRlZENvZGVjLmxvY2FsUGF5bG9hZFR5cGUsXG4gICAgICAgICAgICBjbG9ja1JhdGU6IGV4dGVuZGVkQ29kZWMuY2xvY2tSYXRlLFxuICAgICAgICAgICAgY2hhbm5lbHM6IGV4dGVuZGVkQ29kZWMuY2hhbm5lbHMsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBleHRlbmRlZENvZGVjLnJlbW90ZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydGNwRmVlZGJhY2s6IGV4dGVuZGVkQ29kZWMucnRjcEZlZWRiYWNrXG4gICAgICAgIH07XG4gICAgICAgIHJ0cFBhcmFtZXRlcnMuY29kZWNzLnB1c2goY29kZWMpO1xuICAgICAgICAvLyBBZGQgUlRYIGNvZGVjLlxuICAgICAgICBpZiAoZXh0ZW5kZWRDb2RlYy5sb2NhbFJ0eFBheWxvYWRUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBydHhDb2RlYyA9IHtcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogYCR7ZXh0ZW5kZWRDb2RlYy5raW5kfS9ydHhgLFxuICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlOiBleHRlbmRlZENvZGVjLmxvY2FsUnR4UGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgY2xvY2tSYXRlOiBleHRlbmRlZENvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGFwdDogZXh0ZW5kZWRDb2RlYy5sb2NhbFBheWxvYWRUeXBlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcnRwUGFyYW1ldGVycy5jb2RlY3MucHVzaChydHhDb2RlYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBleHRlbmRlZEV4dGVuc2lvbiBvZiBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICAgIC8vIElnbm9yZSBSVFAgZXh0ZW5zaW9ucyBvZiBhIGRpZmZlcmVudCBraW5kIGFuZCB0aG9zZSBub3QgdmFsaWQgZm9yIHNlbmRpbmcuXG4gICAgICAgIGlmICgoZXh0ZW5kZWRFeHRlbnNpb24ua2luZCAmJiBleHRlbmRlZEV4dGVuc2lvbi5raW5kICE9PSBraW5kKSB8fFxuICAgICAgICAgICAgKGV4dGVuZGVkRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2JyAmJlxuICAgICAgICAgICAgICAgIGV4dGVuZGVkRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRvbmx5JykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4dCA9IHtcbiAgICAgICAgICAgIHVyaTogZXh0ZW5kZWRFeHRlbnNpb24udXJpLFxuICAgICAgICAgICAgaWQ6IGV4dGVuZGVkRXh0ZW5zaW9uLnNlbmRJZCxcbiAgICAgICAgICAgIGVuY3J5cHQ6IGV4dGVuZGVkRXh0ZW5zaW9uLmVuY3J5cHQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBydHBQYXJhbWV0ZXJzLmhlYWRlckV4dGVuc2lvbnMucHVzaChleHQpO1xuICAgIH1cbiAgICAvLyBSZWR1Y2UgY29kZWNzJyBSVENQIGZlZWRiYWNrLiBVc2UgVHJhbnNwb3J0LUNDIGlmIGF2YWlsYWJsZSwgUkVNQiBvdGhlcndpc2UuXG4gICAgaWYgKHJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucy5zb21lKChleHQpID0+IChleHQudXJpID09PSAnaHR0cDovL3d3dy5pZXRmLm9yZy9pZC9kcmFmdC1ob2xtZXItcm1jYXQtdHJhbnNwb3J0LXdpZGUtY2MtZXh0ZW5zaW9ucy0wMScpKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIHJ0cFBhcmFtZXRlcnMuY29kZWNzKSB7XG4gICAgICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSAoY29kZWMucnRjcEZlZWRiYWNrIHx8IFtdKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGZiKSA9PiBmYi50eXBlICE9PSAnZ29vZy1yZW1iJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocnRwUGFyYW1ldGVycy5oZWFkZXJFeHRlbnNpb25zLnNvbWUoKGV4dCkgPT4gKGV4dC51cmkgPT09ICdodHRwOi8vd3d3LndlYnJ0Yy5vcmcvZXhwZXJpbWVudHMvcnRwLWhkcmV4dC9hYnMtc2VuZC10aW1lJykpKSB7XG4gICAgICAgIGZvciAoY29uc3QgY29kZWMgb2YgcnRwUGFyYW1ldGVycy5jb2RlY3MpIHtcbiAgICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IChjb2RlYy5ydGNwRmVlZGJhY2sgfHwgW10pXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZmIpID0+IGZiLnR5cGUgIT09ICd0cmFuc3BvcnQtY2MnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBjb2RlYyBvZiBydHBQYXJhbWV0ZXJzLmNvZGVjcykge1xuICAgICAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrID0gKGNvZGVjLnJ0Y3BGZWVkYmFjayB8fCBbXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChmYikgPT4gKGZiLnR5cGUgIT09ICd0cmFuc3BvcnQtY2MnICYmXG4gICAgICAgICAgICAgICAgZmIudHlwZSAhPT0gJ2dvb2ctcmVtYicpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnRwUGFyYW1ldGVycztcbn1cbmV4cG9ydHMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSBnZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycztcbi8qKlxuICogUmVkdWNlIGdpdmVuIGNvZGVjcyBieSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgY29kZWNzIFwiY29tcGF0aWJsZVwiIHdpdGggdGhlXG4gKiBnaXZlbiBjYXBhYmlsaXR5IGNvZGVjLiBJZiBubyBjYXBhYmlsaXR5IGNvZGVjIGlzIGdpdmVuLCB0YWtlIHRoZSBmaXJzdFxuICogb25lKHMpLlxuICpcbiAqIEdpdmVuIGNvZGVjcyBtdXN0IGJlIGdlbmVyYXRlZCBieSBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCkgb3JcbiAqIG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoKS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgYXJyYXkgb2YgY29kZWNzIGFsc28gaW5jbHVkZSBhIFJUWCBjb2RlYyBpZiBhdmFpbGFibGUuXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZUNvZGVjcyhjb2RlY3MsIGNhcENvZGVjKSB7XG4gICAgY29uc3QgZmlsdGVyZWRDb2RlY3MgPSBbXTtcbiAgICAvLyBJZiBubyBjYXBhYmlsaXR5IGNvZGVjIGlzIGdpdmVuLCB0YWtlIHRoZSBmaXJzdCBvbmUgKGFuZCBSVFgpLlxuICAgIGlmICghY2FwQ29kZWMpIHtcbiAgICAgICAgZmlsdGVyZWRDb2RlY3MucHVzaChjb2RlY3NbMF0pO1xuICAgICAgICBpZiAoaXNSdHhDb2RlYyhjb2RlY3NbMV0pKVxuICAgICAgICAgICAgZmlsdGVyZWRDb2RlY3MucHVzaChjb2RlY3NbMV0pO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UgbG9vayBmb3IgYSBjb21wYXRpYmxlIHNldCBvZiBjb2RlY3MuXG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGNvZGVjcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hDb2RlY3MoY29kZWNzW2lkeF0sIGNhcENvZGVjKSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkQ29kZWNzLnB1c2goY29kZWNzW2lkeF0pO1xuICAgICAgICAgICAgICAgIGlmIChpc1J0eENvZGVjKGNvZGVjc1tpZHggKyAxXSkpXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQ29kZWNzLnB1c2goY29kZWNzW2lkeCArIDFdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyZWRDb2RlY3MubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gbWF0Y2hpbmcgY29kZWMgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkQ29kZWNzO1xufVxuZXhwb3J0cy5yZWR1Y2VDb2RlY3MgPSByZWR1Y2VDb2RlY3M7XG4vKipcbiAqIENyZWF0ZSBSVFAgcGFyYW1ldGVycyBmb3IgYSBDb25zdW1lciBmb3IgdGhlIFJUUCBwcm9iYXRvci5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQcm9iYXRvclJ0cFBhcmFtZXRlcnModmlkZW9SdHBQYXJhbWV0ZXJzKSB7XG4gICAgLy8gQ2xvbmUgZ2l2ZW4gcmVmZXJlbmNlIHZpZGVvIFJUUCBwYXJhbWV0ZXJzLlxuICAgIHZpZGVvUnRwUGFyYW1ldGVycyA9IHV0aWxzXzEuY2xvbmUodmlkZW9SdHBQYXJhbWV0ZXJzKTtcbiAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICB2YWxpZGF0ZVJ0cFBhcmFtZXRlcnModmlkZW9SdHBQYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBydHBQYXJhbWV0ZXJzID0ge1xuICAgICAgICBtaWQ6IFJUUF9QUk9CQVRPUl9NSUQsXG4gICAgICAgIGNvZGVjczogW10sXG4gICAgICAgIGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuICAgICAgICBlbmNvZGluZ3M6IFt7IHNzcmM6IFJUUF9QUk9CQVRPUl9TU1JDIH1dLFxuICAgICAgICBydGNwOiB7IGNuYW1lOiAncHJvYmF0b3InIH1cbiAgICB9O1xuICAgIHJ0cFBhcmFtZXRlcnMuY29kZWNzLnB1c2godmlkZW9SdHBQYXJhbWV0ZXJzLmNvZGVjc1swXSk7XG4gICAgcnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ucGF5bG9hZFR5cGUgPSBSVFBfUFJPQkFUT1JfQ09ERUNfUEFZTE9BRF9UWVBFO1xuICAgIHJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucyA9IHZpZGVvUnRwUGFyYW1ldGVycy5oZWFkZXJFeHRlbnNpb25zO1xuICAgIHJldHVybiBydHBQYXJhbWV0ZXJzO1xufVxuZXhwb3J0cy5nZW5lcmF0ZVByb2JhdG9yUnRwUGFyYW1ldGVycyA9IGdlbmVyYXRlUHJvYmF0b3JSdHBQYXJhbWV0ZXJzO1xuLyoqXG4gKiBXaGV0aGVyIG1lZGlhIGNhbiBiZSBzZW50IGJhc2VkIG9uIHRoZSBnaXZlbiBSVFAgY2FwYWJpbGl0aWVzLlxuICovXG5mdW5jdGlvbiBjYW5TZW5kKGtpbmQsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSB7XG4gICAgcmV0dXJuIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcy5cbiAgICAgICAgc29tZSgoY29kZWMpID0+IGNvZGVjLmtpbmQgPT09IGtpbmQpO1xufVxuZXhwb3J0cy5jYW5TZW5kID0gY2FuU2VuZDtcbi8qKlxuICogV2hldGhlciB0aGUgZ2l2ZW4gUlRQIHBhcmFtZXRlcnMgY2FuIGJlIHJlY2VpdmVkIHdpdGggdGhlIGdpdmVuIFJUUFxuICogY2FwYWJpbGl0aWVzLlxuICovXG5mdW5jdGlvbiBjYW5SZWNlaXZlKHJ0cFBhcmFtZXRlcnMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSB7XG4gICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgdmFsaWRhdGVSdHBQYXJhbWV0ZXJzKHJ0cFBhcmFtZXRlcnMpO1xuICAgIGlmIChydHBQYXJhbWV0ZXJzLmNvZGVjcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBmaXJzdE1lZGlhQ29kZWMgPSBydHBQYXJhbWV0ZXJzLmNvZGVjc1swXTtcbiAgICByZXR1cm4gZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzXG4gICAgICAgIC5zb21lKChjb2RlYykgPT4gY29kZWMucmVtb3RlUGF5bG9hZFR5cGUgPT09IGZpcnN0TWVkaWFDb2RlYy5wYXlsb2FkVHlwZSk7XG59XG5leHBvcnRzLmNhblJlY2VpdmUgPSBjYW5SZWNlaXZlO1xuZnVuY3Rpb24gaXNSdHhDb2RlYyhjb2RlYykge1xuICAgIGlmICghY29kZWMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gLy4rXFwvcnR4JC9pLnRlc3QoY29kZWMubWltZVR5cGUpO1xufVxuZnVuY3Rpb24gbWF0Y2hDb2RlY3MoYUNvZGVjLCBiQ29kZWMsIHsgc3RyaWN0ID0gZmFsc2UsIG1vZGlmeSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGNvbnN0IGFNaW1lVHlwZSA9IGFDb2RlYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGJNaW1lVHlwZSA9IGJDb2RlYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChhTWltZVR5cGUgIT09IGJNaW1lVHlwZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhQ29kZWMuY2xvY2tSYXRlICE9PSBiQ29kZWMuY2xvY2tSYXRlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGFDb2RlYy5jaGFubmVscyAhPT0gYkNvZGVjLmNoYW5uZWxzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gUGVyIGNvZGVjIHNwZWNpYWwgY2hlY2tzLlxuICAgIHN3aXRjaCAoYU1pbWVUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3ZpZGVvL2gyNjQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFQYWNrZXRpemF0aW9uTW9kZSA9IGFDb2RlYy5wYXJhbWV0ZXJzWydwYWNrZXRpemF0aW9uLW1vZGUnXSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJQYWNrZXRpemF0aW9uTW9kZSA9IGJDb2RlYy5wYXJhbWV0ZXJzWydwYWNrZXRpemF0aW9uLW1vZGUnXSB8fCAwO1xuICAgICAgICAgICAgICAgIGlmIChhUGFja2V0aXphdGlvbk1vZGUgIT09IGJQYWNrZXRpemF0aW9uTW9kZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIElmIHN0cmljdCBtYXRjaGluZyBjaGVjayBwcm9maWxlLWxldmVsLWlkLlxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoMjY0LmlzU2FtZVByb2ZpbGUoYUNvZGVjLnBhcmFtZXRlcnMsIGJDb2RlYy5wYXJhbWV0ZXJzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkUHJvZmlsZUxldmVsSWQ7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFByb2ZpbGVMZXZlbElkID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoMjY0LmdlbmVyYXRlUHJvZmlsZUxldmVsSWRGb3JBbnN3ZXIoYUNvZGVjLnBhcmFtZXRlcnMsIGJDb2RlYy5wYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRQcm9maWxlTGV2ZWxJZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29kZWMucGFyYW1ldGVyc1sncHJvZmlsZS1sZXZlbC1pZCddID0gc2VsZWN0ZWRQcm9maWxlTGV2ZWxJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYUNvZGVjLnBhcmFtZXRlcnNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAndmlkZW8vdnA5JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzdHJpY3QgbWF0Y2hpbmcgY2hlY2sgcHJvZmlsZS1pZC5cbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFQcm9maWxlSWQgPSBhQ29kZWMucGFyYW1ldGVyc1sncHJvZmlsZS1pZCddIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJQcm9maWxlSWQgPSBiQ29kZWMucGFyYW1ldGVyc1sncHJvZmlsZS1pZCddIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhUHJvZmlsZUlkICE9PSBiUHJvZmlsZUlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtYXRjaEhlYWRlckV4dGVuc2lvbnMoYUV4dCwgYkV4dCkge1xuICAgIGlmIChhRXh0LmtpbmQgJiYgYkV4dC5raW5kICYmIGFFeHQua2luZCAhPT0gYkV4dC5raW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGFFeHQudXJpICE9PSBiRXh0LnVyaSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVkdWNlUnRjcEZlZWRiYWNrKGNvZGVjQSwgY29kZWNCKSB7XG4gICAgY29uc3QgcmVkdWNlZFJ0Y3BGZWVkYmFjayA9IFtdO1xuICAgIGZvciAoY29uc3QgYUZiIG9mIGNvZGVjQS5ydGNwRmVlZGJhY2sgfHwgW10pIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdCRmIgPSAoY29kZWNCLnJ0Y3BGZWVkYmFjayB8fCBbXSlcbiAgICAgICAgICAgIC5maW5kKChiRmIpID0+IChiRmIudHlwZSA9PT0gYUZiLnR5cGUgJiZcbiAgICAgICAgICAgIChiRmIucGFyYW1ldGVyID09PSBhRmIucGFyYW1ldGVyIHx8ICghYkZiLnBhcmFtZXRlciAmJiAhYUZiLnBhcmFtZXRlcikpKSk7XG4gICAgICAgIGlmIChtYXRjaGluZ0JGYilcbiAgICAgICAgICAgIHJlZHVjZWRSdGNwRmVlZGJhY2sucHVzaChtYXRjaGluZ0JGYik7XG4gICAgfVxuICAgIHJldHVybiByZWR1Y2VkUnRjcEZlZWRiYWNrO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/ortc.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/scalabilityModes.js":
/*!***************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/scalabilityModes.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\\\d{0,1})T([1-9]\\\\d{0,1})');\nfunction parse(scalabilityMode) {\n    const match = ScalabilityModeRegex.exec(scalabilityMode || '');\n    if (match) {\n        return {\n            spatialLayers: Number(match[1]),\n            temporalLayers: Number(match[2])\n        };\n    }\n    else {\n        return {\n            spatialLayers: 1,\n            temporalLayers: 1\n        };\n    }\n}\nexports.parse = parse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvc2NhbGFiaWxpdHlNb2Rlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3J4X3NvY2tldGlvX2NsaWVudC8uL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9zY2FsYWJpbGl0eU1vZGVzLmpzPzgwNDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTY2FsYWJpbGl0eU1vZGVSZWdleCA9IG5ldyBSZWdFeHAoJ15bTFNdKFsxLTldXFxcXGR7MCwxfSlUKFsxLTldXFxcXGR7MCwxfSknKTtcbmZ1bmN0aW9uIHBhcnNlKHNjYWxhYmlsaXR5TW9kZSkge1xuICAgIGNvbnN0IG1hdGNoID0gU2NhbGFiaWxpdHlNb2RlUmVnZXguZXhlYyhzY2FsYWJpbGl0eU1vZGUgfHwgJycpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhdGlhbExheWVyczogTnVtYmVyKG1hdGNoWzFdKSxcbiAgICAgICAgICAgIHRlbXBvcmFsTGF5ZXJzOiBOdW1iZXIobWF0Y2hbMl0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhdGlhbExheWVyczogMSxcbiAgICAgICAgICAgIHRlbXBvcmFsTGF5ZXJzOiAxXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/scalabilityModes.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/types.js":
/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/types.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./Device */ \"./node_modules/mediasoup-client/lib/Device.js\"));\n__export(__webpack_require__(/*! ./Transport */ \"./node_modules/mediasoup-client/lib/Transport.js\"));\n__export(__webpack_require__(/*! ./Producer */ \"./node_modules/mediasoup-client/lib/Producer.js\"));\n__export(__webpack_require__(/*! ./Consumer */ \"./node_modules/mediasoup-client/lib/Consumer.js\"));\n__export(__webpack_require__(/*! ./DataProducer */ \"./node_modules/mediasoup-client/lib/DataProducer.js\"));\n__export(__webpack_require__(/*! ./DataConsumer */ \"./node_modules/mediasoup-client/lib/DataConsumer.js\"));\n__export(__webpack_require__(/*! ./handlers/HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\"));\n__export(__webpack_require__(/*! ./errors */ \"./node_modules/mediasoup-client/lib/errors.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvdHlwZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvdHlwZXMuanM/MDMyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9EZXZpY2VcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vVHJhbnNwb3J0XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1Byb2R1Y2VyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL0NvbnN1bWVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL0RhdGFQcm9kdWNlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9EYXRhQ29uc3VtZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vaGFuZGxlcnMvSGFuZGxlckludGVyZmFjZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9lcnJvcnNcIikpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/types.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/utils.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Clones the given object/array.\n *\n * @param {Object|Array} obj\n *\n * @returns {Object|Array}\n */\nfunction clone(data) {\n    if (typeof data !== 'object')\n        return {};\n    return JSON.parse(JSON.stringify(data));\n}\nexports.clone = clone;\n/**\n * Generates a random positive integer.\n */\nfunction generateRandomNumber() {\n    return Math.round(Math.random() * 10000000);\n}\nexports.generateRandomNumber = generateRandomNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvdXRpbHMuanM/ZjMxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ2xvbmVzIHRoZSBnaXZlbiBvYmplY3QvYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R8QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNsb25lKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4ge307XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xufVxuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gcG9zaXRpdmUgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21OdW1iZXIoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwKTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVSYW5kb21OdW1iZXIgPSBnZW5lcmF0ZVJhbmRvbU51bWJlcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/lib/utils.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/node_modules/debug/src/browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mediasoup-client/node_modules/debug/src/browser.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/mediasoup-client/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanM/ZDYwMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2coLi4uYXJncykge1xuXHQvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuXHQvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuXHRyZXR1cm4gdHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmXG5cdFx0Y29uc29sZS5sb2cgJiZcblx0XHRjb25zb2xlLmxvZyguLi5hcmdzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/node_modules/debug/src/common.js":
/*!************************************************************************!*\
  !*** ./node_modules/mediasoup-client/node_modules/debug/src/common.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/mediasoup-client/node_modules/ms/index.js\");\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3J4X3NvY2tldGlvX2NsaWVudC8uL25vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzP2RhMDMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMgPSBbXTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0Ly8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5cdFx0Ly8gZGVidWcucmF3TG9nID0gcmF3TG9nO1xuXG5cdFx0Ly8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdGNyZWF0ZURlYnVnLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc3QgaW5kZXggPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgY3JlYXRlRGVidWcuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBpbnN0YW5jZSA9IGNyZWF0ZURlYnVnLmluc3RhbmNlc1tpXTtcblx0XHRcdGluc3RhbmNlLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "./node_modules/mediasoup-client/node_modules/ms/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/node_modules/ms/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/YmJhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mediasoup-client/node_modules/ms/index.js\n");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/MTQ2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ms/index.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9mMjhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/rx-socket-io.client/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/rx-socket-io.client/dist/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*! For license information please see index.js.LICENSE.txt */\r\n!function(t,e){ true?module.exports=e(__webpack_require__(/*! rxjs */ \"rxjs\"),__webpack_require__(/*! rxjs/operators */ \"rxjs/operators\"),__webpack_require__(/*! socket.io-client */ \"socket.io-client\")):undefined}(this,(function(t,e,n){return function(t){var e={};function n(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var o in t)n.d(r,o,function(e){return t[e]}.bind(null,o));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p=\"\",n(n.s=1)}([function(t,e,n){\"use strict\";n.r(e),n.d(e,\"__extends\",(function(){return o})),n.d(e,\"__assign\",(function(){return i})),n.d(e,\"__rest\",(function(){return c})),n.d(e,\"__decorate\",(function(){return a})),n.d(e,\"__param\",(function(){return s})),n.d(e,\"__metadata\",(function(){return u})),n.d(e,\"__awaiter\",(function(){return l})),n.d(e,\"__generator\",(function(){return f})),n.d(e,\"__createBinding\",(function(){return _})),n.d(e,\"__exportStar\",(function(){return d})),n.d(e,\"__values\",(function(){return p})),n.d(e,\"__read\",(function(){return h})),n.d(e,\"__spread\",(function(){return v})),n.d(e,\"__spreadArrays\",(function(){return y})),n.d(e,\"__await\",(function(){return b})),n.d(e,\"__asyncGenerator\",(function(){return O})),n.d(e,\"__asyncDelegator\",(function(){return w})),n.d(e,\"__asyncValues\",(function(){return E})),n.d(e,\"__makeTemplateObject\",(function(){return N})),n.d(e,\"__importStar\",(function(){return P})),n.d(e,\"__importDefault\",(function(){return C})),n.d(e,\"__classPrivateFieldGet\",(function(){return m})),n.d(e,\"__classPrivateFieldSet\",(function(){return x}));var r=function(t,e){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(t,e)};function o(t,e){function n(){this.constructor=t}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}var i=function(){return(i=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var o in e=arguments[n])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};function c(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&\"function\"==typeof Object.getOwnPropertySymbols){var o=0;for(r=Object.getOwnPropertySymbols(t);o<r.length;o++)e.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(t,r[o])&&(n[r[o]]=t[r[o]])}return n}function a(t,e,n,r){var o,i=arguments.length,c=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,n):r;if(\"object\"==typeof Reflect&&\"function\"==typeof Reflect.decorate)c=Reflect.decorate(t,e,n,r);else for(var a=t.length-1;a>=0;a--)(o=t[a])&&(c=(i<3?o(c):i>3?o(e,n,c):o(e,n))||c);return i>3&&c&&Object.defineProperty(e,n,c),c}function s(t,e){return function(n,r){e(n,r,t)}}function u(t,e){if(\"object\"==typeof Reflect&&\"function\"==typeof Reflect.metadata)return Reflect.metadata(t,e)}function l(t,e,n,r){return new(n||(n=Promise))((function(o,i){function c(t){try{s(r.next(t))}catch(t){i(t)}}function a(t){try{s(r.throw(t))}catch(t){i(t)}}function s(t){var e;t.done?o(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(c,a)}s((r=r.apply(t,e||[])).next())}))}function f(t,e){var n,r,o,i,c={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},\"function\"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(i){return function(a){return function(i){if(n)throw new TypeError(\"Generator is already executing.\");for(;c;)try{if(n=1,r&&(o=2&i[0]?r.return:i[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,i[1])).done)return o;switch(r=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return c.label++,{value:i[1],done:!1};case 5:c.label++,r=i[1],i=[0];continue;case 7:i=c.ops.pop(),c.trys.pop();continue;default:if(!(o=c.trys,(o=o.length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){c=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){c.label=i[1];break}if(6===i[0]&&c.label<o[1]){c.label=o[1],o=i;break}if(o&&c.label<o[2]){c.label=o[2],c.ops.push(i);break}o[2]&&c.ops.pop(),c.trys.pop();continue}i=e.call(t,c)}catch(t){i=[6,t],r=0}finally{n=o=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}}function _(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}function d(t,e){for(var n in t)\"default\"===n||e.hasOwnProperty(n)||(e[n]=t[n])}function p(t){var e=\"function\"==typeof Symbol&&Symbol.iterator,n=e&&t[e],r=0;if(n)return n.call(t);if(t&&\"number\"==typeof t.length)return{next:function(){return t&&r>=t.length&&(t=void 0),{value:t&&t[r++],done:!t}}};throw new TypeError(e?\"Object is not iterable.\":\"Symbol.iterator is not defined.\")}function h(t,e){var n=\"function\"==typeof Symbol&&t[Symbol.iterator];if(!n)return t;var r,o,i=n.call(t),c=[];try{for(;(void 0===e||e-- >0)&&!(r=i.next()).done;)c.push(r.value)}catch(t){o={error:t}}finally{try{r&&!r.done&&(n=i.return)&&n.call(i)}finally{if(o)throw o.error}}return c}function v(){for(var t=[],e=0;e<arguments.length;e++)t=t.concat(h(arguments[e]));return t}function y(){for(var t=0,e=0,n=arguments.length;e<n;e++)t+=arguments[e].length;var r=Array(t),o=0;for(e=0;e<n;e++)for(var i=arguments[e],c=0,a=i.length;c<a;c++,o++)r[o]=i[c];return r}function b(t){return this instanceof b?(this.v=t,this):new b(t)}function O(t,e,n){if(!Symbol.asyncIterator)throw new TypeError(\"Symbol.asyncIterator is not defined.\");var r,o=n.apply(t,e||[]),i=[];return r={},c(\"next\"),c(\"throw\"),c(\"return\"),r[Symbol.asyncIterator]=function(){return this},r;function c(t){o[t]&&(r[t]=function(e){return new Promise((function(n,r){i.push([t,e,n,r])>1||a(t,e)}))})}function a(t,e){try{(n=o[t](e)).value instanceof b?Promise.resolve(n.value.v).then(s,u):l(i[0][2],n)}catch(t){l(i[0][3],t)}var n}function s(t){a(\"next\",t)}function u(t){a(\"throw\",t)}function l(t,e){t(e),i.shift(),i.length&&a(i[0][0],i[0][1])}}function w(t){var e,n;return e={},r(\"next\"),r(\"throw\",(function(t){throw t})),r(\"return\"),e[Symbol.iterator]=function(){return this},e;function r(r,o){e[r]=t[r]?function(e){return(n=!n)?{value:b(t[r](e)),done:\"return\"===r}:o?o(e):e}:o}}function E(t){if(!Symbol.asyncIterator)throw new TypeError(\"Symbol.asyncIterator is not defined.\");var e,n=t[Symbol.asyncIterator];return n?n.call(t):(t=p(t),e={},r(\"next\"),r(\"throw\"),r(\"return\"),e[Symbol.asyncIterator]=function(){return this},e);function r(n){e[n]=t[n]&&function(e){return new Promise((function(r,o){(function(t,e,n,r){Promise.resolve(r).then((function(e){t({value:e,done:n})}),e)})(r,o,(e=t[n](e)).done,e.value)}))}}}function N(t,e){return Object.defineProperty?Object.defineProperty(t,\"raw\",{value:e}):t.raw=e,t}function P(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function C(t){return t&&t.__esModule?t:{default:t}}function m(t,e){if(!e.has(t))throw new TypeError(\"attempted to get private field on non-instance\");return e.get(t)}function x(t,e,n){if(!e.has(t))throw new TypeError(\"attempted to set private field on non-instance\");return e.set(t,n),n}},function(t,e,n){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});n(0).__exportStar(n(2),e)},function(t,e,n){\"use strict\";var r,o,i,c,a;Object.defineProperty(e,\"__esModule\",{value:!0}),e.RxSocketClient=e.Status=void 0;const s=n(0),u=n(3),l=n(4),f=n(5);var _;!function(t){t[t.NOT_CONNECTED=0]=\"NOT_CONNECTED\",t[t.CONNECTING=1]=\"CONNECTING\",t[t.CONNECTED=2]=\"CONNECTED\",t[t.RECONNECTING=3]=\"RECONNECTING\",t[t.RECONNECTED=4]=\"RECONNECTED\",t[t.DISCONNECTED=5]=\"DISCONNECTED\",t[t.CLOSED=6]=\"CLOSED\"}(_=e.Status||(e.Status={}));e.RxSocketClient=class{constructor(t,e={},n=(()=>!1)){if(this.serverUrl=t,this.socketOptions=e,this.errorPredicationCallback=n,r.set(this,null),o.set(this,new u.BehaviorSubject(_.NOT_CONNECTED)),i.set(this,()=>{if(null===s.__classPrivateFieldGet(this,r))throw new Error(\"Socket is not inited!\");return s.__classPrivateFieldGet(this,r)}),c.set(this,()=>s.__classPrivateFieldGet(this,o).pipe(l.distinctUntilChanged()).pipe(l.filter(t=>t===_.DISCONNECTED)).pipe(l.map(()=>{}))),a.set(this,t=>u.merge(s.__classPrivateFieldGet(this,c).call(this).pipe(l.flatMap(()=>u.throwError(\"Socket connection lost!\"))),t)),\"string\"!=typeof t)throw new Error('\"serverUrl\" isn\\'t provided!')}get id(){return s.__classPrivateFieldGet(this,i).call(this).id}get status(){return s.__classPrivateFieldGet(this,o).value}get status$(){return s.__classPrivateFieldGet(this,o).asObservable()}init(){if(this.status===_.CONNECTED)throw new Error(\"Trying to connect already connected socket connection!\");if(this.status===_.CONNECTING)throw new Error(\"Previous connecting is pending!\");return s.__classPrivateFieldGet(this,o).next(_.CONNECTING),new u.Observable(t=>{const e=f.connect(this.serverUrl,\"object\"==typeof this.socketOptions?this.socketOptions:this.socketOptions()),n=e=>{s.__classPrivateFieldGet(this,o).next(_.NOT_CONNECTED),t.error(e)};e.once(\"connect_error\",n),e.once(\"connect_timeout\",n),e.once(\"connect\",()=>{e.off(\"connect_error\",n),e.off(\"connect_timeout\",n),s.__classPrivateFieldSet(this,r,e),s.__classPrivateFieldGet(this,o).next(_.CONNECTED),e.on(\"connect_error\",()=>s.__classPrivateFieldGet(this,o).next(_.DISCONNECTED)),e.on(\"connect_timeout\",()=>s.__classPrivateFieldGet(this,o).next(_.DISCONNECTED)),e.on(\"reconnecting\",()=>s.__classPrivateFieldGet(this,o).next(_.RECONNECTING)),e.on(\"reconnect\",()=>{s.__classPrivateFieldGet(this,o).next(_.RECONNECTED),s.__classPrivateFieldGet(this,o).next(_.CONNECTED)}),t.next(!0),t.complete()})})}close(){s.__classPrivateFieldGet(this,o).next(_.CLOSED),s.__classPrivateFieldGet(this,o).complete(),s.__classPrivateFieldGet(this,i).call(this).removeAllListeners(),s.__classPrivateFieldGet(this,i).call(this).close(),s.__classPrivateFieldSet(this,r,null)}emit(t,e={}){const n=new u.Observable(n=>{s.__classPrivateFieldGet(this,i).call(this).emit(t,\"object\"==typeof e?Object.assign({},e):{},t=>{this.errorPredicationCallback(t)?n.error(t):(n.next(t),n.complete())})});return s.__classPrivateFieldGet(this,a).call(this,n).pipe(l.take(1))}listen(t){const e=new u.Observable(e=>{function n(t){e.next(t)}return s.__classPrivateFieldGet(this,i).call(this).on(t,n),{unsubscribe:()=>{s.__classPrivateFieldGet(this,i).call(this).off(t,n)}}});return s.__classPrivateFieldGet(this,a).call(this,e)}listenWithAck(t){const e=new u.Observable(e=>{function n(t,n){e.next({ack:n,data:t})}return s.__classPrivateFieldGet(this,i).call(this).on(t,n),{unsubscribe:()=>{s.__classPrivateFieldGet(this,i).call(this).off(t,n)}}});return s.__classPrivateFieldGet(this,a).call(this,e)}},r=new WeakMap,o=new WeakMap,i=new WeakMap,c=new WeakMap,a=new WeakMap},function(e,n){e.exports=t},function(t,n){t.exports=e},function(t,e){t.exports=n}])}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcngtc29ja2V0LWlvLmNsaWVudC9kaXN0L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3J4LXNvY2tldC1pby5jbGllbnQvZGlzdC9pbmRleC5qcz83NGFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBGb3IgbGljZW5zZSBpbmZvcm1hdGlvbiBwbGVhc2Ugc2VlIGluZGV4LmpzLkxJQ0VOU0UudHh0ICovXHJcbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUocmVxdWlyZShcInJ4anNcIikscmVxdWlyZShcInJ4anMvb3BlcmF0b3JzXCIpLHJlcXVpcmUoXCJzb2NrZXQuaW8tY2xpZW50XCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcInJ4anNcIixcInJ4anMvb3BlcmF0b3JzXCIsXCJzb2NrZXQuaW8tY2xpZW50XCJdLGUpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMucnhfc29ja2V0aW9fY2xpZW50PWUocmVxdWlyZShcInJ4anNcIikscmVxdWlyZShcInJ4anMvb3BlcmF0b3JzXCIpLHJlcXVpcmUoXCJzb2NrZXQuaW8tY2xpZW50XCIpKTp0LnJ4X3NvY2tldGlvX2NsaWVudD1lKHQucnhqcyx0LnJ4anMub3BlcmF0b3JzLHQuaW8pfSh0aGlzLChmdW5jdGlvbih0LGUsbil7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXt9O2Z1bmN0aW9uIG4ocil7aWYoZVtyXSlyZXR1cm4gZVtyXS5leHBvcnRzO3ZhciBvPWVbcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiB0W3JdLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLG4pLG8ubD0hMCxvLmV4cG9ydHN9cmV0dXJuIG4ubT10LG4uYz1lLG4uZD1mdW5jdGlvbih0LGUscil7bi5vKHQsZSl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsZ2V0OnJ9KX0sbi5yPWZ1bmN0aW9uKHQpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LG4udD1mdW5jdGlvbih0LGUpe2lmKDEmZSYmKHQ9bih0KSksOCZlKXJldHVybiB0O2lmKDQmZSYmXCJvYmplY3RcIj09dHlwZW9mIHQmJnQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgcj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKG4ucihyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkocixcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSksMiZlJiZcInN0cmluZ1wiIT10eXBlb2YgdClmb3IodmFyIG8gaW4gdCluLmQocixvLGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfS5iaW5kKG51bGwsbykpO3JldHVybiByfSxuLm49ZnVuY3Rpb24odCl7dmFyIGU9dCYmdC5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHQuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gdH07cmV0dXJuIG4uZChlLFwiYVwiLGUpLGV9LG4ubz1mdW5jdGlvbih0LGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX0sbi5wPVwiXCIsbihuLnM9MSl9KFtmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bi5yKGUpLG4uZChlLFwiX19leHRlbmRzXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIG99KSksbi5kKGUsXCJfX2Fzc2lnblwiLChmdW5jdGlvbigpe3JldHVybiBpfSkpLG4uZChlLFwiX19yZXN0XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSksbi5kKGUsXCJfX2RlY29yYXRlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSksbi5kKGUsXCJfX3BhcmFtXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSksbi5kKGUsXCJfX21ldGFkYXRhXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSksbi5kKGUsXCJfX2F3YWl0ZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbH0pKSxuLmQoZSxcIl9fZ2VuZXJhdG9yXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSksbi5kKGUsXCJfX2NyZWF0ZUJpbmRpbmdcIiwoZnVuY3Rpb24oKXtyZXR1cm4gX30pKSxuLmQoZSxcIl9fZXhwb3J0U3RhclwiLChmdW5jdGlvbigpe3JldHVybiBkfSkpLG4uZChlLFwiX192YWx1ZXNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gcH0pKSxuLmQoZSxcIl9fcmVhZFwiLChmdW5jdGlvbigpe3JldHVybiBofSkpLG4uZChlLFwiX19zcHJlYWRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdn0pKSxuLmQoZSxcIl9fc3ByZWFkQXJyYXlzXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHl9KSksbi5kKGUsXCJfX2F3YWl0XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGJ9KSksbi5kKGUsXCJfX2FzeW5jR2VuZXJhdG9yXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIE99KSksbi5kKGUsXCJfX2FzeW5jRGVsZWdhdG9yXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSksbi5kKGUsXCJfX2FzeW5jVmFsdWVzXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEV9KSksbi5kKGUsXCJfX21ha2VUZW1wbGF0ZU9iamVjdFwiLChmdW5jdGlvbigpe3JldHVybiBOfSkpLG4uZChlLFwiX19pbXBvcnRTdGFyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSksbi5kKGUsXCJfX2ltcG9ydERlZmF1bHRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gQ30pKSxuLmQoZSxcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbX0pKSxuLmQoZSxcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwoZnVuY3Rpb24oKXtyZXR1cm4geH0pKTt2YXIgcj1mdW5jdGlvbih0LGUpe3JldHVybihyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWV9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pfSkodCxlKX07ZnVuY3Rpb24gbyh0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPXR9cih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KG4ucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBuKX12YXIgaT1mdW5jdGlvbigpe3JldHVybihpPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxuPTEscj1hcmd1bWVudHMubGVuZ3RoO248cjtuKyspZm9yKHZhciBvIGluIGU9YXJndW1lbnRzW25dKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG8pJiYodFtvXT1lW29dKTtyZXR1cm4gdH0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07ZnVuY3Rpb24gYyh0LGUpe3ZhciBuPXt9O2Zvcih2YXIgciBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpJiZlLmluZGV4T2Yocik8MCYmKG5bcl09dFtyXSk7aWYobnVsbCE9dCYmXCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG89MDtmb3Iocj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpO288ci5sZW5ndGg7bysrKWUuaW5kZXhPZihyW29dKTwwJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodCxyW29dKSYmKG5bcltvXV09dFtyW29dXSl9cmV0dXJuIG59ZnVuY3Rpb24gYSh0LGUsbixyKXt2YXIgbyxpPWFyZ3VtZW50cy5sZW5ndGgsYz1pPDM/ZTpudWxsPT09cj9yPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTpyO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBSZWZsZWN0LmRlY29yYXRlKWM9UmVmbGVjdC5kZWNvcmF0ZSh0LGUsbixyKTtlbHNlIGZvcih2YXIgYT10Lmxlbmd0aC0xO2E+PTA7YS0tKShvPXRbYV0pJiYoYz0oaTwzP28oYyk6aT4zP28oZSxuLGMpOm8oZSxuKSl8fGMpO3JldHVybiBpPjMmJmMmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4sYyksY31mdW5jdGlvbiBzKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKG4scil7ZShuLHIsdCl9fWZ1bmN0aW9uIHUodCxlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgUmVmbGVjdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSlyZXR1cm4gUmVmbGVjdC5tZXRhZGF0YSh0LGUpfWZ1bmN0aW9uIGwodCxlLG4scil7cmV0dXJuIG5ldyhufHwobj1Qcm9taXNlKSkoKGZ1bmN0aW9uKG8saSl7ZnVuY3Rpb24gYyh0KXt0cnl7cyhyLm5leHQodCkpfWNhdGNoKHQpe2kodCl9fWZ1bmN0aW9uIGEodCl7dHJ5e3Moci50aHJvdyh0KSl9Y2F0Y2godCl7aSh0KX19ZnVuY3Rpb24gcyh0KXt2YXIgZTt0LmRvbmU/byh0LnZhbHVlKTooZT10LnZhbHVlLGUgaW5zdGFuY2VvZiBuP2U6bmV3IG4oKGZ1bmN0aW9uKHQpe3QoZSl9KSkpLnRoZW4oYyxhKX1zKChyPXIuYXBwbHkodCxlfHxbXSkpLm5leHQoKSl9KSl9ZnVuY3Rpb24gZih0LGUpe3ZhciBuLHIsbyxpLGM9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmb1swXSl0aHJvdyBvWzFdO3JldHVybiBvWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIGk9e25leHQ6YSgwKSx0aHJvdzphKDEpLHJldHVybjphKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihpW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGk7ZnVuY3Rpb24gYShpKXtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGkpe2lmKG4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDtjOyl0cnl7aWYobj0xLHImJihvPTImaVswXT9yLnJldHVybjppWzBdP3IudGhyb3d8fCgobz1yLnJldHVybikmJm8uY2FsbChyKSwwKTpyLm5leHQpJiYhKG89by5jYWxsKHIsaVsxXSkpLmRvbmUpcmV0dXJuIG87c3dpdGNoKHI9MCxvJiYoaT1bMiZpWzBdLG8udmFsdWVdKSxpWzBdKXtjYXNlIDA6Y2FzZSAxOm89aTticmVhaztjYXNlIDQ6cmV0dXJuIGMubGFiZWwrKyx7dmFsdWU6aVsxXSxkb25lOiExfTtjYXNlIDU6Yy5sYWJlbCsrLHI9aVsxXSxpPVswXTtjb250aW51ZTtjYXNlIDc6aT1jLm9wcy5wb3AoKSxjLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKG89Yy50cnlzLChvPW8ubGVuZ3RoPjAmJm9bby5sZW5ndGgtMV0pfHw2IT09aVswXSYmMiE9PWlbMF0pKXtjPTA7Y29udGludWV9aWYoMz09PWlbMF0mJighb3x8aVsxXT5vWzBdJiZpWzFdPG9bM10pKXtjLmxhYmVsPWlbMV07YnJlYWt9aWYoNj09PWlbMF0mJmMubGFiZWw8b1sxXSl7Yy5sYWJlbD1vWzFdLG89aTticmVha31pZihvJiZjLmxhYmVsPG9bMl0pe2MubGFiZWw9b1syXSxjLm9wcy5wdXNoKGkpO2JyZWFrfW9bMl0mJmMub3BzLnBvcCgpLGMudHJ5cy5wb3AoKTtjb250aW51ZX1pPWUuY2FsbCh0LGMpfWNhdGNoKHQpe2k9WzYsdF0scj0wfWZpbmFsbHl7bj1vPTB9aWYoNSZpWzBdKXRocm93IGlbMV07cmV0dXJue3ZhbHVlOmlbMF0/aVsxXTp2b2lkIDAsZG9uZTohMH19KFtpLGFdKX19fWZ1bmN0aW9uIF8odCxlLG4scil7dm9pZCAwPT09ciYmKHI9biksdFtyXT1lW25dfWZ1bmN0aW9uIGQodCxlKXtmb3IodmFyIG4gaW4gdClcImRlZmF1bHRcIj09PW58fGUuaGFzT3duUHJvcGVydHkobil8fChlW25dPXRbbl0pfWZ1bmN0aW9uIHAodCl7dmFyIGU9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3Isbj1lJiZ0W2VdLHI9MDtpZihuKXJldHVybiBuLmNhbGwodCk7aWYodCYmXCJudW1iZXJcIj09dHlwZW9mIHQubGVuZ3RoKXJldHVybntuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHQmJnI+PXQubGVuZ3RoJiYodD12b2lkIDApLHt2YWx1ZTp0JiZ0W3IrK10sZG9uZTohdH19fTt0aHJvdyBuZXcgVHlwZUVycm9yKGU/XCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiOlwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKX1mdW5jdGlvbiBoKHQsZSl7dmFyIG49XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0W1N5bWJvbC5pdGVyYXRvcl07aWYoIW4pcmV0dXJuIHQ7dmFyIHIsbyxpPW4uY2FsbCh0KSxjPVtdO3RyeXtmb3IoOyh2b2lkIDA9PT1lfHxlLS0gPjApJiYhKHI9aS5uZXh0KCkpLmRvbmU7KWMucHVzaChyLnZhbHVlKX1jYXRjaCh0KXtvPXtlcnJvcjp0fX1maW5hbGx5e3RyeXtyJiYhci5kb25lJiYobj1pLnJldHVybikmJm4uY2FsbChpKX1maW5hbGx5e2lmKG8pdGhyb3cgby5lcnJvcn19cmV0dXJuIGN9ZnVuY3Rpb24gdigpe2Zvcih2YXIgdD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0PXQuY29uY2F0KGgoYXJndW1lbnRzW2VdKSk7cmV0dXJuIHR9ZnVuY3Rpb24geSgpe2Zvcih2YXIgdD0wLGU9MCxuPWFyZ3VtZW50cy5sZW5ndGg7ZTxuO2UrKyl0Kz1hcmd1bWVudHNbZV0ubGVuZ3RoO3ZhciByPUFycmF5KHQpLG89MDtmb3IoZT0wO2U8bjtlKyspZm9yKHZhciBpPWFyZ3VtZW50c1tlXSxjPTAsYT1pLmxlbmd0aDtjPGE7YysrLG8rKylyW29dPWlbY107cmV0dXJuIHJ9ZnVuY3Rpb24gYih0KXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGI/KHRoaXMudj10LHRoaXMpOm5ldyBiKHQpfWZ1bmN0aW9uIE8odCxlLG4pe2lmKCFTeW1ib2wuYXN5bmNJdGVyYXRvcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO3ZhciByLG89bi5hcHBseSh0LGV8fFtdKSxpPVtdO3JldHVybiByPXt9LGMoXCJuZXh0XCIpLGMoXCJ0aHJvd1wiKSxjKFwicmV0dXJuXCIpLHJbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LHI7ZnVuY3Rpb24gYyh0KXtvW3RdJiYoclt0XT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4scil7aS5wdXNoKFt0LGUsbixyXSk+MXx8YSh0LGUpfSkpfSl9ZnVuY3Rpb24gYSh0LGUpe3RyeXsobj1vW3RdKGUpKS52YWx1ZSBpbnN0YW5jZW9mIGI/UHJvbWlzZS5yZXNvbHZlKG4udmFsdWUudikudGhlbihzLHUpOmwoaVswXVsyXSxuKX1jYXRjaCh0KXtsKGlbMF1bM10sdCl9dmFyIG59ZnVuY3Rpb24gcyh0KXthKFwibmV4dFwiLHQpfWZ1bmN0aW9uIHUodCl7YShcInRocm93XCIsdCl9ZnVuY3Rpb24gbCh0LGUpe3QoZSksaS5zaGlmdCgpLGkubGVuZ3RoJiZhKGlbMF1bMF0saVswXVsxXSl9fWZ1bmN0aW9uIHcodCl7dmFyIGUsbjtyZXR1cm4gZT17fSxyKFwibmV4dFwiKSxyKFwidGhyb3dcIiwoZnVuY3Rpb24odCl7dGhyb3cgdH0pKSxyKFwicmV0dXJuXCIpLGVbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxlO2Z1bmN0aW9uIHIocixvKXtlW3JdPXRbcl0/ZnVuY3Rpb24oZSl7cmV0dXJuKG49IW4pP3t2YWx1ZTpiKHRbcl0oZSkpLGRvbmU6XCJyZXR1cm5cIj09PXJ9Om8/byhlKTplfTpvfX1mdW5jdGlvbiBFKHQpe2lmKCFTeW1ib2wuYXN5bmNJdGVyYXRvcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO3ZhciBlLG49dFtTeW1ib2wuYXN5bmNJdGVyYXRvcl07cmV0dXJuIG4/bi5jYWxsKHQpOih0PXAodCksZT17fSxyKFwibmV4dFwiKSxyKFwidGhyb3dcIikscihcInJldHVyblwiKSxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxlKTtmdW5jdGlvbiByKG4pe2Vbbl09dFtuXSYmZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihyLG8peyhmdW5jdGlvbih0LGUsbixyKXtQcm9taXNlLnJlc29sdmUocikudGhlbigoZnVuY3Rpb24oZSl7dCh7dmFsdWU6ZSxkb25lOm59KX0pLGUpfSkocixvLChlPXRbbl0oZSkpLmRvbmUsZS52YWx1ZSl9KSl9fX1mdW5jdGlvbiBOKHQsZSl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eT9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInJhd1wiLHt2YWx1ZTplfSk6dC5yYXc9ZSx0fWZ1bmN0aW9uIFAodCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSk7cmV0dXJuIGUuZGVmYXVsdD10LGV9ZnVuY3Rpb24gQyh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbSh0LGUpe2lmKCFlLmhhcyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gZS5nZXQodCl9ZnVuY3Rpb24geCh0LGUsbil7aWYoIWUuaGFzKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBlLnNldCh0LG4pLG59fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7bigwKS5fX2V4cG9ydFN0YXIobigyKSxlKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByLG8saSxjLGE7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5SeFNvY2tldENsaWVudD1lLlN0YXR1cz12b2lkIDA7Y29uc3Qgcz1uKDApLHU9bigzKSxsPW4oNCksZj1uKDUpO3ZhciBfOyFmdW5jdGlvbih0KXt0W3QuTk9UX0NPTk5FQ1RFRD0wXT1cIk5PVF9DT05ORUNURURcIix0W3QuQ09OTkVDVElORz0xXT1cIkNPTk5FQ1RJTkdcIix0W3QuQ09OTkVDVEVEPTJdPVwiQ09OTkVDVEVEXCIsdFt0LlJFQ09OTkVDVElORz0zXT1cIlJFQ09OTkVDVElOR1wiLHRbdC5SRUNPTk5FQ1RFRD00XT1cIlJFQ09OTkVDVEVEXCIsdFt0LkRJU0NPTk5FQ1RFRD01XT1cIkRJU0NPTk5FQ1RFRFwiLHRbdC5DTE9TRUQ9Nl09XCJDTE9TRURcIn0oXz1lLlN0YXR1c3x8KGUuU3RhdHVzPXt9KSk7ZS5SeFNvY2tldENsaWVudD1jbGFzc3tjb25zdHJ1Y3Rvcih0LGU9e30sbj0oKCk9PiExKSl7aWYodGhpcy5zZXJ2ZXJVcmw9dCx0aGlzLnNvY2tldE9wdGlvbnM9ZSx0aGlzLmVycm9yUHJlZGljYXRpb25DYWxsYmFjaz1uLHIuc2V0KHRoaXMsbnVsbCksby5zZXQodGhpcyxuZXcgdS5CZWhhdmlvclN1YmplY3QoXy5OT1RfQ09OTkVDVEVEKSksaS5zZXQodGhpcywoKT0+e2lmKG51bGw9PT1zLl9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcyxyKSl0aHJvdyBuZXcgRXJyb3IoXCJTb2NrZXQgaXMgbm90IGluaXRlZCFcIik7cmV0dXJuIHMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLHIpfSksYy5zZXQodGhpcywoKT0+cy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsbykucGlwZShsLmRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnBpcGUobC5maWx0ZXIodD0+dD09PV8uRElTQ09OTkVDVEVEKSkucGlwZShsLm1hcCgoKT0+e30pKSksYS5zZXQodGhpcyx0PT51Lm1lcmdlKHMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLGMpLmNhbGwodGhpcykucGlwZShsLmZsYXRNYXAoKCk9PnUudGhyb3dFcnJvcihcIlNvY2tldCBjb25uZWN0aW9uIGxvc3QhXCIpKSksdCkpLFwic3RyaW5nXCIhPXR5cGVvZiB0KXRocm93IG5ldyBFcnJvcignXCJzZXJ2ZXJVcmxcIiBpc25cXCd0IHByb3ZpZGVkIScpfWdldCBpZCgpe3JldHVybiBzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcyxpKS5jYWxsKHRoaXMpLmlkfWdldCBzdGF0dXMoKXtyZXR1cm4gcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsbykudmFsdWV9Z2V0IHN0YXR1cyQoKXtyZXR1cm4gcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsbykuYXNPYnNlcnZhYmxlKCl9aW5pdCgpe2lmKHRoaXMuc3RhdHVzPT09Xy5DT05ORUNURUQpdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIGNvbm5lY3QgYWxyZWFkeSBjb25uZWN0ZWQgc29ja2V0IGNvbm5lY3Rpb24hXCIpO2lmKHRoaXMuc3RhdHVzPT09Xy5DT05ORUNUSU5HKXRocm93IG5ldyBFcnJvcihcIlByZXZpb3VzIGNvbm5lY3RpbmcgaXMgcGVuZGluZyFcIik7cmV0dXJuIHMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLG8pLm5leHQoXy5DT05ORUNUSU5HKSxuZXcgdS5PYnNlcnZhYmxlKHQ9Pntjb25zdCBlPWYuY29ubmVjdCh0aGlzLnNlcnZlclVybCxcIm9iamVjdFwiPT10eXBlb2YgdGhpcy5zb2NrZXRPcHRpb25zP3RoaXMuc29ja2V0T3B0aW9uczp0aGlzLnNvY2tldE9wdGlvbnMoKSksbj1lPT57cy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsbykubmV4dChfLk5PVF9DT05ORUNURUQpLHQuZXJyb3IoZSl9O2Uub25jZShcImNvbm5lY3RfZXJyb3JcIixuKSxlLm9uY2UoXCJjb25uZWN0X3RpbWVvdXRcIixuKSxlLm9uY2UoXCJjb25uZWN0XCIsKCk9PntlLm9mZihcImNvbm5lY3RfZXJyb3JcIixuKSxlLm9mZihcImNvbm5lY3RfdGltZW91dFwiLG4pLHMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLHIsZSkscy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsbykubmV4dChfLkNPTk5FQ1RFRCksZS5vbihcImNvbm5lY3RfZXJyb3JcIiwoKT0+cy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsbykubmV4dChfLkRJU0NPTk5FQ1RFRCkpLGUub24oXCJjb25uZWN0X3RpbWVvdXRcIiwoKT0+cy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsbykubmV4dChfLkRJU0NPTk5FQ1RFRCkpLGUub24oXCJyZWNvbm5lY3RpbmdcIiwoKT0+cy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsbykubmV4dChfLlJFQ09OTkVDVElORykpLGUub24oXCJyZWNvbm5lY3RcIiwoKT0+e3MuX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLG8pLm5leHQoXy5SRUNPTk5FQ1RFRCkscy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsbykubmV4dChfLkNPTk5FQ1RFRCl9KSx0Lm5leHQoITApLHQuY29tcGxldGUoKX0pfSl9Y2xvc2UoKXtzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcyxvKS5uZXh0KF8uQ0xPU0VEKSxzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcyxvKS5jb21wbGV0ZSgpLHMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLGkpLmNhbGwodGhpcykucmVtb3ZlQWxsTGlzdGVuZXJzKCkscy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsaSkuY2FsbCh0aGlzKS5jbG9zZSgpLHMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLHIsbnVsbCl9ZW1pdCh0LGU9e30pe2NvbnN0IG49bmV3IHUuT2JzZXJ2YWJsZShuPT57cy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsaSkuY2FsbCh0aGlzKS5lbWl0KHQsXCJvYmplY3RcIj09dHlwZW9mIGU/T2JqZWN0LmFzc2lnbih7fSxlKTp7fSx0PT57dGhpcy5lcnJvclByZWRpY2F0aW9uQ2FsbGJhY2sodCk/bi5lcnJvcih0KToobi5uZXh0KHQpLG4uY29tcGxldGUoKSl9KX0pO3JldHVybiBzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcyxhKS5jYWxsKHRoaXMsbikucGlwZShsLnRha2UoMSkpfWxpc3Rlbih0KXtjb25zdCBlPW5ldyB1Lk9ic2VydmFibGUoZT0+e2Z1bmN0aW9uIG4odCl7ZS5uZXh0KHQpfXJldHVybiBzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcyxpKS5jYWxsKHRoaXMpLm9uKHQsbikse3Vuc3Vic2NyaWJlOigpPT57cy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsaSkuY2FsbCh0aGlzKS5vZmYodCxuKX19fSk7cmV0dXJuIHMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLGEpLmNhbGwodGhpcyxlKX1saXN0ZW5XaXRoQWNrKHQpe2NvbnN0IGU9bmV3IHUuT2JzZXJ2YWJsZShlPT57ZnVuY3Rpb24gbih0LG4pe2UubmV4dCh7YWNrOm4sZGF0YTp0fSl9cmV0dXJuIHMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLGkpLmNhbGwodGhpcykub24odCxuKSx7dW5zdWJzY3JpYmU6KCk9PntzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcyxpKS5jYWxsKHRoaXMpLm9mZih0LG4pfX19KTtyZXR1cm4gcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsYSkuY2FsbCh0aGlzLGUpfX0scj1uZXcgV2Vha01hcCxvPW5ldyBXZWFrTWFwLGk9bmV3IFdlYWtNYXAsYz1uZXcgV2Vha01hcCxhPW5ldyBXZWFrTWFwfSxmdW5jdGlvbihlLG4pe2UuZXhwb3J0cz10fSxmdW5jdGlvbih0LG4pe3QuZXhwb3J0cz1lfSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1ufV0pfSkpOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/rx-socket-io.client/dist/index.js\n");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/grammar.js":
/*!***************************************************!*\
  !*** ./node_modules/sdp-transform/lib/grammar.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var grammar = module.exports = {\n  v: [{\n    name: 'version',\n    reg: /^(\\d*)$/\n  }],\n  o: [{\n    // o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: '%s %s %d %s IP%d %s'\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n  // k: [{}], // outdated thing ignored\n  t: [{\n    // t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: '%d %d'\n  }],\n  c: [{\n    // c=IN IP4 10.47.197.26\n    name: 'connection',\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: ['version', 'ip'],\n    format: 'IN IP%d %s'\n  }],\n  b: [{\n    // b=AS:4000\n    push: 'bandwidth',\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: ['type', 'limit'],\n    format: '%s:%s'\n  }],\n  m: [{\n    // m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n    names: ['type', 'port', 'protocol', 'payloads'],\n    format: '%s %d %s %s'\n  }],\n  a: [\n    {\n      // a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return (o.encoding)\n          ? 'rtpmap:%d %s/%s/%s'\n          : o.rate\n            ? 'rtpmap:%d %s/%s'\n            : 'rtpmap:%d %s';\n      }\n    },\n    {\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      // a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: 'fmtp:%d %s'\n    },\n    {\n      // a=control:streamid=0\n      name: 'control',\n      reg: /^control:(.*)/,\n      format: 'control:%s'\n    },\n    {\n      // a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return (o.address != null)\n          ? 'rtcp:%d %s IP%d %s'\n          : 'rtcp:%d';\n      }\n    },\n    {\n      // a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: 'rtcp-fb:%d trr-int %d'\n    },\n    {\n      // a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return (o.subtype != null)\n          ? 'rtcp-fb:%s %s %s'\n          : 'rtcp-fb:%s %s';\n      }\n    },\n    {\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      // a=extmap:1/recvonly URI-gps-string\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n      push: 'ext',\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],\n      format: function (o) {\n        return (\n          'extmap:%d' +\n          (o.direction ? '/%s' : '%v') +\n          (o['encrypt-uri'] ? ' %s' : '%v') +\n          ' %s' +\n          (o.config ? ' %s' : '')\n        );\n      }\n    },\n    {\n      // a=extmap-allow-mixed\n      name: 'extmapAllowMixed',\n      reg: /^(extmap-allow-mixed)/\n    },\n    {\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return (o.sessionConfig != null)\n          ? 'crypto:%d %s %s %s'\n          : 'crypto:%d %s %s';\n      }\n    },\n    {\n      // a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: 'setup:%s'\n    },\n    {\n      // a=connection:new\n      name: 'connectionType',\n      reg: /^connection:(new|existing)/,\n      format: 'connection:%s'\n    },\n    {\n      // a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: 'mid:%s'\n    },\n    {\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: 'msid:%s'\n    },\n    {\n      // a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'ptime:%d'\n    },\n    {\n      // a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'maxptime:%d'\n    },\n    {\n      // a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    {\n      // a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    },\n    {\n      // a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: 'ice-ufrag:%s'\n    },\n    {\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: 'ice-pwd:%s'\n    },\n    {\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: 'fingerprint:%s %s'\n    },\n    {\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push:'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n      format: function (o) {\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\n\n        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += (o.tcptype != null) ? ' tcptype %s' : '%v';\n\n        if (o.generation != null) {\n          str += ' generation %d';\n        }\n\n        str += (o['network-id'] != null) ? ' network-id %d' : '%v';\n        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\n        return str;\n      }\n    },\n    {\n      // a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    },\n    {\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: 'remote-candidates:%s'\n    },\n    {\n      // a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: 'ice-options:%s'\n    },\n    {\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: 'ssrcs',\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: ['id', 'attribute', 'value'],\n      format: function (o) {\n        var str = 'ssrc:%d';\n        if (o.attribute != null) {\n          str += ' %s';\n          if (o.value != null) {\n            str += ':%s';\n          }\n        }\n        return str;\n      }\n    },\n    {\n      // a=ssrc-group:FEC 1 2\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: 'ssrcGroups',\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: 'ssrc-group:%s %s'\n    },\n    {\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: 'msidSemantic',\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n    },\n    {\n      // a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: 'group:%s %s'\n    },\n    {\n      // a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    },\n    {\n      // a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    },\n    {\n      // a=sctpmap:5000 webrtc-datachannel 1024\n      name: 'sctpmap',\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n      format: function (o) {\n        return (o.maxMessageSize != null)\n          ? 'sctpmap:%s %s %s'\n          : 'sctpmap:%s %s';\n      }\n    },\n    {\n      // a=x-google-flag:conference\n      name: 'xGoogleFlag',\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: 'x-google-flag:%s'\n    },\n    {\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: 'rids',\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: ['id', 'direction', 'params'],\n      format: function (o) {\n        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\n      }\n    },\n    {\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      // a=imageattr:* send [x=800,y=640] recv *\n      // a=imageattr:100 recv [x=320,y=240]\n      push: 'imageattrs',\n      reg: new RegExp(\n        // a=imageattr:97\n        '^imageattr:(\\\\d+|\\\\*)' +\n        // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n        '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n        // recv [x=330,y=250]\n        '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\n      ),\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n      format: function (o) {\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      // a=simulcast:recv 1;4,5 send 6;7\n      name: 'simulcast',\n      reg: new RegExp(\n        // a=simulcast:\n        '^simulcast:' +\n        // send 1,2,3;~4,~5\n        '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n        // space + recv 6;~7,~8\n        '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n        // end\n        '$'\n      ),\n      names: ['dir1', 'list1', 'dir2', 'list2'],\n      format: function (o) {\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // old simulcast draft 03 (implemented by Firefox)\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      // a=simulcast: recv pt=97;98 send pt=97\n      // a=simulcast: send rid=5;6;7 paused=6,7\n      name: 'simulcast_03',\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: ['value'],\n      format: 'simulcast: %s'\n    },\n    {\n      // a=framerate:25\n      // a=framerate:29.97\n      name: 'framerate',\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: 'framerate:%s'\n    },\n    {\n      // RFC4570\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: 'sourceFilter',\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\n      format: 'source-filter: %s %s %s %s %s'\n    },\n    {\n      // a=bundle-only\n      name: 'bundleOnly',\n      reg: /^(bundle-only)/\n    },\n    {\n      // a=label:1\n      name: 'label',\n      reg: /^label:(.+)/,\n      format: 'label:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n      name: 'sctpPort',\n      reg: /^sctp-port:(\\d+)$/,\n      format: 'sctp-port:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n      name: 'maxMessageSize',\n      reg: /^max-message-size:(\\d+)$/,\n      format: 'max-message-size:%s'\n    },\n    {\n      // RFC7273\n      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n      push:'tsRefClocks',\n      reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n      names: ['clksrc', 'clksrcExt'],\n      format: function (o) {\n        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');\n      }\n    },\n    {\n      // RFC7273\n      // a=mediaclk:direct=963214424\n      name:'mediaClk',\n      reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],\n      format: function (o) {\n        var str = 'mediaclk:';\n        str += (o.id != null ? 'id=%s %s' : '%v%s');\n        str += (o.mediaClockValue != null ? '=%s' : '');\n        str += (o.rateNumerator != null ? ' rate=%s' : '');\n        str += (o.rateDenominator != null ? '/%s' : '');\n        return str;\n      }\n    },\n    {\n      // a=keywds:keywords\n      name: 'keywords',\n      reg: /^keywds:(.+)$/,\n      format: 'keywds:%s'\n    },\n    {\n      // a=content:main\n      name: 'content',\n      reg: /^content:(.+)/,\n      format: 'content:%s'\n    },\n    // BFCP https://tools.ietf.org/html/rfc4583\n    {\n      // a=floorctrl:c-s\n      name: 'bfcpFloorCtrl',\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\n      format: 'floorctrl:%s'\n    },\n    {\n      // a=confid:1\n      name: 'bfcpConfId',\n      reg: /^confid:(\\d+)/,\n      format: 'confid:%s'\n    },\n    {\n      // a=userid:1\n      name: 'bfcpUserId',\n      reg: /^userid:(\\d+)/,\n      format: 'userid:%s'\n    },\n    {\n      // a=floorid:1\n      name: 'bfcpFloorId',\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n      names: ['id', 'mStream'],\n      format: 'floorid:%s mstrm:%s'\n    },\n    {\n      // any a= that we don't understand is kept verbatim on media.invalid\n      push: 'invalid',\n      names: ['value']\n    }\n  ]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = '%s';\n    }\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2RwLXRyYW5zZm9ybS9saWIvZ3JhbW1hci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3J4X3NvY2tldGlvX2NsaWVudC8uL25vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi9ncmFtbWFyLmpzPzNiYWEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdyYW1tYXIgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgdjogW3tcbiAgICBuYW1lOiAndmVyc2lvbicsXG4gICAgcmVnOiAvXihcXGQqKSQvXG4gIH1dLFxuICBvOiBbe1xuICAgIC8vIG89LSAyMDUxOCAwIElOIElQNCAyMDMuMC4xMTMuMVxuICAgIC8vIE5COiBzZXNzaW9uSWQgd2lsbCBiZSBhIFN0cmluZyBpbiBtb3N0IGNhc2VzIGJlY2F1c2UgaXQgaXMgaHVnZVxuICAgIG5hbWU6ICdvcmlnaW4nLFxuICAgIHJlZzogL14oXFxTKikgKFxcZCopIChcXGQqKSAoXFxTKikgSVAoXFxkKSAoXFxTKikvLFxuICAgIG5hbWVzOiBbJ3VzZXJuYW1lJywgJ3Nlc3Npb25JZCcsICdzZXNzaW9uVmVyc2lvbicsICduZXRUeXBlJywgJ2lwVmVyJywgJ2FkZHJlc3MnXSxcbiAgICBmb3JtYXQ6ICclcyAlcyAlZCAlcyBJUCVkICVzJ1xuICB9XSxcbiAgLy8gZGVmYXVsdCBwYXJzaW5nIG9mIHRoZXNlIG9ubHkgKHRob3VnaCBzb21lIG9mIHRoZXNlIGZlZWwgb3V0ZGF0ZWQpXG4gIHM6IFt7IG5hbWU6ICduYW1lJyB9XSxcbiAgaTogW3sgbmFtZTogJ2Rlc2NyaXB0aW9uJyB9XSxcbiAgdTogW3sgbmFtZTogJ3VyaScgfV0sXG4gIGU6IFt7IG5hbWU6ICdlbWFpbCcgfV0sXG4gIHA6IFt7IG5hbWU6ICdwaG9uZScgfV0sXG4gIHo6IFt7IG5hbWU6ICd0aW1lem9uZXMnIH1dLCAvLyBUT0RPOiB0aGlzIG9uZSBjYW4gYWN0dWFsbHkgYmUgcGFyc2VkIHByb3Blcmx5Li4uXG4gIHI6IFt7IG5hbWU6ICdyZXBlYXRzJyB9XSwgICAvLyBUT0RPOiB0aGlzIG9uZSBjYW4gYWxzbyBiZSBwYXJzZWQgcHJvcGVybHlcbiAgLy8gazogW3t9XSwgLy8gb3V0ZGF0ZWQgdGhpbmcgaWdub3JlZFxuICB0OiBbe1xuICAgIC8vIHQ9MCAwXG4gICAgbmFtZTogJ3RpbWluZycsXG4gICAgcmVnOiAvXihcXGQqKSAoXFxkKikvLFxuICAgIG5hbWVzOiBbJ3N0YXJ0JywgJ3N0b3AnXSxcbiAgICBmb3JtYXQ6ICclZCAlZCdcbiAgfV0sXG4gIGM6IFt7XG4gICAgLy8gYz1JTiBJUDQgMTAuNDcuMTk3LjI2XG4gICAgbmFtZTogJ2Nvbm5lY3Rpb24nLFxuICAgIHJlZzogL15JTiBJUChcXGQpIChcXFMqKS8sXG4gICAgbmFtZXM6IFsndmVyc2lvbicsICdpcCddLFxuICAgIGZvcm1hdDogJ0lOIElQJWQgJXMnXG4gIH1dLFxuICBiOiBbe1xuICAgIC8vIGI9QVM6NDAwMFxuICAgIHB1c2g6ICdiYW5kd2lkdGgnLFxuICAgIHJlZzogL14oVElBU3xBU3xDVHxSUnxSUyk6KFxcZCopLyxcbiAgICBuYW1lczogWyd0eXBlJywgJ2xpbWl0J10sXG4gICAgZm9ybWF0OiAnJXM6JXMnXG4gIH1dLFxuICBtOiBbe1xuICAgIC8vIG09dmlkZW8gNTE3NDQgUlRQL0FWUCAxMjYgOTcgOTggMzQgMzFcbiAgICAvLyBOQjogc3BlY2lhbCAtIHB1c2hlcyB0byBzZXNzaW9uXG4gICAgLy8gVE9ETzogcnRwL2ZtdHAgc2hvdWxkIGJlIGZpbHRlcmVkIGJ5IHRoZSBwYXlsb2FkcyBmb3VuZCBoZXJlP1xuICAgIHJlZzogL14oXFx3KikgKFxcZCopIChbXFx3L10qKSg/OiAoLiopKT8vLFxuICAgIG5hbWVzOiBbJ3R5cGUnLCAncG9ydCcsICdwcm90b2NvbCcsICdwYXlsb2FkcyddLFxuICAgIGZvcm1hdDogJyVzICVkICVzICVzJ1xuICB9XSxcbiAgYTogW1xuICAgIHtcbiAgICAgIC8vIGE9cnRwbWFwOjExMCBvcHVzLzQ4MDAwLzJcbiAgICAgIHB1c2g6ICdydHAnLFxuICAgICAgcmVnOiAvXnJ0cG1hcDooXFxkKikgKFtcXHdcXC0uXSopKD86XFxzKlxcLyhcXGQqKSg/OlxccypcXC8oXFxTKikpPyk/LyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAnY29kZWMnLCAncmF0ZScsICdlbmNvZGluZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uZW5jb2RpbmcpXG4gICAgICAgICAgPyAncnRwbWFwOiVkICVzLyVzLyVzJ1xuICAgICAgICAgIDogby5yYXRlXG4gICAgICAgICAgICA/ICdydHBtYXA6JWQgJXMvJXMnXG4gICAgICAgICAgICA6ICdydHBtYXA6JWQgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1mbXRwOjEwOCBwcm9maWxlLWxldmVsLWlkPTI0O29iamVjdD0yMztiaXRyYXRlPTY0MDAwXG4gICAgICAvLyBhPWZtdHA6MTExIG1pbnB0aW1lPTEwOyB1c2VpbmJhbmRmZWM9MVxuICAgICAgcHVzaDogJ2ZtdHAnLFxuICAgICAgcmVnOiAvXmZtdHA6KFxcZCopIChbXFxTfCBdKikvLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb25maWcnXSxcbiAgICAgIGZvcm1hdDogJ2ZtdHA6JWQgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNvbnRyb2w6c3RyZWFtaWQ9MFxuICAgICAgbmFtZTogJ2NvbnRyb2wnLFxuICAgICAgcmVnOiAvXmNvbnRyb2w6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdjb250cm9sOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ydGNwOjY1MTc5IElOIElQNCAxOTMuODQuNzcuMTk0XG4gICAgICBuYW1lOiAncnRjcCcsXG4gICAgICByZWc6IC9ecnRjcDooXFxkKikoPzogKFxcUyopIElQKFxcZCkgKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsncG9ydCcsICduZXRUeXBlJywgJ2lwVmVyJywgJ2FkZHJlc3MnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLmFkZHJlc3MgIT0gbnVsbClcbiAgICAgICAgICA/ICdydGNwOiVkICVzIElQJWQgJXMnXG4gICAgICAgICAgOiAncnRjcDolZCc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3AtZmI6OTggdHJyLWludCAxMDBcbiAgICAgIHB1c2g6ICdydGNwRmJUcnJJbnQnLFxuICAgICAgcmVnOiAvXnJ0Y3AtZmI6KFxcKnxcXGQqKSB0cnItaW50IChcXGQqKS8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6ICdydGNwLWZiOiVkIHRyci1pbnQgJWQnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3AtZmI6OTggbmFjayBycHNpXG4gICAgICBwdXNoOiAncnRjcEZiJyxcbiAgICAgIHJlZzogL15ydGNwLWZiOihcXCp8XFxkKikgKFtcXHctX10qKSg/OiAoW1xcdy1fXSopKT8vLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICd0eXBlJywgJ3N1YnR5cGUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLnN1YnR5cGUgIT0gbnVsbClcbiAgICAgICAgICA/ICdydGNwLWZiOiVzICVzICVzJ1xuICAgICAgICAgIDogJ3J0Y3AtZmI6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4gICAgICAvLyBhPWV4dG1hcDoxL3JlY3Zvbmx5IFVSSS1ncHMtc3RyaW5nXG4gICAgICAvLyBhPWV4dG1hcDozIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OmVuY3J5cHQgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6c21wdGUtdGMgMjVANjAwLzI0XG4gICAgICBwdXNoOiAnZXh0JyxcbiAgICAgIHJlZzogL15leHRtYXA6KFxcZCspKD86XFwvKFxcdyspKT8oPzogKHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OmVuY3J5cHQpKT8gKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJywgJ2RpcmVjdGlvbicsICdlbmNyeXB0LXVyaScsICd1cmknLCAnY29uZmlnJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgJ2V4dG1hcDolZCcgK1xuICAgICAgICAgIChvLmRpcmVjdGlvbiA/ICcvJXMnIDogJyV2JykgK1xuICAgICAgICAgIChvWydlbmNyeXB0LXVyaSddID8gJyAlcycgOiAnJXYnKSArXG4gICAgICAgICAgJyAlcycgK1xuICAgICAgICAgIChvLmNvbmZpZyA/ICcgJXMnIDogJycpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWV4dG1hcC1hbGxvdy1taXhlZFxuICAgICAgbmFtZTogJ2V4dG1hcEFsbG93TWl4ZWQnLFxuICAgICAgcmVnOiAvXihleHRtYXAtYWxsb3ctbWl4ZWQpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jcnlwdG86MSBBRVNfQ01fMTI4X0hNQUNfU0hBMV84MCBpbmxpbmU6UFMxdVFDVmVlQ0ZDYW5WbWNqa3BQeXdqTldoY1lEMG1YWHR4YVZCUnwyXjIwfDE6MzJcbiAgICAgIHB1c2g6ICdjcnlwdG8nLFxuICAgICAgcmVnOiAvXmNyeXB0bzooXFxkKikgKFtcXHdfXSopIChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdzdWl0ZScsICdjb25maWcnLCAnc2Vzc2lvbkNvbmZpZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uc2Vzc2lvbkNvbmZpZyAhPSBudWxsKVxuICAgICAgICAgID8gJ2NyeXB0bzolZCAlcyAlcyAlcydcbiAgICAgICAgICA6ICdjcnlwdG86JWQgJXMgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zZXR1cDphY3RwYXNzXG4gICAgICBuYW1lOiAnc2V0dXAnLFxuICAgICAgcmVnOiAvXnNldHVwOihcXHcqKS8sXG4gICAgICBmb3JtYXQ6ICdzZXR1cDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y29ubmVjdGlvbjpuZXdcbiAgICAgIG5hbWU6ICdjb25uZWN0aW9uVHlwZScsXG4gICAgICByZWc6IC9eY29ubmVjdGlvbjoobmV3fGV4aXN0aW5nKS8sXG4gICAgICBmb3JtYXQ6ICdjb25uZWN0aW9uOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1taWQ6MVxuICAgICAgbmFtZTogJ21pZCcsXG4gICAgICByZWc6IC9ebWlkOihbXlxcc10qKS8sXG4gICAgICBmb3JtYXQ6ICdtaWQ6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPW1zaWQ6MGM4YjA2NGQtZDgwNy00M2I0LWI0MzQtZjkyYTg4OWQ4NTg3IDk4MTc4Njg1LWQ0MDktNDZlMC04ZTE2LTdlZjBkYjBkYjY0YVxuICAgICAgbmFtZTogJ21zaWQnLFxuICAgICAgcmVnOiAvXm1zaWQ6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdtc2lkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1wdGltZToyMFxuICAgICAgbmFtZTogJ3B0aW1lJyxcbiAgICAgIHJlZzogL15wdGltZTooXFxkKig/OlxcLlxcZCopKikvLFxuICAgICAgZm9ybWF0OiAncHRpbWU6JWQnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPW1heHB0aW1lOjYwXG4gICAgICBuYW1lOiAnbWF4cHRpbWUnLFxuICAgICAgcmVnOiAvXm1heHB0aW1lOihcXGQqKD86XFwuXFxkKikqKS8sXG4gICAgICBmb3JtYXQ6ICdtYXhwdGltZTolZCdcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c2VuZHJlY3ZcbiAgICAgIG5hbWU6ICdkaXJlY3Rpb24nLFxuICAgICAgcmVnOiAvXihzZW5kcmVjdnxyZWN2b25seXxzZW5kb25seXxpbmFjdGl2ZSkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWljZS1saXRlXG4gICAgICBuYW1lOiAnaWNlbGl0ZScsXG4gICAgICByZWc6IC9eKGljZS1saXRlKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aWNlLXVmcmFnOkY3Z0lcbiAgICAgIG5hbWU6ICdpY2VVZnJhZycsXG4gICAgICByZWc6IC9eaWNlLXVmcmFnOihcXFMqKS8sXG4gICAgICBmb3JtYXQ6ICdpY2UtdWZyYWc6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWljZS1wd2Q6eDljbWwvWXppY2hWMitYbGhpTXU4Z1xuICAgICAgbmFtZTogJ2ljZVB3ZCcsXG4gICAgICByZWc6IC9eaWNlLXB3ZDooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLXB3ZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZmluZ2VycHJpbnQ6U0hBLTEgMDA6MTE6MjI6MzM6NDQ6NTU6NjY6Nzc6ODg6OTk6QUE6QkI6Q0M6REQ6RUU6RkY6MDA6MTE6MjI6MzNcbiAgICAgIG5hbWU6ICdmaW5nZXJwcmludCcsXG4gICAgICByZWc6IC9eZmluZ2VycHJpbnQ6KFxcUyopIChcXFMqKS8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ2hhc2gnXSxcbiAgICAgIGZvcm1hdDogJ2ZpbmdlcnByaW50OiVzICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jYW5kaWRhdGU6MCAxIFVEUCAyMTEzNjY3MzI3IDIwMy4wLjExMy4xIDU0NDAwIHR5cCBob3N0XG4gICAgICAvLyBhPWNhbmRpZGF0ZToxMTYyODc1MDgxIDEgdWRwIDIxMTM5MzcxNTEgMTkyLjE2OC4zNC43NSA2MDAxNyB0eXAgaG9zdCBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MzI4OTkxMjk1NyAyIHVkcCAxODQ1NTAxNjk1IDE5My44NC43Ny4xOTQgNjAwMTcgdHlwIHNyZmx4IHJhZGRyIDE5Mi4xNjguMzQuNzUgcnBvcnQgNjAwMTcgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjIyOTgxNTYyMCAxIHRjcCAxNTE4MjgwNDQ3IDE5Mi4xNjguMTUwLjE5IDYwMDE3IHR5cCBob3N0IHRjcHR5cGUgYWN0aXZlIGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICAvLyBhPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdGNwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyB0Y3B0eXBlIHBhc3NpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIHB1c2g6J2NhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXmNhbmRpZGF0ZTooXFxTKikgKFxcZCopIChcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSB0eXAgKFxcUyopKD86IHJhZGRyIChcXFMqKSBycG9ydCAoXFxkKikpPyg/OiB0Y3B0eXBlIChcXFMqKSk/KD86IGdlbmVyYXRpb24gKFxcZCopKT8oPzogbmV0d29yay1pZCAoXFxkKikpPyg/OiBuZXR3b3JrLWNvc3QgKFxcZCopKT8vLFxuICAgICAgbmFtZXM6IFsnZm91bmRhdGlvbicsICdjb21wb25lbnQnLCAndHJhbnNwb3J0JywgJ3ByaW9yaXR5JywgJ2lwJywgJ3BvcnQnLCAndHlwZScsICdyYWRkcicsICdycG9ydCcsICd0Y3B0eXBlJywgJ2dlbmVyYXRpb24nLCAnbmV0d29yay1pZCcsICduZXR3b3JrLWNvc3QnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdjYW5kaWRhdGU6JXMgJWQgJXMgJWQgJXMgJWQgdHlwICVzJztcblxuICAgICAgICBzdHIgKz0gKG8ucmFkZHIgIT0gbnVsbCkgPyAnIHJhZGRyICVzIHJwb3J0ICVkJyA6ICcldiV2JztcblxuICAgICAgICAvLyBOQjogY2FuZGlkYXRlIGhhcyB0aHJlZSBvcHRpb25hbCBjaHVua3MsIHNvICV2b2lkIG1pZGRsZXMgb25lIGlmIGl0J3MgbWlzc2luZ1xuICAgICAgICBzdHIgKz0gKG8udGNwdHlwZSAhPSBudWxsKSA/ICcgdGNwdHlwZSAlcycgOiAnJXYnO1xuXG4gICAgICAgIGlmIChvLmdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIHN0ciArPSAnIGdlbmVyYXRpb24gJWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IChvWyduZXR3b3JrLWlkJ10gIT0gbnVsbCkgPyAnIG5ldHdvcmstaWQgJWQnIDogJyV2JztcbiAgICAgICAgc3RyICs9IChvWyduZXR3b3JrLWNvc3QnXSAhPSBudWxsKSA/ICcgbmV0d29yay1jb3N0ICVkJyA6ICcldic7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWVuZC1vZi1jYW5kaWRhdGVzIChrZWVwIGFmdGVyIHRoZSBjYW5kaWRhdGVzIGxpbmUgZm9yIHJlYWRhYmlsaXR5KVxuICAgICAgbmFtZTogJ2VuZE9mQ2FuZGlkYXRlcycsXG4gICAgICByZWc6IC9eKGVuZC1vZi1jYW5kaWRhdGVzKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cmVtb3RlLWNhbmRpZGF0ZXM6MSAyMDMuMC4xMTMuMSA1NDQwMCAyIDIwMy4wLjExMy4xIDU0NDAxIC4uLlxuICAgICAgbmFtZTogJ3JlbW90ZUNhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXnJlbW90ZS1jYW5kaWRhdGVzOiguKikvLFxuICAgICAgZm9ybWF0OiAncmVtb3RlLWNhbmRpZGF0ZXM6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWljZS1vcHRpb25zOmdvb2dsZS1pY2VcbiAgICAgIG5hbWU6ICdpY2VPcHRpb25zJyxcbiAgICAgIHJlZzogL15pY2Utb3B0aW9uczooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLW9wdGlvbnM6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNzcmM6MjU2NjEwNzU2OSBjbmFtZTp0OVlVOE0xVXhURjhZMUExXG4gICAgICBwdXNoOiAnc3NyY3MnLFxuICAgICAgcmVnOiAvXnNzcmM6KFxcZCopIChbXFx3Xy1dKikoPzo6KC4qKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ2F0dHJpYnV0ZScsICd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgc3RyID0gJ3NzcmM6JWQnO1xuICAgICAgICBpZiAoby5hdHRyaWJ1dGUgIT0gbnVsbCkge1xuICAgICAgICAgIHN0ciArPSAnICVzJztcbiAgICAgICAgICBpZiAoby52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgKz0gJzolcyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNzcmMtZ3JvdXA6RkVDIDEgMlxuICAgICAgLy8gYT1zc3JjLWdyb3VwOkZFQy1GUiAzMDA0MzY0MTk1IDEwODA3NzIyNDFcbiAgICAgIHB1c2g6ICdzc3JjR3JvdXBzJyxcbiAgICAgIC8vIHRva2VuLWNoYXIgPSAleDIxIC8gJXgyMy0yNyAvICV4MkEtMkIgLyAleDJELTJFIC8gJXgzMC0zOSAvICV4NDEtNUEgLyAleDVFLTdFXG4gICAgICByZWc6IC9ec3NyYy1ncm91cDooW1xceDIxXFx4MjNcXHgyNFxceDI1XFx4MjZcXHgyN1xceDJBXFx4MkJcXHgyRFxceDJFXFx3XSopICguKikvLFxuICAgICAgbmFtZXM6IFsnc2VtYW50aWNzJywgJ3NzcmNzJ10sXG4gICAgICBmb3JtYXQ6ICdzc3JjLWdyb3VwOiVzICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1tc2lkLXNlbWFudGljOiBXTVMgSnZsYW01WDNTWDFPUDZwbjIweldvZ3ZhS0p6NUhqZjlPbmxWXG4gICAgICBuYW1lOiAnbXNpZFNlbWFudGljJyxcbiAgICAgIHJlZzogL15tc2lkLXNlbWFudGljOlxccz8oXFx3KikgKFxcUyopLyxcbiAgICAgIG5hbWVzOiBbJ3NlbWFudGljJywgJ3Rva2VuJ10sXG4gICAgICBmb3JtYXQ6ICdtc2lkLXNlbWFudGljOiAlcyAlcycgLy8gc3BhY2UgYWZ0ZXIgJzonIGlzIG5vdCBhY2NpZGVudGFsXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWdyb3VwOkJVTkRMRSBhdWRpbyB2aWRlb1xuICAgICAgcHVzaDogJ2dyb3VwcycsXG4gICAgICByZWc6IC9eZ3JvdXA6KFxcdyopICguKikvLFxuICAgICAgbmFtZXM6IFsndHlwZScsICdtaWRzJ10sXG4gICAgICBmb3JtYXQ6ICdncm91cDolcyAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cnRjcC1tdXhcbiAgICAgIG5hbWU6ICdydGNwTXV4JyxcbiAgICAgIHJlZzogL14ocnRjcC1tdXgpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ydGNwLXJzaXplXG4gICAgICBuYW1lOiAncnRjcFJzaXplJyxcbiAgICAgIHJlZzogL14ocnRjcC1yc2l6ZSkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNjdHBtYXA6NTAwMCB3ZWJydGMtZGF0YWNoYW5uZWwgMTAyNFxuICAgICAgbmFtZTogJ3NjdHBtYXAnLFxuICAgICAgcmVnOiAvXnNjdHBtYXA6KFtcXHdfL10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsnc2N0cG1hcE51bWJlcicsICdhcHAnLCAnbWF4TWVzc2FnZVNpemUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLm1heE1lc3NhZ2VTaXplICE9IG51bGwpXG4gICAgICAgICAgPyAnc2N0cG1hcDolcyAlcyAlcydcbiAgICAgICAgICA6ICdzY3RwbWFwOiVzICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9eC1nb29nbGUtZmxhZzpjb25mZXJlbmNlXG4gICAgICBuYW1lOiAneEdvb2dsZUZsYWcnLFxuICAgICAgcmVnOiAvXngtZ29vZ2xlLWZsYWc6KFteXFxzXSopLyxcbiAgICAgIGZvcm1hdDogJ3gtZ29vZ2xlLWZsYWc6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJpZDoxIHNlbmQgbWF4LXdpZHRoPTEyODA7bWF4LWhlaWdodD03MjA7bWF4LWZwcz0zMDtkZXBlbmQ9MFxuICAgICAgcHVzaDogJ3JpZHMnLFxuICAgICAgcmVnOiAvXnJpZDooW1xcZFxcd10rKSAoXFx3KykoPzogKFtcXFN8IF0qKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ2RpcmVjdGlvbicsICdwYXJhbXMnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLnBhcmFtcykgPyAncmlkOiVzICVzICVzJyA6ICdyaWQ6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1pbWFnZWF0dHI6OTcgc2VuZCBbeD04MDAseT02NDAsc2FyPTEuMSxxPTAuNl0gW3g9NDgwLHk9MzIwXSByZWN2IFt4PTMzMCx5PTI1MF1cbiAgICAgIC8vIGE9aW1hZ2VhdHRyOiogc2VuZCBbeD04MDAseT02NDBdIHJlY3YgKlxuICAgICAgLy8gYT1pbWFnZWF0dHI6MTAwIHJlY3YgW3g9MzIwLHk9MjQwXVxuICAgICAgcHVzaDogJ2ltYWdlYXR0cnMnLFxuICAgICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgICAgICAvLyBhPWltYWdlYXR0cjo5N1xuICAgICAgICAnXmltYWdlYXR0cjooXFxcXGQrfFxcXFwqKScgK1xuICAgICAgICAvLyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdXG4gICAgICAgICdbXFxcXHNcXFxcdF0rKHNlbmR8cmVjdilbXFxcXHNcXFxcdF0rKFxcXFwqfFxcXFxbXFxcXFMrXFxcXF0oPzpbXFxcXHNcXFxcdF0rXFxcXFtcXFxcUytcXFxcXSkqKScgK1xuICAgICAgICAvLyByZWN2IFt4PTMzMCx5PTI1MF1cbiAgICAgICAgJyg/OltcXFxcc1xcXFx0XSsocmVjdnxzZW5kKVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopKT8nXG4gICAgICApLFxuICAgICAgbmFtZXM6IFsncHQnLCAnZGlyMScsICdhdHRyczEnLCAnZGlyMicsICdhdHRyczInXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICdpbWFnZWF0dHI6JXMgJXMgJXMnICsgKG8uZGlyMiA/ICcgJXMgJXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zaW11bGNhc3Q6c2VuZCAxLDIsMzt+NCx+NSByZWN2IDY7fjcsfjhcbiAgICAgIC8vIGE9c2ltdWxjYXN0OnJlY3YgMTs0LDUgc2VuZCA2OzdcbiAgICAgIG5hbWU6ICdzaW11bGNhc3QnLFxuICAgICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgICAgICAvLyBhPXNpbXVsY2FzdDpcbiAgICAgICAgJ15zaW11bGNhc3Q6JyArXG4gICAgICAgIC8vIHNlbmQgMSwyLDM7fjQsfjVcbiAgICAgICAgJyhzZW5kfHJlY3YpIChbYS16QS1aMC05XFxcXC1ffjssXSspJyArXG4gICAgICAgIC8vIHNwYWNlICsgcmVjdiA2O343LH44XG4gICAgICAgICcoPzpcXFxccz8oc2VuZHxyZWN2KSAoW2EtekEtWjAtOVxcXFwtX347LF0rKSk/JyArXG4gICAgICAgIC8vIGVuZFxuICAgICAgICAnJCdcbiAgICAgICksXG4gICAgICBuYW1lczogWydkaXIxJywgJ2xpc3QxJywgJ2RpcjInLCAnbGlzdDInXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICdzaW11bGNhc3Q6JXMgJXMnICsgKG8uZGlyMiA/ICcgJXMgJXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gb2xkIHNpbXVsY2FzdCBkcmFmdCAwMyAoaW1wbGVtZW50ZWQgYnkgRmlyZWZveClcbiAgICAgIC8vICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNkcC1zaW11bGNhc3QtMDNcbiAgICAgIC8vIGE9c2ltdWxjYXN0OiByZWN2IHB0PTk3Ozk4IHNlbmQgcHQ9OTdcbiAgICAgIC8vIGE9c2ltdWxjYXN0OiBzZW5kIHJpZD01OzY7NyBwYXVzZWQ9Niw3XG4gICAgICBuYW1lOiAnc2ltdWxjYXN0XzAzJyxcbiAgICAgIHJlZzogL15zaW11bGNhc3Q6W1xcc1xcdF0rKFtcXFMrXFxzXFx0XSspJC8sXG4gICAgICBuYW1lczogWyd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiAnc2ltdWxjYXN0OiAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZnJhbWVyYXRlOjI1XG4gICAgICAvLyBhPWZyYW1lcmF0ZToyOS45N1xuICAgICAgbmFtZTogJ2ZyYW1lcmF0ZScsXG4gICAgICByZWc6IC9eZnJhbWVyYXRlOihcXGQrKD86JHxcXC5cXGQrKSkvLFxuICAgICAgZm9ybWF0OiAnZnJhbWVyYXRlOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDNDU3MFxuICAgICAgLy8gYT1zb3VyY2UtZmlsdGVyOiBpbmNsIElOIElQNCAyMzkuNS4yLjMxIDEwLjEuMTUuNVxuICAgICAgbmFtZTogJ3NvdXJjZUZpbHRlcicsXG4gICAgICByZWc6IC9ec291cmNlLWZpbHRlcjogKihleGNsfGluY2wpIChcXFMqKSAoSVA0fElQNnxcXCopIChcXFMqKSAoLiopLyxcbiAgICAgIG5hbWVzOiBbJ2ZpbHRlck1vZGUnLCAnbmV0VHlwZScsICdhZGRyZXNzVHlwZXMnLCAnZGVzdEFkZHJlc3MnLCAnc3JjTGlzdCddLFxuICAgICAgZm9ybWF0OiAnc291cmNlLWZpbHRlcjogJXMgJXMgJXMgJXMgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWJ1bmRsZS1vbmx5XG4gICAgICBuYW1lOiAnYnVuZGxlT25seScsXG4gICAgICByZWc6IC9eKGJ1bmRsZS1vbmx5KS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9bGFiZWw6MVxuICAgICAgbmFtZTogJ2xhYmVsJyxcbiAgICAgIHJlZzogL15sYWJlbDooLispLyxcbiAgICAgIGZvcm1hdDogJ2xhYmVsOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDIHZlcnNpb24gMjYgZm9yIFNDVFAgb3ZlciBEVExTXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYjc2VjdGlvbi01XG4gICAgICBuYW1lOiAnc2N0cFBvcnQnLFxuICAgICAgcmVnOiAvXnNjdHAtcG9ydDooXFxkKykkLyxcbiAgICAgIGZvcm1hdDogJ3NjdHAtcG9ydDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFJGQyB2ZXJzaW9uIDI2IGZvciBTQ1RQIG92ZXIgRFRMU1xuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2I3NlY3Rpb24tNlxuICAgICAgbmFtZTogJ21heE1lc3NhZ2VTaXplJyxcbiAgICAgIHJlZzogL15tYXgtbWVzc2FnZS1zaXplOihcXGQrKSQvLFxuICAgICAgZm9ybWF0OiAnbWF4LW1lc3NhZ2Utc2l6ZTolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFJGQzcyNzNcbiAgICAgIC8vIGE9dHMtcmVmY2xrOnB0cD1JRUVFMTU4OC0yMDA4OjM5LUE3LTk0LUZGLUZFLTA3LUNCLUQwOjM3XG4gICAgICBwdXNoOid0c1JlZkNsb2NrcycsXG4gICAgICByZWc6IC9edHMtcmVmY2xrOihbXlxccz1dKikoPzo9KFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsnY2xrc3JjJywgJ2Nsa3NyY0V4dCddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ3RzLXJlZmNsazolcycgKyAoby5jbGtzcmNFeHQgIT0gbnVsbCA/ICc9JXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDNzI3M1xuICAgICAgLy8gYT1tZWRpYWNsazpkaXJlY3Q9OTYzMjE0NDI0XG4gICAgICBuYW1lOidtZWRpYUNsaycsXG4gICAgICByZWc6IC9ebWVkaWFjbGs6KD86aWQ9KFxcUyopKT8gKihbXlxccz1dKikoPzo9KFxcUyopKT8oPzogKnJhdGU9KFxcZCspXFwvKFxcZCspKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnbWVkaWFDbG9ja05hbWUnLCAnbWVkaWFDbG9ja1ZhbHVlJywgJ3JhdGVOdW1lcmF0b3InLCAncmF0ZURlbm9taW5hdG9yJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnbWVkaWFjbGs6JztcbiAgICAgICAgc3RyICs9IChvLmlkICE9IG51bGwgPyAnaWQ9JXMgJXMnIDogJyV2JXMnKTtcbiAgICAgICAgc3RyICs9IChvLm1lZGlhQ2xvY2tWYWx1ZSAhPSBudWxsID8gJz0lcycgOiAnJyk7XG4gICAgICAgIHN0ciArPSAoby5yYXRlTnVtZXJhdG9yICE9IG51bGwgPyAnIHJhdGU9JXMnIDogJycpO1xuICAgICAgICBzdHIgKz0gKG8ucmF0ZURlbm9taW5hdG9yICE9IG51bGwgPyAnLyVzJyA6ICcnKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9a2V5d2RzOmtleXdvcmRzXG4gICAgICBuYW1lOiAna2V5d29yZHMnLFxuICAgICAgcmVnOiAvXmtleXdkczooLispJC8sXG4gICAgICBmb3JtYXQ6ICdrZXl3ZHM6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNvbnRlbnQ6bWFpblxuICAgICAgbmFtZTogJ2NvbnRlbnQnLFxuICAgICAgcmVnOiAvXmNvbnRlbnQ6KC4rKS8sXG4gICAgICBmb3JtYXQ6ICdjb250ZW50OiVzJ1xuICAgIH0sXG4gICAgLy8gQkZDUCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDU4M1xuICAgIHtcbiAgICAgIC8vIGE9Zmxvb3JjdHJsOmMtc1xuICAgICAgbmFtZTogJ2JmY3BGbG9vckN0cmwnLFxuICAgICAgcmVnOiAvXmZsb29yY3RybDooYy1vbmx5fHMtb25seXxjLXMpLyxcbiAgICAgIGZvcm1hdDogJ2Zsb29yY3RybDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y29uZmlkOjFcbiAgICAgIG5hbWU6ICdiZmNwQ29uZklkJyxcbiAgICAgIHJlZzogL15jb25maWQ6KFxcZCspLyxcbiAgICAgIGZvcm1hdDogJ2NvbmZpZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9dXNlcmlkOjFcbiAgICAgIG5hbWU6ICdiZmNwVXNlcklkJyxcbiAgICAgIHJlZzogL151c2VyaWQ6KFxcZCspLyxcbiAgICAgIGZvcm1hdDogJ3VzZXJpZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Zmxvb3JpZDoxXG4gICAgICBuYW1lOiAnYmZjcEZsb29ySWQnLFxuICAgICAgcmVnOiAvXmZsb29yaWQ6KC4rKSAoPzptLXN0cmVhbXxtc3RybSk6KC4rKS8sXG4gICAgICBuYW1lczogWydpZCcsICdtU3RyZWFtJ10sXG4gICAgICBmb3JtYXQ6ICdmbG9vcmlkOiVzIG1zdHJtOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYW55IGE9IHRoYXQgd2UgZG9uJ3QgdW5kZXJzdGFuZCBpcyBrZXB0IHZlcmJhdGltIG9uIG1lZGlhLmludmFsaWRcbiAgICAgIHB1c2g6ICdpbnZhbGlkJyxcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJ11cbiAgICB9XG4gIF1cbn07XG5cbi8vIHNldCBzZW5zaWJsZSBkZWZhdWx0cyB0byBhdm9pZCBwb2xsdXRpbmcgdGhlIGdyYW1tYXIgd2l0aCBib3JpbmcgZGV0YWlsc1xuT2JqZWN0LmtleXMoZ3JhbW1hcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBvYmpzID0gZ3JhbW1hcltrZXldO1xuICBvYmpzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghb2JqLnJlZykge1xuICAgICAgb2JqLnJlZyA9IC8oLiopLztcbiAgICB9XG4gICAgaWYgKCFvYmouZm9ybWF0KSB7XG4gICAgICBvYmouZm9ybWF0ID0gJyVzJztcbiAgICB9XG4gIH0pO1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/sdp-transform/lib/grammar.js\n");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/sdp-transform/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var parser = __webpack_require__(/*! ./parser */ \"./node_modules/sdp-transform/lib/parser.js\");\nvar writer = __webpack_require__(/*! ./writer */ \"./node_modules/sdp-transform/lib/writer.js\");\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseParams = parser.parseParams;\nexports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2RwLXRyYW5zZm9ybS9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9ub2RlX21vZHVsZXMvc2RwLXRyYW5zZm9ybS9saWIvaW5kZXguanM/OTNiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcbnZhciB3cml0ZXIgPSByZXF1aXJlKCcuL3dyaXRlcicpO1xuXG5leHBvcnRzLndyaXRlID0gd3JpdGVyO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlci5wYXJzZTtcbmV4cG9ydHMucGFyc2VQYXJhbXMgPSBwYXJzZXIucGFyc2VQYXJhbXM7XG5leHBvcnRzLnBhcnNlRm10cENvbmZpZyA9IHBhcnNlci5wYXJzZUZtdHBDb25maWc7IC8vIEFsaWFzIG9mIHBhcnNlUGFyYW1zKCkuXG5leHBvcnRzLnBhcnNlUGF5bG9hZHMgPSBwYXJzZXIucGFyc2VQYXlsb2FkcztcbmV4cG9ydHMucGFyc2VSZW1vdGVDYW5kaWRhdGVzID0gcGFyc2VyLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcztcbmV4cG9ydHMucGFyc2VJbWFnZUF0dHJpYnV0ZXMgPSBwYXJzZXIucGFyc2VJbWFnZUF0dHJpYnV0ZXM7XG5leHBvcnRzLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCA9IHBhcnNlci5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3Q7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/sdp-transform/lib/index.js\n");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/parser.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/parser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  }\n  else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i+1] != null) {\n        location[names[i]] = toIntIfInt(match[i+1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  }\n  else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ?\n    {} :  // blank object that will be pushed\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\");\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {}\n    , media = []\n    , location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({rtp: [], fmtp: []});\n      location = media[media.length-1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar paramReducer = function (acc, expr) {\n  var s = expr.split(/=(.+)/, 2);\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  } else if (s.length === 1 && expr.length > 1) {\n    acc[s[0]] = undefined;\n  }\n  return acc;\n};\n\nexports.parseParams = function (str) {\n  return str.split(/;\\s?/).reduce(paramReducer, {});\n};\n\n// For backward compatibility - alias will be removed in 3.0.0\nexports.parseFmtpConfig = exports.parseParams;\n\nexports.parsePayloads = function (str) {\n  return str.toString().split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\nexports.parseImageAttributes = function (str) {\n  return str.split(' ').map(function (item) {\n    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});\n  });\n};\n\nexports.parseSimulcastStreamList = function (str) {\n  return str.split(';').map(function (stream) {\n    return stream.split(',').map(function (format) {\n      var scid, paused = false;\n\n      if (format[0] !== '~') {\n        scid = toIntIfInt(format);\n      } else {\n        scid = toIntIfInt(format.substring(1, format.length));\n        paused = true;\n      }\n\n      return {\n        scid: scid,\n        paused: paused\n      };\n    });\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2RwLXRyYW5zZm9ybS9saWIvcGFyc2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL3BhcnNlci5qcz85NWU4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b0ludElmSW50ID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIFN0cmluZyhOdW1iZXIodikpID09PSB2ID8gTnVtYmVyKHYpIDogdjtcbn07XG5cbnZhciBhdHRhY2hQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG1hdGNoLCBsb2NhdGlvbiwgbmFtZXMsIHJhd05hbWUpIHtcbiAgaWYgKHJhd05hbWUgJiYgIW5hbWVzKSB7XG4gICAgbG9jYXRpb25bcmF3TmFtZV0gPSB0b0ludElmSW50KG1hdGNoWzFdKTtcbiAgfVxuICBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAobWF0Y2hbaSsxXSAhPSBudWxsKSB7XG4gICAgICAgIGxvY2F0aW9uW25hbWVzW2ldXSA9IHRvSW50SWZJbnQobWF0Y2hbaSsxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGFyc2VSZWcgPSBmdW5jdGlvbiAob2JqLCBsb2NhdGlvbiwgY29udGVudCkge1xuICB2YXIgbmVlZHNCbGFuayA9IG9iai5uYW1lICYmIG9iai5uYW1lcztcbiAgaWYgKG9iai5wdXNoICYmICFsb2NhdGlvbltvYmoucHVzaF0pIHtcbiAgICBsb2NhdGlvbltvYmoucHVzaF0gPSBbXTtcbiAgfVxuICBlbHNlIGlmIChuZWVkc0JsYW5rICYmICFsb2NhdGlvbltvYmoubmFtZV0pIHtcbiAgICBsb2NhdGlvbltvYmoubmFtZV0gPSB7fTtcbiAgfVxuICB2YXIga2V5TG9jYXRpb24gPSBvYmoucHVzaCA/XG4gICAge30gOiAgLy8gYmxhbmsgb2JqZWN0IHRoYXQgd2lsbCBiZSBwdXNoZWRcbiAgICBuZWVkc0JsYW5rID8gbG9jYXRpb25bb2JqLm5hbWVdIDogbG9jYXRpb247IC8vIG90aGVyd2lzZSwgbmFtZWQgbG9jYXRpb24gb3Igcm9vdFxuXG4gIGF0dGFjaFByb3BlcnRpZXMoY29udGVudC5tYXRjaChvYmoucmVnKSwga2V5TG9jYXRpb24sIG9iai5uYW1lcywgb2JqLm5hbWUpO1xuXG4gIGlmIChvYmoucHVzaCkge1xuICAgIGxvY2F0aW9uW29iai5wdXNoXS5wdXNoKGtleUxvY2F0aW9uKTtcbiAgfVxufTtcblxudmFyIGdyYW1tYXIgPSByZXF1aXJlKCcuL2dyYW1tYXInKTtcbnZhciB2YWxpZExpbmUgPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXihbYS16XSk9KC4qKS8pO1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNkcCkge1xuICB2YXIgc2Vzc2lvbiA9IHt9XG4gICAgLCBtZWRpYSA9IFtdXG4gICAgLCBsb2NhdGlvbiA9IHNlc3Npb247IC8vIHBvaW50cyBhdCB3aGVyZSBwcm9wZXJ0aWVzIGdvIHVuZGVyIChvbmUgb2YgdGhlIGFib3ZlKVxuXG4gIC8vIHBhcnNlIGxpbmVzIHdlIHVuZGVyc3RhbmRcbiAgc2RwLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLykuZmlsdGVyKHZhbGlkTGluZSkuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgIHZhciB0eXBlID0gbFswXTtcbiAgICB2YXIgY29udGVudCA9IGwuc2xpY2UoMik7XG4gICAgaWYgKHR5cGUgPT09ICdtJykge1xuICAgICAgbWVkaWEucHVzaCh7cnRwOiBbXSwgZm10cDogW119KTtcbiAgICAgIGxvY2F0aW9uID0gbWVkaWFbbWVkaWEubGVuZ3RoLTFdOyAvLyBwb2ludCBhdCBsYXRlc3QgbWVkaWEgbGluZVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgKGdyYW1tYXJbdHlwZV0gfHwgW10pLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICB2YXIgb2JqID0gZ3JhbW1hclt0eXBlXVtqXTtcbiAgICAgIGlmIChvYmoucmVnLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUmVnKG9iaiwgbG9jYXRpb24sIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgc2Vzc2lvbi5tZWRpYSA9IG1lZGlhOyAvLyBsaW5rIGl0IHVwXG4gIHJldHVybiBzZXNzaW9uO1xufTtcblxudmFyIHBhcmFtUmVkdWNlciA9IGZ1bmN0aW9uIChhY2MsIGV4cHIpIHtcbiAgdmFyIHMgPSBleHByLnNwbGl0KC89KC4rKS8sIDIpO1xuICBpZiAocy5sZW5ndGggPT09IDIpIHtcbiAgICBhY2Nbc1swXV0gPSB0b0ludElmSW50KHNbMV0pO1xuICB9IGVsc2UgaWYgKHMubGVuZ3RoID09PSAxICYmIGV4cHIubGVuZ3RoID4gMSkge1xuICAgIGFjY1tzWzBdXSA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gYWNjO1xufTtcblxuZXhwb3J0cy5wYXJzZVBhcmFtcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvO1xccz8vKS5yZWR1Y2UocGFyYW1SZWR1Y2VyLCB7fSk7XG59O1xuXG4vLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSAtIGFsaWFzIHdpbGwgYmUgcmVtb3ZlZCBpbiAzLjAuMFxuZXhwb3J0cy5wYXJzZUZtdHBDb25maWcgPSBleHBvcnRzLnBhcnNlUGFyYW1zO1xuXG5leHBvcnRzLnBhcnNlUGF5bG9hZHMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIudG9TdHJpbmcoKS5zcGxpdCgnICcpLm1hcChOdW1iZXIpO1xufTtcblxuZXhwb3J0cy5wYXJzZVJlbW90ZUNhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBjYW5kaWRhdGVzID0gW107XG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnICcpLm1hcCh0b0ludElmSW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICBjb21wb25lbnQ6IHBhcnRzW2ldLFxuICAgICAgaXA6IHBhcnRzW2kgKyAxXSxcbiAgICAgIHBvcnQ6IHBhcnRzW2kgKyAyXVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuZXhwb3J0cy5wYXJzZUltYWdlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLnN1YnN0cmluZygxLCBpdGVtLmxlbmd0aC0xKS5zcGxpdCgnLCcpLnJlZHVjZShwYXJhbVJlZHVjZXIsIHt9KTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnOycpLm1hcChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgcmV0dXJuIHN0cmVhbS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICB2YXIgc2NpZCwgcGF1c2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChmb3JtYXRbMF0gIT09ICd+Jykge1xuICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NpZCA9IHRvSW50SWZJbnQoZm9ybWF0LnN1YnN0cmluZygxLCBmb3JtYXQubGVuZ3RoKSk7XG4gICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaWQ6IHNjaWQsXG4gICAgICAgIHBhdXNlZDogcGF1c2VkXG4gICAgICB9O1xuICAgIH0pO1xuICB9KTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/sdp-transform/lib/parser.js\n");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/writer.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/writer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\");\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2RwLXRyYW5zZm9ybS9saWIvd3JpdGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL3dyaXRlci5qcz9mMGJjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBncmFtbWFyID0gcmVxdWlyZSgnLi9ncmFtbWFyJyk7XG5cbi8vIGN1c3RvbWl6ZWQgdXRpbC5mb3JtYXQgLSBkaXNjYXJkcyBleGNlc3MgYXJndW1lbnRzIGFuZCBjYW4gdm9pZCBtaWRkbGUgb25lc1xudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkdiVdL2c7XG52YXIgZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdFN0cikge1xuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHJldHVybiBmb3JtYXRTdHIucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICByZXR1cm4geDsgLy8gbWlzc2luZyBhcmd1bWVudFxuICAgIH1cbiAgICB2YXIgYXJnID0gYXJnc1tpXTtcbiAgICBpICs9IDE7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgY2FzZSAnJSUnOlxuICAgICAgcmV0dXJuICclJztcbiAgICBjYXNlICclcyc6XG4gICAgICByZXR1cm4gU3RyaW5nKGFyZyk7XG4gICAgY2FzZSAnJWQnOlxuICAgICAgcmV0dXJuIE51bWJlcihhcmcpO1xuICAgIGNhc2UgJyV2JzpcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH0pO1xuICAvLyBOQjogd2UgZGlzY2FyZCBleGNlc3MgYXJndW1lbnRzIC0gdGhleSBhcmUgdHlwaWNhbGx5IHVuZGVmaW5lZCBmcm9tIG1ha2VMaW5lXG59O1xuXG52YXIgbWFrZUxpbmUgPSBmdW5jdGlvbiAodHlwZSwgb2JqLCBsb2NhdGlvbikge1xuICB2YXIgc3RyID0gb2JqLmZvcm1hdCBpbnN0YW5jZW9mIEZ1bmN0aW9uID9cbiAgICAob2JqLmZvcm1hdChvYmoucHVzaCA/IGxvY2F0aW9uIDogbG9jYXRpb25bb2JqLm5hbWVdKSkgOlxuICAgIG9iai5mb3JtYXQ7XG5cbiAgdmFyIGFyZ3MgPSBbdHlwZSArICc9JyArIHN0cl07XG4gIGlmIChvYmoubmFtZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5uYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG4gPSBvYmoubmFtZXNbaV07XG4gICAgICBpZiAob2JqLm5hbWUpIHtcbiAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXVtuXSk7XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gZm9yIG1MaW5lIGFuZCBwdXNoIGF0dHJpYnV0ZXNcbiAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVdKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3MpO1xufTtcblxuLy8gUkZDIHNwZWNpZmllZCBvcmRlclxuLy8gVE9ETzogZXh0ZW5kIHRoaXMgd2l0aCBhbGwgdGhlIHJlc3RcbnZhciBkZWZhdWx0T3V0ZXJPcmRlciA9IFtcbiAgJ3YnLCAnbycsICdzJywgJ2knLFxuICAndScsICdlJywgJ3AnLCAnYycsXG4gICdiJywgJ3QnLCAncicsICd6JywgJ2EnXG5dO1xudmFyIGRlZmF1bHRJbm5lck9yZGVyID0gWydpJywgJ2MnLCAnYicsICdhJ107XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgLy8gZW5zdXJlIGNlcnRhaW4gcHJvcGVydGllcyBleGlzdFxuICBpZiAoc2Vzc2lvbi52ZXJzaW9uID09IG51bGwpIHtcbiAgICBzZXNzaW9uLnZlcnNpb24gPSAwOyAvLyAndj0wJyBtdXN0IGJlIHRoZXJlIChvbmx5IGRlZmluZWQgdmVyc2lvbiBhdG0pXG4gIH1cbiAgaWYgKHNlc3Npb24ubmFtZSA9PSBudWxsKSB7XG4gICAgc2Vzc2lvbi5uYW1lID0gJyAnOyAvLyAncz0gJyBtdXN0IGJlIHRoZXJlIGlmIG5vIG1lYW5pbmdmdWwgbmFtZSBzZXRcbiAgfVxuICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgaWYgKG1MaW5lLnBheWxvYWRzID09IG51bGwpIHtcbiAgICAgIG1MaW5lLnBheWxvYWRzID0gJyc7XG4gICAgfVxuICB9KTtcblxuICB2YXIgb3V0ZXJPcmRlciA9IG9wdHMub3V0ZXJPcmRlciB8fCBkZWZhdWx0T3V0ZXJPcmRlcjtcbiAgdmFyIGlubmVyT3JkZXIgPSBvcHRzLmlubmVyT3JkZXIgfHwgZGVmYXVsdElubmVyT3JkZXI7XG4gIHZhciBzZHAgPSBbXTtcblxuICAvLyBsb29wIHRocm91Z2ggb3V0ZXJPcmRlciBmb3IgbWF0Y2hpbmcgcHJvcGVydGllcyBvbiBzZXNzaW9uXG4gIG91dGVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGdyYW1tYXJbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICBpZiAob2JqLm5hbWUgaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgc2Vzc2lvbikpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqLnB1c2ggaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5wdXNoXSAhPSBudWxsKSB7XG4gICAgICAgIHNlc3Npb25bb2JqLnB1c2hdLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBlbCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gdGhlbiBmb3IgZWFjaCBtZWRpYSBsaW5lLCBmb2xsb3cgdGhlIGlubmVyT3JkZXJcbiAgc2Vzc2lvbi5tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChtTGluZSkge1xuICAgIHNkcC5wdXNoKG1ha2VMaW5lKCdtJywgZ3JhbW1hci5tWzBdLCBtTGluZSkpO1xuXG4gICAgaW5uZXJPcmRlci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqLm5hbWUgaW4gbUxpbmUgJiYgbUxpbmVbb2JqLm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIG1MaW5lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqLnB1c2ggaW4gbUxpbmUgJiYgbUxpbmVbb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgICBtTGluZVtvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgZWwpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzZHAuam9pbignXFxyXFxuJykgKyAnXFxyXFxuJztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/sdp-transform/lib/writer.js\n");

/***/ }),

/***/ "./src/conference-api.ts":
/*!*******************************!*\
  !*** ./src/conference-api.ts ***!
  \*******************************/
/*! exports provided: ConferenceApi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConferenceApi\", function() { return ConferenceApi; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _mediasoup_socket_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mediasoup-socket-api */ \"./src/mediasoup-socket-api.ts\");\n/* harmony import */ var mediasoup_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mediasoup-client */ \"./node_modules/mediasoup-client/lib/index.js\");\n/* harmony import */ var mediasoup_client__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mediasoup_client__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_4__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass ConferenceApi extends events__WEBPACK_IMPORTED_MODULE_1__[\"EventEmitter\"] {\r\n    constructor(configs) {\r\n        super();\r\n        this.connectors = new Map();\r\n        this.layers = new Map();\r\n        this.timeouts = [];\r\n        this.configs = Object.assign({ url: `https://rpc.codeda.com`, kinds: ['video', 'audio'], maxIncomingBitrate: 0, timeout: {\r\n                stats: 1000,\r\n                transport: 3000,\r\n                consumer: 5000\r\n            }, retryConsumerTimeout: 1000 }, configs);\r\n        this.log = Object(debug__WEBPACK_IMPORTED_MODULE_4__[\"debug\"])(`conference-api [${this.configs.stream}]:`);\r\n        this.api = new _mediasoup_socket_api__WEBPACK_IMPORTED_MODULE_2__[\"MediasoupSocketApi\"](this.configs.url, this.configs.token, this.log);\r\n        this.device = new mediasoup_client__WEBPACK_IMPORTED_MODULE_3__[\"Device\"]();\r\n    }\r\n    setPreferredLayers(layers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.operation === _constants__WEBPACK_IMPORTED_MODULE_0__[\"API_OPERATION\"].SUBSCRIBE) {\r\n                const kind = 'video';\r\n                this.layers.set(kind, layers);\r\n                const consumer = this.connectors.get(kind);\r\n                if (consumer && consumer !== true) {\r\n                    try {\r\n                        yield this.api.setPreferredLayers({ consumerId: consumer.id, layers });\r\n                    }\r\n                    catch (e) { }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    addTrack(track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.log('addTrack', track);\r\n            if (this.operation === _constants__WEBPACK_IMPORTED_MODULE_0__[\"API_OPERATION\"].PUBLISH && this.mediaStream) {\r\n                this.mediaStream.addTrack(track);\r\n                this.emit(\"addtrack\", new MediaStreamTrackEvent(\"addtrack\", { track }));\r\n                yield this.publishTrack(track);\r\n            }\r\n        });\r\n    }\r\n    removeTrack(track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.log('removeTrack', track);\r\n            if (this.operation === _constants__WEBPACK_IMPORTED_MODULE_0__[\"API_OPERATION\"].PUBLISH && this.mediaStream) {\r\n                this.mediaStream.removeTrack(track);\r\n                this.emit(\"removetrack\", new MediaStreamTrackEvent(\"removetrack\", { track }));\r\n                const producer = this.connectors.get(track.kind);\r\n                if (producer && producer !== true) {\r\n                    producer.close();\r\n                    producer.emit('close');\r\n                }\r\n            }\r\n        });\r\n    }\r\n    setMaxPublisherBitrate(bitrate) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.configs.maxIncomingBitrate = bitrate;\r\n            if (this.transport) {\r\n                yield this.api.setMaxIncomingBitrate({ transportId: this.transport.id, bitrate });\r\n            }\r\n        });\r\n    }\r\n    updateKinds(kinds) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.operation === _constants__WEBPACK_IMPORTED_MODULE_0__[\"API_OPERATION\"].SUBSCRIBE) {\r\n                this.log('updateKinds', kinds);\r\n                const oldKinds = this.configs.kinds;\r\n                this.configs.kinds = kinds;\r\n                for (const kind of oldKinds) {\r\n                    if (!kinds.includes(kind)) {\r\n                        const connector = this.connectors.get(kind);\r\n                        if (connector) {\r\n                            if (connector !== true) {\r\n                                connector.close();\r\n                                connector.emit('close');\r\n                            }\r\n                            else {\r\n                                this.connectors.delete(kind);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                const promises = [];\r\n                for (const kind of kinds) {\r\n                    if (!this.connectors.get(kind)) {\r\n                        promises.push(this.subscribeTrack(kind));\r\n                    }\r\n                }\r\n                yield Promise.all(promises);\r\n            }\r\n        });\r\n    }\r\n    init(operation) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.operation) {\r\n                throw new Error(\"Already processing\");\r\n            }\r\n            this.operation = operation;\r\n            if (!this.device.loaded) {\r\n                yield this.api.initSocket();\r\n                const { routerRtpCapabilities, iceServers, simulcast, timeout } = yield this.api.getServerConfigs();\r\n                if (routerRtpCapabilities.headerExtensions) {\r\n                    routerRtpCapabilities.headerExtensions = routerRtpCapabilities.headerExtensions.\r\n                        filter((ext) => ext.uri !== 'urn:3gpp:video-orientation');\r\n                }\r\n                yield this.device.load({ routerRtpCapabilities });\r\n                this.iceServers = iceServers;\r\n                this.simulcast = simulcast;\r\n                this.configs.timeout = Object.assign(Object.assign({}, this.configs.timeout), timeout);\r\n            }\r\n            yield this.getTransport();\r\n        });\r\n    }\r\n    publish(mediaStream) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.init(_constants__WEBPACK_IMPORTED_MODULE_0__[\"API_OPERATION\"].PUBLISH);\r\n            this.mediaStream = mediaStream;\r\n            yield Promise.all(mediaStream.getTracks().map(track => this.publishTrack(track)));\r\n            return mediaStream;\r\n        });\r\n    }\r\n    subscribe() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.init(_constants__WEBPACK_IMPORTED_MODULE_0__[\"API_OPERATION\"].SUBSCRIBE);\r\n            const mediaStream = this.mediaStream || new MediaStream();\r\n            this.mediaStream = mediaStream;\r\n            this.configs.kinds.map((kind) => __awaiter(this, void 0, void 0, function* () {\r\n                yield this.subscribeTrack(kind);\r\n            }));\r\n            return mediaStream;\r\n        });\r\n    }\r\n    subscribeTrack(kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const api = this;\r\n            this.connectors.set(kind, true);\r\n            const onClose = () => __awaiter(this, void 0, void 0, function* () {\r\n                if (this.mediaStream) {\r\n                    consumer.track.stop();\r\n                    this.mediaStream.removeTrack(consumer.track);\r\n                    this.emit(\"removetrack\", new MediaStreamTrackEvent(\"removetrack\", { track: consumer.track }));\r\n                }\r\n                if (this.transport && !this.transport.closed) {\r\n                    const _consumer = this.connectors.get(kind);\r\n                    try {\r\n                        yield this.api.closeConsumer({ consumerId: consumer.id });\r\n                    }\r\n                    catch (e) { }\r\n                    if (_consumer && _consumer !== true && consumer.id === _consumer.id) {\r\n                        this.connectors.delete(consumer.track.kind);\r\n                        if (this.mediaStream) {\r\n                            if (this.transport && this.configs.kinds.includes(kind)) {\r\n                                yield this.subscribeTrack(kind);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            const consumer = yield this.consume(this.transport, this.configs.stream, kind);\r\n            consumer.on('close', onClose);\r\n            if (this.connectors.get(kind) === true) {\r\n                this.connectors.set(kind, consumer);\r\n                this.emit('newConsumerId', { id: consumer.id, kind });\r\n                this.listenStats(consumer, 'inbound-rtp');\r\n                yield api.api.resumeConsumer({ consumerId: consumer.id });\r\n                if (this.mediaStream) {\r\n                    this.mediaStream.addTrack(consumer.track);\r\n                    this.emit(\"addtrack\", new MediaStreamTrackEvent(\"addtrack\", { track: consumer.track }));\r\n                }\r\n            }\r\n            else {\r\n                consumer.close();\r\n                consumer.emit('close');\r\n            }\r\n        });\r\n    }\r\n    publishTrack(track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const kind = track.kind;\r\n            if (this.configs.kinds.includes(kind)) {\r\n                track.addEventListener('ended', () => __awaiter(this, void 0, void 0, function* () {\r\n                    yield this.removeTrack(track);\r\n                }));\r\n                const params = { track, stopTracks: !!this.configs.stopTracks };\r\n                if (this.configs.simulcast && kind === 'video' && this.simulcast) {\r\n                    if (this.simulcast.encodings) {\r\n                        params.encodings = this.simulcast.encodings;\r\n                    }\r\n                    if (this.simulcast.codecOptions) {\r\n                        params.codecOptions = this.simulcast.codecOptions;\r\n                    }\r\n                }\r\n                const producer = yield this.transport.produce(params);\r\n                producer.on('close', () => __awaiter(this, void 0, void 0, function* () {\r\n                    const producer = this.connectors.get(kind);\r\n                    if (producer && producer !== true) {\r\n                        this.connectors.delete(kind);\r\n                        try {\r\n                            yield this.api.closeProducer({ producerId: producer.id });\r\n                        }\r\n                        catch (e) { }\r\n                    }\r\n                }));\r\n                this.listenStats(producer, 'outbound-rtp');\r\n                this.connectors.set(kind, producer);\r\n                this.emit('newProducerId', { id: producer.id, kind });\r\n            }\r\n        });\r\n    }\r\n    consume(transport, stream, _kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const rtpCapabilities = this.device.rtpCapabilities;\r\n            try {\r\n                const consumeData = { rtpCapabilities, stream, kind: _kind, transportId: transport.id };\r\n                if (this.configs.origin && this.configs.url !== this.configs.origin.url) {\r\n                    consumeData.origin = ConferenceApi.originOptions(this.configs.url, this.configs.token, this.configs.origin);\r\n                }\r\n                const data = yield this.api.consume(consumeData);\r\n                const layers = this.layers.get(_kind);\r\n                if (layers) {\r\n                    try {\r\n                        yield this.api.setPreferredLayers({ consumerId: data.id, layers });\r\n                    }\r\n                    catch (e) { }\r\n                }\r\n                return transport.consume(data);\r\n            }\r\n            catch (e) {\r\n                if (e) {\r\n                    if (e.errorId === _constants__WEBPACK_IMPORTED_MODULE_0__[\"ERROR\"].INVALID_STREAM) {\r\n                        let timeout;\r\n                        yield new Promise(resolve => {\r\n                            timeout = setTimeout(resolve, this.configs.retryConsumerTimeout);\r\n                            this.timeouts.push(timeout);\r\n                        });\r\n                        if (!this.timeouts.includes(timeout)) {\r\n                            throw e;\r\n                        }\r\n                        return this.consume(transport, stream, _kind);\r\n                    }\r\n                    else if (e.errorId === _constants__WEBPACK_IMPORTED_MODULE_0__[\"ERROR\"].INVALID_TRANSPORT) {\r\n                        this.restartAll().then(() => { }).catch(() => { });\r\n                    }\r\n                }\r\n                throw e;\r\n            }\r\n        });\r\n    }\r\n    listenStats(target, type) {\r\n        let lastBytes = 0;\r\n        let lastBytesTime = Date.now();\r\n        const bytesField = type === 'inbound-rtp' ? 'bytesReceived' : 'bytesSent';\r\n        let deadTime = 0;\r\n        target.on('close', () => {\r\n            this.emit('bitRate', { bitRate: 0, kind: target.kind });\r\n        });\r\n        const getStats = () => {\r\n            if (target && !target.closed) {\r\n                target.getStats().then((stats) => __awaiter(this, void 0, void 0, function* () {\r\n                    if (target && !target.closed) {\r\n                        let alive = false;\r\n                        let i = 0;\r\n                        const checkTarget = () => {\r\n                            if (i === stats['size']) {\r\n                                if (alive) {\r\n                                    deadTime = 0;\r\n                                }\r\n                                else {\r\n                                    this.emit('bitRate', { bitRate: 0, kind: target.kind });\r\n                                    if (type === 'inbound-rtp') {\r\n                                        deadTime++;\r\n                                        if (deadTime > (this.configs.timeout.consumer / this.configs.timeout.stats)) {\r\n                                            try {\r\n                                                this.log('restart by no stats');\r\n                                                if (lastBytes) {\r\n                                                    target.close();\r\n                                                    target.emit('close');\r\n                                                }\r\n                                                else {\r\n                                                    this.restartAll().then(() => { }).catch(() => { });\r\n                                                }\r\n                                            }\r\n                                            catch (e) {\r\n                                            }\r\n                                            return;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                setTimeout(getStats, this.configs.timeout.stats);\r\n                            }\r\n                        };\r\n                        if (stats['size']) {\r\n                            stats.forEach((s) => {\r\n                                if (s && s.type === type) {\r\n                                    if (s[bytesField] && s[bytesField] > lastBytes) {\r\n                                        const bitRate = Math.round((s[bytesField] - lastBytes) / (Date.now() - lastBytesTime) * 1000 * 8);\r\n                                        this.emit('bitRate', { bitRate, kind: target.kind });\r\n                                        lastBytes = s[bytesField];\r\n                                        lastBytesTime = Date.now();\r\n                                        alive = true;\r\n                                    }\r\n                                }\r\n                                i++;\r\n                                checkTarget();\r\n                            });\r\n                        }\r\n                        else {\r\n                            checkTarget();\r\n                        }\r\n                    }\r\n                }));\r\n            }\r\n        };\r\n        getStats();\r\n    }\r\n    close(hard = true) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.transport) {\r\n                if (!this.transport.closed && hard) {\r\n                    this.transport.close();\r\n                }\r\n                const transportId = this.transport.id;\r\n                delete this.transport;\r\n                try {\r\n                    yield this.api.closeTransport({ transportId });\r\n                }\r\n                catch (e) { }\r\n                this.emit('connectionstatechange', { state: 'disconnected' });\r\n            }\r\n            if (hard && this.mediaStream && this.configs.stopTracks) {\r\n                this.mediaStream.getTracks().forEach(function (track) {\r\n                    track.stop();\r\n                });\r\n            }\r\n            yield this.closeConnectors();\r\n            delete this.operation;\r\n            while (this.timeouts.length) {\r\n                const t = this.timeouts.shift();\r\n                if (t) {\r\n                    clearTimeout(t);\r\n                }\r\n            }\r\n            this.api.clear();\r\n        });\r\n    }\r\n    closeConnectors() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.connectors.size) {\r\n                yield new Promise(resolve => {\r\n                    this.connectors.forEach((connector, kind) => {\r\n                        this.connectors.delete(kind);\r\n                        try {\r\n                            if (connector && connector !== true) {\r\n                                connector.close();\r\n                                connector.emit('close');\r\n                            }\r\n                        }\r\n                        catch (e) { }\r\n                        if (!this.connectors.size) {\r\n                            resolve();\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        });\r\n    }\r\n    restartAll() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const operation = this.operation;\r\n            yield this.close(operation === _constants__WEBPACK_IMPORTED_MODULE_0__[\"API_OPERATION\"].SUBSCRIBE);\r\n            if (operation === _constants__WEBPACK_IMPORTED_MODULE_0__[\"API_OPERATION\"].SUBSCRIBE) {\r\n                yield this.subscribe();\r\n            }\r\n            else if (operation === _constants__WEBPACK_IMPORTED_MODULE_0__[\"API_OPERATION\"].PUBLISH && this.mediaStream) {\r\n                yield this.publish(this.mediaStream);\r\n            }\r\n        });\r\n    }\r\n    getTransport() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this.transport) {\r\n                const api = this;\r\n                const data = yield this.api.createTransport();\r\n                if (this.iceServers) {\r\n                    data.iceServers = this.iceServers;\r\n                }\r\n                if (this.operation === _constants__WEBPACK_IMPORTED_MODULE_0__[\"API_OPERATION\"].SUBSCRIBE) {\r\n                    this.transport = this.device.createRecvTransport(data);\r\n                }\r\n                else if (this.operation === _constants__WEBPACK_IMPORTED_MODULE_0__[\"API_OPERATION\"].PUBLISH) {\r\n                    this.transport = this.device.createSendTransport(data);\r\n                }\r\n                this.emit('newTransportId', { id: this.transport.id });\r\n                if (this.configs.maxIncomingBitrate) {\r\n                    yield this.api.setMaxIncomingBitrate({ transportId: this.transport.id, bitrate: this.configs.maxIncomingBitrate });\r\n                }\r\n                this.transport.on('connect', ({ dtlsParameters }, callback, errback) => {\r\n                    api.api.connectTransport({\r\n                        transportId: this.transport.id,\r\n                        dtlsParameters\r\n                    }).then(callback).catch(errback);\r\n                });\r\n                if (this.operation === _constants__WEBPACK_IMPORTED_MODULE_0__[\"API_OPERATION\"].PUBLISH) {\r\n                    this.transport.on('produce', ({ kind, rtpParameters }, callback, errback) => __awaiter(this, void 0, void 0, function* () {\r\n                        try {\r\n                            const data = yield api.api.produce({\r\n                                transportId: this.transport.id,\r\n                                stream: api.configs.stream,\r\n                                kind,\r\n                                rtpParameters\r\n                            });\r\n                            callback(data);\r\n                        }\r\n                        catch (err) {\r\n                            errback(err);\r\n                        }\r\n                    }));\r\n                }\r\n                this.transport.on('connectionstatechange', (state) => __awaiter(this, void 0, void 0, function* () {\r\n                    this.emit('connectionstatechange', { state });\r\n                    switch (state) {\r\n                        case 'connected':\r\n                            if (this.transportTimeout) {\r\n                                clearTimeout(this.transportTimeout);\r\n                            }\r\n                            break;\r\n                        case 'failed':\r\n                        case 'disconnected':\r\n                            if (this.transportTimeout) {\r\n                                clearTimeout(this.transportTimeout);\r\n                            }\r\n                            this.transportTimeout = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\r\n                                yield this.restartAll();\r\n                            }), this.configs.timeout.transport);\r\n                            break;\r\n                    }\r\n                }));\r\n            }\r\n            return this.transport;\r\n        });\r\n    }\r\n    static originOptions(url, token, origin) {\r\n        if (origin.token) {\r\n            token = origin.token;\r\n        }\r\n        const data = {\r\n            token,\r\n            to: url,\r\n            from: origin.url\r\n        };\r\n        if (origin.origin && origin.origin.url !== origin.url) {\r\n            data.origin = ConferenceApi.originOptions(origin.url, token, origin.origin);\r\n        }\r\n        return data;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29uZmVyZW5jZS1hcGkudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9zcmMvY29uZmVyZW5jZS1hcGkudHM/Y2NjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0FQSV9PUEVSQVRJT04sIEVSUk9SfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7RXZlbnRFbWl0dGVyfSBmcm9tIFwiZXZlbnRzXCI7XHJcbmltcG9ydCB7TWVkaWFzb3VwU29ja2V0QXBpfSBmcm9tICcuL21lZGlhc291cC1zb2NrZXQtYXBpJztcclxuaW1wb3J0IHtNZWRpYUtpbmQsIFJ0cENhcGFiaWxpdGllc30gZnJvbSAnbWVkaWFzb3VwLWNsaWVudC9saWIvUnRwUGFyYW1ldGVycyc7XHJcbmltcG9ydCB7RGV2aWNlfSBmcm9tICdtZWRpYXNvdXAtY2xpZW50JztcclxuaW1wb3J0IHtUcmFuc3BvcnQsIFRyYW5zcG9ydE9wdGlvbnN9IGZyb20gJ21lZGlhc291cC1jbGllbnQvbGliL1RyYW5zcG9ydCc7XHJcbmltcG9ydCB7UHJvZHVjZXIsIFByb2R1Y2VyT3B0aW9uc30gZnJvbSAnbWVkaWFzb3VwLWNsaWVudC9saWIvUHJvZHVjZXInO1xyXG5pbXBvcnQge0NvbnN1bWVyfSBmcm9tICdtZWRpYXNvdXAtY2xpZW50L2xpYi9Db25zdW1lcic7XHJcbmltcG9ydCB7ZGVidWd9ICBmcm9tICdkZWJ1Zyc7XHJcbmltcG9ydCB7XHJcbiAgICBDb25mZXJlbmNlQ29uZmlnLFxyXG4gICAgQ29uZmVyZW5jZUlucHV0LCBDb25mZXJlbmNlSW5wdXRPcmlnaW4sXHJcbiAgICBDb25zdW1lUmVxdWVzdCwgQ29uc3VtZVJlcXVlc3RPcmlnaW5EYXRhLFxyXG4gICAgQ29uc3VtZXJMYXllcnMsXHJcbiAgICBJY2VTZXZlcixcclxuICAgIFNpbXVsY2FzdFxyXG59IGZyb20gJy4vY2xpZW50LWludGVyZmFjZXMnO1xyXG5cclxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIENvbmZlcmVuY2VBcGkge1xyXG4gICAgb24oZXZlbnQ6ICdiaXRSYXRlJywgbGlzdGVuZXI6ICh7Yml0UmF0ZTpudW1iZXIsa2luZDpNZWRpYUtpbmR9KSA9PiB2b2lkKTogdGhpc1xyXG4gICAgb24oZXZlbnQ6ICdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBsaXN0ZW5lcjogKHtzdGF0ZTpzdHJpbmd9KSA9PiB2b2lkKTogdGhpc1xyXG4gICAgb24oZXZlbnQ6ICduZXdUcmFuc3BvcnRJZCcsIGxpc3RlbmVyOiAoe2lkOnN0cmluZ30pID0+IHZvaWQpOiB0aGlzXHJcbiAgICBvbihldmVudDogJ25ld1Byb2R1Y2VySWQnLCBsaXN0ZW5lcjogKHtpZDpzdHJpbmcsa2luZDpNZWRpYUtpbmR9KSA9PiB2b2lkKTogdGhpc1xyXG4gICAgb24oZXZlbnQ6ICduZXdDb25zdW1lcklkJywgbGlzdGVuZXI6ICh7aWQ6c3RyaW5nLGtpbmQ6TWVkaWFLaW5kfSkgPT4gdm9pZCk6IHRoaXNcclxuICAgIG9uKGV2ZW50OiAnYWRkdHJhY2snLCBsaXN0ZW5lcjogKGV2ZW50Ok1lZGlhU3RyZWFtVHJhY2tFdmVudCkgPT4gdm9pZCk6IHRoaXNcclxuICAgIG9uKGV2ZW50OiAncmVtb3ZldHJhY2snLCBsaXN0ZW5lcjogKGV2ZW50Ok1lZGlhU3RyZWFtVHJhY2tFdmVudCkgPT4gdm9pZCk6IHRoaXNcclxufVxyXG5leHBvcnQgY2xhc3MgQ29uZmVyZW5jZUFwaSBleHRlbmRzIEV2ZW50RW1pdHRlcntcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXBpOk1lZGlhc291cFNvY2tldEFwaTtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnczpDb25mZXJlbmNlQ29uZmlnO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBkZXZpY2U6RGV2aWNlO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb25uZWN0b3JzOk1hcDxNZWRpYUtpbmQsQ29uc3VtZXJ8UHJvZHVjZXJ8dHJ1ZT4gPSBuZXcgTWFwKCk7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGxheWVyczpNYXA8TWVkaWFLaW5kLENvbnN1bWVyTGF5ZXJzPiA9IG5ldyBNYXAoKTtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgbG9nOnR5cGVvZiBjb25zb2xlLmxvZztcclxuICAgIHByaXZhdGUgb3BlcmF0aW9uOkFQSV9PUEVSQVRJT047XHJcbiAgICBwcml2YXRlIHRyYW5zcG9ydDpUcmFuc3BvcnQ7XHJcbiAgICBwcml2YXRlIG1lZGlhU3RyZWFtPzpNZWRpYVN0cmVhbTtcclxuICAgIHByaXZhdGUgdHJhbnNwb3J0VGltZW91dDpSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PjtcclxuICAgIHByaXZhdGUgaWNlU2VydmVyczpJY2VTZXZlcltdfHVuZGVmaW5lZDtcclxuICAgIHByaXZhdGUgc2ltdWxjYXN0OlNpbXVsY2FzdHx1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRpbWVvdXRzOkFycmF5PFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+PiA9W107XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdzOkNvbmZlcmVuY2VJbnB1dCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNvbmZpZ3M9e1xyXG4gICAgICAgICAgICB1cmw6YGh0dHBzOi8vcnBjLmNvZGVkYS5jb21gLFxyXG4gICAgICAgICAgICBraW5kczpbJ3ZpZGVvJywnYXVkaW8nXSxcclxuICAgICAgICAgICAgbWF4SW5jb21pbmdCaXRyYXRlOjAsXHJcbiAgICAgICAgICAgIHRpbWVvdXQ6e1xyXG4gICAgICAgICAgICAgICAgc3RhdHM6IDEwMDAsXHJcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IDMwMDAsXHJcbiAgICAgICAgICAgICAgICBjb25zdW1lcjogNTAwMFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXRyeUNvbnN1bWVyVGltZW91dDoxMDAwLFxyXG4gICAgICAgICAgICAuLi5jb25maWdzXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmxvZz1kZWJ1ZyhgY29uZmVyZW5jZS1hcGkgWyR7dGhpcy5jb25maWdzLnN0cmVhbX1dOmApO1xyXG4gICAgICAgIHRoaXMuYXBpPW5ldyBNZWRpYXNvdXBTb2NrZXRBcGkodGhpcy5jb25maWdzLnVybCx0aGlzLmNvbmZpZ3MudG9rZW4sdGhpcy5sb2cpO1xyXG4gICAgICAgIHRoaXMuZGV2aWNlID0gbmV3IERldmljZSgpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2V0UHJlZmVycmVkTGF5ZXJzKGxheWVyczpDb25zdW1lckxheWVycyl7XHJcbiAgICAgICAgaWYodGhpcy5vcGVyYXRpb249PT1BUElfT1BFUkFUSU9OLlNVQlNDUklCRSl7XHJcbiAgICAgICAgICAgIGNvbnN0IGtpbmQ6TWVkaWFLaW5kPSd2aWRlbyc7XHJcbiAgICAgICAgICAgIHRoaXMubGF5ZXJzLnNldChraW5kLGxheWVycyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnN1bWVyPXRoaXMuY29ubmVjdG9ycy5nZXQoa2luZCk7XHJcbiAgICAgICAgICAgIGlmKGNvbnN1bWVyICYmIGNvbnN1bWVyIT09dHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpLnNldFByZWZlcnJlZExheWVycyh7Y29uc3VtZXJJZDogY29uc3VtZXIuaWQsIGxheWVyc30pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIGFkZFRyYWNrKHRyYWNrOk1lZGlhU3RyZWFtVHJhY2spe1xyXG4gICAgICAgIHRoaXMubG9nKCdhZGRUcmFjaycsdHJhY2spO1xyXG4gICAgICAgIGlmKHRoaXMub3BlcmF0aW9uPT09QVBJX09QRVJBVElPTi5QVUJMSVNIICYmIHRoaXMubWVkaWFTdHJlYW0pe1xyXG4gICAgICAgICAgICB0aGlzLm1lZGlhU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiYWRkdHJhY2tcIixuZXcgTWVkaWFTdHJlYW1UcmFja0V2ZW50KFwiYWRkdHJhY2tcIix7dHJhY2t9KSk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaFRyYWNrKHRyYWNrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyByZW1vdmVUcmFjayh0cmFjazpNZWRpYVN0cmVhbVRyYWNrKXtcclxuICAgICAgICB0aGlzLmxvZygncmVtb3ZlVHJhY2snLHRyYWNrKTtcclxuICAgICAgICBpZih0aGlzLm9wZXJhdGlvbj09PUFQSV9PUEVSQVRJT04uUFVCTElTSCAmJiB0aGlzLm1lZGlhU3RyZWFtKXtcclxuICAgICAgICAgICAgdGhpcy5tZWRpYVN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInJlbW92ZXRyYWNrXCIsbmV3IE1lZGlhU3RyZWFtVHJhY2tFdmVudChcInJlbW92ZXRyYWNrXCIse3RyYWNrfSkpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9kdWNlcj10aGlzLmNvbm5lY3RvcnMuZ2V0KHRyYWNrLmtpbmQgYXMgTWVkaWFLaW5kKTtcclxuICAgICAgICAgICAgaWYocHJvZHVjZXIgJiYgcHJvZHVjZXIhPT10cnVlKXtcclxuICAgICAgICAgICAgICAgIHByb2R1Y2VyLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBwcm9kdWNlci5lbWl0KCdjbG9zZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgc2V0TWF4UHVibGlzaGVyQml0cmF0ZShiaXRyYXRlOm51bWJlcil7XHJcbiAgICAgICAgdGhpcy5jb25maWdzLm1heEluY29taW5nQml0cmF0ZT1iaXRyYXRlO1xyXG4gICAgICAgIGlmKHRoaXMudHJhbnNwb3J0KXtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGkuc2V0TWF4SW5jb21pbmdCaXRyYXRlKHt0cmFuc3BvcnRJZDp0aGlzLnRyYW5zcG9ydC5pZCxiaXRyYXRlfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyB1cGRhdGVLaW5kcyhraW5kczpNZWRpYUtpbmRbXSl7XHJcbiAgICAgICAgaWYodGhpcy5vcGVyYXRpb249PT1BUElfT1BFUkFUSU9OLlNVQlNDUklCRSl7XHJcbiAgICAgICAgICAgIHRoaXMubG9nKCd1cGRhdGVLaW5kcycsIGtpbmRzKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG9sZEtpbmRzPXRoaXMuY29uZmlncy5raW5kcztcclxuICAgICAgICAgICAgdGhpcy5jb25maWdzLmtpbmRzPWtpbmRzO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtpbmQgb2Ygb2xkS2luZHMpe1xyXG4gICAgICAgICAgICAgICAgaWYoIWtpbmRzLmluY2x1ZGVzKGtpbmQpKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0b3I9dGhpcy5jb25uZWN0b3JzLmdldChraW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjb25uZWN0b3Ipe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjb25uZWN0b3IhPT10cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yLmVtaXQoJ2Nsb3NlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnMuZGVsZXRlKGtpbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzOlByb21pc2U8dm9pZD5bXT1bXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBraW5kIG9mIGtpbmRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29ubmVjdG9ycy5nZXQoa2luZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc3Vic2NyaWJlVHJhY2soa2luZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcml2YXRlIGFzeW5jIGluaXQob3BlcmF0aW9uOkFQSV9PUEVSQVRJT04pOlByb21pc2U8dm9pZD57XHJcbiAgICAgICAgaWYodGhpcy5vcGVyYXRpb24pe1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHByb2Nlc3NpbmdcIilcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb249b3BlcmF0aW9uO1xyXG4gICAgICAgIGlmKCF0aGlzLmRldmljZS5sb2FkZWQpe1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwaS5pbml0U29ja2V0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHtyb3V0ZXJSdHBDYXBhYmlsaXRpZXMsaWNlU2VydmVycyxzaW11bGNhc3QsdGltZW91dH0gPSBhd2FpdCB0aGlzLmFwaS5nZXRTZXJ2ZXJDb25maWdzKCk7XHJcbiAgICAgICAgICAgIGlmIChyb3V0ZXJSdHBDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcm91dGVyUnRwQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnMgPSByb3V0ZXJSdHBDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucy5cclxuICAgICAgICAgICAgICAgIGZpbHRlcigoZXh0KSA9PiBleHQudXJpICE9PSAndXJuOjNncHA6dmlkZW8tb3JpZW50YXRpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRldmljZS5sb2FkKHsgcm91dGVyUnRwQ2FwYWJpbGl0aWVzIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmljZVNlcnZlcnM9aWNlU2VydmVycztcclxuICAgICAgICAgICAgdGhpcy5zaW11bGNhc3Q9c2ltdWxjYXN0O1xyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3MudGltZW91dD17Li4udGhpcy5jb25maWdzLnRpbWVvdXQsLi4udGltZW91dH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgdGhpcy5nZXRUcmFuc3BvcnQoKTtcclxuXHJcbiAgICB9XHJcbiAgICBhc3luYyBwdWJsaXNoKG1lZGlhU3RyZWFtOk1lZGlhU3RyZWFtKTpQcm9taXNlPE1lZGlhU3RyZWFtPntcclxuICAgICAgICBhd2FpdCB0aGlzLmluaXQoQVBJX09QRVJBVElPTi5QVUJMSVNIKTtcclxuICAgICAgICB0aGlzLm1lZGlhU3RyZWFtPW1lZGlhU3RyZWFtO1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG1lZGlhU3RyZWFtLmdldFRyYWNrcygpLm1hcCh0cmFjaz0+dGhpcy5wdWJsaXNoVHJhY2sodHJhY2spKSk7XHJcbiAgICAgICAgcmV0dXJuIG1lZGlhU3RyZWFtO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc3Vic2NyaWJlKCk6UHJvbWlzZTxNZWRpYVN0cmVhbT57XHJcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0KEFQSV9PUEVSQVRJT04uU1VCU0NSSUJFKTtcclxuICAgICAgICBjb25zdCBtZWRpYVN0cmVhbSA9IHRoaXMubWVkaWFTdHJlYW0gfHwgbmV3IE1lZGlhU3RyZWFtKCk7XHJcbiAgICAgICAgdGhpcy5tZWRpYVN0cmVhbT1tZWRpYVN0cmVhbTtcclxuICAgICAgICB0aGlzLmNvbmZpZ3Mua2luZHMubWFwKGFzeW5jIGtpbmQ9PntcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdWJzY3JpYmVUcmFjayhraW5kKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbWVkaWFTdHJlYW07XHJcbiAgICB9XHJcbiAgICBwcml2YXRlIGFzeW5jIHN1YnNjcmliZVRyYWNrKGtpbmQ6TWVkaWFLaW5kKTpQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBhcGk6Q29uZmVyZW5jZUFwaT10aGlzO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdG9ycy5zZXQoa2luZCBhcyBNZWRpYUtpbmQsdHJ1ZSk7XHJcbiAgICAgICAgY29uc3Qgb25DbG9zZT1hc3luYyAoKT0+e1xyXG4gICAgICAgICAgICBpZih0aGlzLm1lZGlhU3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdW1lci50cmFjay5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKGNvbnN1bWVyLnRyYWNrKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInJlbW92ZXRyYWNrXCIsbmV3IE1lZGlhU3RyZWFtVHJhY2tFdmVudChcInJlbW92ZXRyYWNrXCIse3RyYWNrOmNvbnN1bWVyLnRyYWNrfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHRoaXMudHJhbnNwb3J0ICYmICF0aGlzLnRyYW5zcG9ydC5jbG9zZWQpe1xyXG4gICAgICAgICAgICAgICAgY29uc3QgX2NvbnN1bWVyPXRoaXMuY29ubmVjdG9ycy5nZXQoa2luZCk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpLmNsb3NlQ29uc3VtZXIoe2NvbnN1bWVySWQ6IGNvbnN1bWVyLmlkfSk7XHJcbiAgICAgICAgICAgICAgICB9Y2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgICAgICAgICBpZihfY29uc3VtZXIgJiYgX2NvbnN1bWVyIT09dHJ1ZSAmJiBjb25zdW1lci5pZD09PV9jb25zdW1lci5pZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzLmRlbGV0ZShjb25zdW1lci50cmFjay5raW5kIGFzIE1lZGlhS2luZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5tZWRpYVN0cmVhbSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMudHJhbnNwb3J0ICYmIHRoaXMuY29uZmlncy5raW5kcy5pbmNsdWRlcyhraW5kKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zdWJzY3JpYmVUcmFjayhraW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgY29uc3VtZXI6Q29uc3VtZXIgPSBhd2FpdCB0aGlzLmNvbnN1bWUodGhpcy50cmFuc3BvcnQsdGhpcy5jb25maWdzLnN0cmVhbSxraW5kKTtcclxuICAgICAgICBjb25zdW1lci5vbignY2xvc2UnLCBvbkNsb3NlKTtcclxuICAgICAgICBpZih0aGlzLmNvbm5lY3RvcnMuZ2V0KGtpbmQgYXMgTWVkaWFLaW5kKT09PXRydWUpe1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnMuc2V0KGtpbmQgYXMgTWVkaWFLaW5kLGNvbnN1bWVyKTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCduZXdDb25zdW1lcklkJyx7aWQ6Y29uc3VtZXIuaWQsa2luZH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5TdGF0cyhjb25zdW1lciwnaW5ib3VuZC1ydHAnKTtcclxuICAgICAgICAgICAgYXdhaXQgYXBpLmFwaS5yZXN1bWVDb25zdW1lcih7Y29uc3VtZXJJZDogY29uc3VtZXIuaWR9KTtcclxuICAgICAgICAgICAgaWYodGhpcy5tZWRpYVN0cmVhbSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhU3RyZWFtLmFkZFRyYWNrKGNvbnN1bWVyLnRyYWNrKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImFkZHRyYWNrXCIsbmV3IE1lZGlhU3RyZWFtVHJhY2tFdmVudChcImFkZHRyYWNrXCIse3RyYWNrOmNvbnN1bWVyLnRyYWNrfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdW1lci5jbG9zZSgpO1xyXG4gICAgICAgICAgICBjb25zdW1lci5lbWl0KCdjbG9zZScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbiAgICBwcml2YXRlIGFzeW5jIHB1Ymxpc2hUcmFjayh0cmFjazpNZWRpYVN0cmVhbVRyYWNrKTpQcm9taXNlPHZvaWQ+e1xyXG4gICAgICAgIGNvbnN0IGtpbmQ6TWVkaWFLaW5kPXRyYWNrLmtpbmQgYXMgTWVkaWFLaW5kO1xyXG4gICAgICAgIGlmKHRoaXMuY29uZmlncy5raW5kcy5pbmNsdWRlcyhraW5kKSl7XHJcbiAgICAgICAgICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgYXN5bmMgKCk9PntcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVtb3ZlVHJhY2sodHJhY2spO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtczpQcm9kdWNlck9wdGlvbnMgPSB7IHRyYWNrLCBzdG9wVHJhY2tzOiEhdGhpcy5jb25maWdzLnN0b3BUcmFja3MgfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlncy5zaW11bGNhc3QgJiYga2luZD09PSd2aWRlbycgJiYgdGhpcy5zaW11bGNhc3QpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuc2ltdWxjYXN0LmVuY29kaW5ncyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IHRoaXMuc2ltdWxjYXN0LmVuY29kaW5ncztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuc2ltdWxjYXN0LmNvZGVjT3B0aW9ucyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNvZGVjT3B0aW9ucz10aGlzLnNpbXVsY2FzdC5jb2RlY09wdGlvbnNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwcm9kdWNlcj1hd2FpdCB0aGlzLnRyYW5zcG9ydC5wcm9kdWNlKHBhcmFtcyk7XHJcbiAgICAgICAgICAgIHByb2R1Y2VyLm9uKCdjbG9zZScsIGFzeW5jICgpPT57XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9kdWNlcj10aGlzLmNvbm5lY3RvcnMuZ2V0KGtpbmQpO1xyXG4gICAgICAgICAgICAgICAgaWYocHJvZHVjZXIgJiYgcHJvZHVjZXIhPT10cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnMuZGVsZXRlKGtpbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpLmNsb3NlUHJvZHVjZXIoe3Byb2R1Y2VySWQ6cHJvZHVjZXIuaWR9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5TdGF0cyhwcm9kdWNlciwnb3V0Ym91bmQtcnRwJyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9ycy5zZXQoa2luZCxwcm9kdWNlcik7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnbmV3UHJvZHVjZXJJZCcse2lkOnByb2R1Y2VyLmlkLGtpbmR9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcml2YXRlIGFzeW5jIGNvbnN1bWUodHJhbnNwb3J0OlRyYW5zcG9ydCxzdHJlYW06c3RyaW5nLF9raW5kOk1lZGlhS2luZCk6UHJvbWlzZTxDb25zdW1lcj57XHJcbiAgICAgICAgY29uc3QgIHJ0cENhcGFiaWxpdGllczpSdHBDYXBhYmlsaXRpZXMgID0gdGhpcy5kZXZpY2UucnRwQ2FwYWJpbGl0aWVzIGFzIFJ0cENhcGFiaWxpdGllcztcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnN1bWVEYXRhOkNvbnN1bWVSZXF1ZXN0PXsgcnRwQ2FwYWJpbGl0aWVzLHN0cmVhbSxraW5kOl9raW5kLHRyYW5zcG9ydElkOnRyYW5zcG9ydC5pZH07XHJcbiAgICAgICAgICAgIGlmKHRoaXMuY29uZmlncy5vcmlnaW4gJiYgdGhpcy5jb25maWdzLnVybCE9PXRoaXMuY29uZmlncy5vcmlnaW4udXJsKXtcclxuICAgICAgICAgICAgICAgIGNvbnN1bWVEYXRhLm9yaWdpbj1Db25mZXJlbmNlQXBpLm9yaWdpbk9wdGlvbnModGhpcy5jb25maWdzLnVybCx0aGlzLmNvbmZpZ3MudG9rZW4sdGhpcy5jb25maWdzLm9yaWdpbilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBkYXRhPWF3YWl0IHRoaXMuYXBpLmNvbnN1bWUoY29uc3VtZURhdGEpO1xyXG4gICAgICAgICAgICBjb25zdCBsYXllcnM9dGhpcy5sYXllcnMuZ2V0KF9raW5kKTtcclxuICAgICAgICAgICAgaWYobGF5ZXJzKXtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGkuc2V0UHJlZmVycmVkTGF5ZXJzKHtjb25zdW1lcklkOmRhdGEuaWQsbGF5ZXJzfSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cmFuc3BvcnQuY29uc3VtZShkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYoZSl7XHJcbiAgICAgICAgICAgICAgICBpZihlLmVycm9ySWQ9PT1FUlJPUi5JTlZBTElEX1NUUkVBTSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpbWVvdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZT0+e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0PXNldFRpbWVvdXQocmVzb2x2ZSx0aGlzLmNvbmZpZ3MucmV0cnlDb25zdW1lclRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRzLnB1c2godGltZW91dClcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZighdGhpcy50aW1lb3V0cy5pbmNsdWRlcyh0aW1lb3V0KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWUodHJhbnNwb3J0LHN0cmVhbSxfa2luZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGUuZXJyb3JJZD09PUVSUk9SLklOVkFMSURfVFJBTlNQT1JUKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnRBbGwoKS50aGVuKCgpPT57fSkuY2F0Y2goKCk9Pnt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuICAgIHByaXZhdGUgbGlzdGVuU3RhdHModGFyZ2V0OkNvbnN1bWVyfFByb2R1Y2VyLHR5cGU6XCJpbmJvdW5kLXJ0cFwifFwib3V0Ym91bmQtcnRwXCIpe1xyXG4gICAgICAgIGxldCBsYXN0Qnl0ZXM9MDtcclxuICAgICAgICBsZXQgbGFzdEJ5dGVzVGltZT1EYXRlLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVzRmllbGQ9dHlwZT09PSdpbmJvdW5kLXJ0cCc/J2J5dGVzUmVjZWl2ZWQnOidieXRlc1NlbnQnO1xyXG4gICAgICAgIGxldCBkZWFkVGltZT0wO1xyXG4gICAgICAgIHRhcmdldC5vbignY2xvc2UnLCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnYml0UmF0ZScsIHtiaXRSYXRlOiAwLCBraW5kOiB0YXJnZXQua2luZH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGdldFN0YXRzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ICYmICF0YXJnZXQuY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuZ2V0U3RhdHMoKS50aGVuKGFzeW5jIHN0YXRzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICYmICF0YXJnZXQuY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhbGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaT0wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGVja1RhcmdldD0oKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaT09PXN0YXRzWydzaXplJ10pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWFkVGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2JpdFJhdGUnLCB7Yml0UmF0ZTogMCwga2luZDogdGFyZ2V0LmtpbmR9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdpbmJvdW5kLXJ0cCcpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWFkVGltZSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlYWRUaW1lID4gKHRoaXMuY29uZmlncy50aW1lb3V0LmNvbnN1bWVyL3RoaXMuY29uZmlncy50aW1lb3V0LnN0YXRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKCdyZXN0YXJ0IGJ5IG5vIHN0YXRzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxhc3RCeXRlcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5lbWl0KCdjbG9zZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0QWxsKCkudGhlbigoKT0+e30pLmNhdGNoKCgpPT57fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChnZXRTdGF0cywgdGhpcy5jb25maWdzLnRpbWVvdXQuc3RhdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzdGF0c1snc2l6ZSddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5mb3JFYWNoKChzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgJiYgcy50eXBlID09PSB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzW2J5dGVzRmllbGRdICYmIHNbYnl0ZXNGaWVsZF0gPiBsYXN0Qnl0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdFJhdGU9TWF0aC5yb3VuZCgoc1tieXRlc0ZpZWxkXS1sYXN0Qnl0ZXMpLyhEYXRlLm5vdygpLWxhc3RCeXRlc1RpbWUpKjEwMDAqOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2JpdFJhdGUnLHtiaXRSYXRlLGtpbmQ6dGFyZ2V0LmtpbmR9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCeXRlcyA9IHNbYnl0ZXNGaWVsZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Qnl0ZXNUaW1lPURhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVGFyZ2V0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVGFyZ2V0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBnZXRTdGF0cygpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgY2xvc2UoaGFyZD10cnVlKXtcclxuICAgICAgICBpZih0aGlzLnRyYW5zcG9ydCl7XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLnRyYW5zcG9ydC5jbG9zZWQgJiYgaGFyZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zcG9ydElkPXRoaXMudHJhbnNwb3J0LmlkO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy50cmFuc3BvcnQ7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwaS5jbG9zZVRyYW5zcG9ydCh7dHJhbnNwb3J0SWR9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge31cclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLHtzdGF0ZTonZGlzY29ubmVjdGVkJ30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihoYXJkICYmIHRoaXMubWVkaWFTdHJlYW0gJiYgdGhpcy5jb25maWdzLnN0b3BUcmFja3Mpe1xyXG4gICAgICAgICAgICB0aGlzLm1lZGlhU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IHRoaXMuY2xvc2VDb25uZWN0b3JzKCk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMub3BlcmF0aW9uO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLnRpbWVvdXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCB0PXRoaXMudGltZW91dHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgaWYodCl7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hcGkuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIHByaXZhdGUgYXN5bmMgY2xvc2VDb25uZWN0b3JzKCk6UHJvbWlzZTx2b2lkPntcclxuICAgICAgICBpZih0aGlzLmNvbm5lY3RvcnMuc2l6ZSl7XHJcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmU9PntcclxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9ycy5mb3JFYWNoKChjb25uZWN0b3Isa2luZCk9PntcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnMuZGVsZXRlKGtpbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvbm5lY3RvciAmJiBjb25uZWN0b3IhPT10cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yLmVtaXQoJ2Nsb3NlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMuY29ubmVjdG9ycy5zaXplKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSBhc3luYyByZXN0YXJ0QWxsKCk6UHJvbWlzZTx2b2lkPntcclxuICAgICAgICBjb25zdCBvcGVyYXRpb249dGhpcy5vcGVyYXRpb247XHJcbiAgICAgICAgYXdhaXQgdGhpcy5jbG9zZShvcGVyYXRpb249PT1BUElfT1BFUkFUSU9OLlNVQlNDUklCRSk7XHJcbiAgICAgICAgaWYob3BlcmF0aW9uPT09QVBJX09QRVJBVElPTi5TVUJTQ1JJQkUpe1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN1YnNjcmliZSgpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYob3BlcmF0aW9uPT09QVBJX09QRVJBVElPTi5QVUJMSVNIICYmIHRoaXMubWVkaWFTdHJlYW0pe1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2godGhpcy5tZWRpYVN0cmVhbSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcml2YXRlIGFzeW5jIGdldFRyYW5zcG9ydCgpOlByb21pc2U8VHJhbnNwb3J0PntcclxuICAgICAgICBpZighdGhpcy50cmFuc3BvcnQpe1xyXG4gICAgICAgICAgICBjb25zdCBhcGk6Q29uZmVyZW5jZUFwaT10aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhOlRyYW5zcG9ydE9wdGlvbnMgPSBhd2FpdCB0aGlzLmFwaS5jcmVhdGVUcmFuc3BvcnQoKTtcclxuICAgICAgICAgICAgaWYodGhpcy5pY2VTZXJ2ZXJzKXtcclxuICAgICAgICAgICAgICAgIGRhdGEuaWNlU2VydmVycz10aGlzLmljZVNlcnZlcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodGhpcy5vcGVyYXRpb249PT1BUElfT1BFUkFUSU9OLlNVQlNDUklCRSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRoaXMuZGV2aWNlLmNyZWF0ZVJlY3ZUcmFuc3BvcnQoZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSAgaWYodGhpcy5vcGVyYXRpb249PT1BUElfT1BFUkFUSU9OLlBVQkxJU0gpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0aGlzLmRldmljZS5jcmVhdGVTZW5kVHJhbnNwb3J0KGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnbmV3VHJhbnNwb3J0SWQnLHtpZDp0aGlzLnRyYW5zcG9ydC5pZH0pO1xyXG4gICAgICAgICAgICBpZih0aGlzLmNvbmZpZ3MubWF4SW5jb21pbmdCaXRyYXRlKXtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpLnNldE1heEluY29taW5nQml0cmF0ZSh7dHJhbnNwb3J0SWQ6dGhpcy50cmFuc3BvcnQuaWQsYml0cmF0ZTp0aGlzLmNvbmZpZ3MubWF4SW5jb21pbmdCaXRyYXRlfSlcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQub24oJ2Nvbm5lY3QnLCAoeyBkdGxzUGFyYW1ldGVycyB9LCBjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXBpLmFwaS5jb25uZWN0VHJhbnNwb3J0KHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnRJZDogdGhpcy50cmFuc3BvcnQuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnNcclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oY2FsbGJhY2spLmNhdGNoKGVycmJhY2spO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYodGhpcy5vcGVyYXRpb249PT1BUElfT1BFUkFUSU9OLlBVQkxJU0gpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQub24oJ3Byb2R1Y2UnLCBhc3luYyAoeyBraW5kLCBydHBQYXJhbWV0ZXJzIH0sIGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YT1hd2FpdCBhcGkuYXBpLnByb2R1Y2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0SWQ6IHRoaXMudHJhbnNwb3J0LmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtOmFwaS5jb25maWdzLnN0cmVhbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydHBQYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBhc3luYyAoc3RhdGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbnN0YXRlY2hhbmdlJyx7c3RhdGV9KTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnRyYW5zcG9ydFRpbWVvdXQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHJhbnNwb3J0VGltZW91dClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMudHJhbnNwb3J0VGltZW91dCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50cmFuc3BvcnRUaW1lb3V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0VGltZW91dD1zZXRUaW1lb3V0KGFzeW5jICgpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlc3RhcnRBbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSx0aGlzLmNvbmZpZ3MudGltZW91dC50cmFuc3BvcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQ7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlIHN0YXRpYyBvcmlnaW5PcHRpb25zKHVybCx0b2tlbixvcmlnaW46Q29uZmVyZW5jZUlucHV0T3JpZ2luKTpDb25zdW1lUmVxdWVzdE9yaWdpbkRhdGF7XHJcbiAgICAgICAgaWYob3JpZ2luLnRva2VuKXtcclxuICAgICAgICAgICAgdG9rZW49b3JpZ2luLnRva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhOkNvbnN1bWVSZXF1ZXN0T3JpZ2luRGF0YT17XHJcbiAgICAgICAgICAgIHRva2VuLFxyXG4gICAgICAgICAgICB0bzogdXJsLFxyXG4gICAgICAgICAgICBmcm9tOm9yaWdpbi51cmxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmKG9yaWdpbi5vcmlnaW4gJiYgb3JpZ2luLm9yaWdpbi51cmwhPT1vcmlnaW4udXJsKXtcclxuICAgICAgICAgICAgZGF0YS5vcmlnaW49Q29uZmVyZW5jZUFwaS5vcmlnaW5PcHRpb25zKG9yaWdpbi51cmwsdG9rZW4sb3JpZ2luLm9yaWdpbilcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbn0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBbUJBO0FBY0E7QUFDQTtBQVhBO0FBQ0E7QUFRQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/conference-api.ts\n");

/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/*! exports provided: ACTION, ERROR, API_OPERATION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ACTION\", function() { return ACTION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ERROR\", function() { return ERROR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"API_OPERATION\", function() { return API_OPERATION; });\nvar ACTION;\r\n(function (ACTION) {\r\n    ACTION[\"GET_SERVER_CONFIGS\"] = \"getServerConfigs\";\r\n    ACTION[\"CREATE_TRANSPORT\"] = \"createTransport\";\r\n    ACTION[\"CONNECT_TRANSPORT\"] = \"connectTransport\";\r\n    ACTION[\"CLOSE_TRANSPORT\"] = \"closeTransport\";\r\n    ACTION[\"PRODUCE\"] = \"produce\";\r\n    ACTION[\"CONSUME\"] = \"consume\";\r\n    ACTION[\"RESUME_CONSUMER\"] = \"resumeConsumer\";\r\n    ACTION[\"PAUSE_CONSUMER\"] = \"pauseConsumer\";\r\n    ACTION[\"CLOSE_CONSUMER\"] = \"closeConsumer\";\r\n    ACTION[\"RESUME_PRODUCER\"] = \"resumeProducer\";\r\n    ACTION[\"PAUSE_PRODUCER\"] = \"pauseProducer\";\r\n    ACTION[\"CLOSE_PRODUCER\"] = \"closeProducer\";\r\n    ACTION[\"FILE_STREAMING\"] = \"fileStreaming\";\r\n    ACTION[\"RTMP_STREAMING\"] = \"rtmpStreaming\";\r\n    ACTION[\"STOP_FILE_STREAMING\"] = \"stopFileStreaming\";\r\n    ACTION[\"START_RECORDING\"] = \"startRecording\";\r\n    ACTION[\"STOP_RECORDING\"] = \"stopRecording\";\r\n    ACTION[\"CREATE_PIPE_TRANSPORT\"] = \"createPipeTransport\";\r\n    ACTION[\"CONNECT_PIPE_TRANSPORT\"] = \"connectPipeTransport\";\r\n    ACTION[\"SET_PREFERRED_LAYERS\"] = \"setPreferredLayers\";\r\n    ACTION[\"SET_MAX_INCOMING_BITRATE\"] = \"setMaxIncomingBitrate\";\r\n    ACTION[\"PRODUCERS_STATS\"] = \"producersStats\";\r\n    ACTION[\"CONSUMERS_STATS\"] = \"consumersStats\";\r\n    ACTION[\"TRANSPORT_STATS\"] = \"transportStats\";\r\n    ACTION[\"PIPE_TO_REMOTE_PRODUCER\"] = \"pipeToRemoteProducer\";\r\n    ACTION[\"PIPE_FROM_REMOTE_PRODUCER\"] = \"pipeFromRemoteProducer\";\r\n    ACTION[\"WORKER_LOAD\"] = \"workerLoad\";\r\n    ACTION[\"NUM_WORKERS\"] = \"numWorkers\";\r\n    ACTION[\"RECORDED_STREAMS\"] = \"recordedStreams\";\r\n    ACTION[\"STREAM_RECORDINGS\"] = \"streamRecordings\";\r\n    ACTION[\"DELETE_STREAM_RECORDINGS\"] = \"deleteStreamRecordings\";\r\n    ACTION[\"DELETE_RECORDING\"] = \"deleteRecording\";\r\n    ACTION[\"PUSH_TO_SERVER_INPUTS\"] = \"pushToServerInputs\";\r\n    ACTION[\"PULL_FROM_SERVER_INPUTS\"] = \"pullFromServerInputs\";\r\n    ACTION[\"PUSH_TO_SERVER_OPTIONS\"] = \"pushToServerOptions\";\r\n    ACTION[\"PUSH_TO_SERVER\"] = \"pushToServer\";\r\n    ACTION[\"KINDS_BY_FILE\"] = \"kindsByFile\";\r\n    ACTION[\"REQUEST_KEYFRAME\"] = \"requestKeyframe\";\r\n})(ACTION || (ACTION = {}));\r\nvar ERROR;\r\n(function (ERROR) {\r\n    ERROR[ERROR[\"UNKNOWN\"] = 500] = \"UNKNOWN\";\r\n    ERROR[ERROR[\"UNAUTHORIZED\"] = 401] = \"UNAUTHORIZED\";\r\n    ERROR[ERROR[\"INVALID_TRANSPORT\"] = 530] = \"INVALID_TRANSPORT\";\r\n    ERROR[ERROR[\"INVALID_PRODUCER\"] = 531] = \"INVALID_PRODUCER\";\r\n    ERROR[ERROR[\"INVALID_CONSUMER\"] = 532] = \"INVALID_CONSUMER\";\r\n    ERROR[ERROR[\"INVALID_STREAM\"] = 533] = \"INVALID_STREAM\";\r\n    ERROR[ERROR[\"INVALID_OPERATION\"] = 534] = \"INVALID_OPERATION\";\r\n    ERROR[ERROR[\"INVALID_WORKER\"] = 535] = \"INVALID_WORKER\";\r\n    ERROR[ERROR[\"INVALID_INPUT\"] = 536] = \"INVALID_INPUT\";\r\n})(ERROR || (ERROR = {}));\r\nvar API_OPERATION;\r\n(function (API_OPERATION) {\r\n    API_OPERATION[API_OPERATION[\"SUBSCRIBE\"] = 0] = \"SUBSCRIBE\";\r\n    API_OPERATION[API_OPERATION[\"PUBLISH\"] = 1] = \"PUBLISH\";\r\n    API_OPERATION[API_OPERATION[\"RECORDING\"] = 2] = \"RECORDING\";\r\n    API_OPERATION[API_OPERATION[\"STREAMING\"] = 3] = \"STREAMING\";\r\n})(API_OPERATION || (API_OPERATION = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29uc3RhbnRzLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnhfc29ja2V0aW9fY2xpZW50Ly4vc3JjL2NvbnN0YW50cy50cz84NWVlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBlbnVtIEFDVElPTiB7XG4gICAgR0VUX1NFUlZFUl9DT05GSUdTPSdnZXRTZXJ2ZXJDb25maWdzJyxcbiAgICBDUkVBVEVfVFJBTlNQT1JUPSdjcmVhdGVUcmFuc3BvcnQnLCBDT05ORUNUX1RSQU5TUE9SVD0nY29ubmVjdFRyYW5zcG9ydCcsIENMT1NFX1RSQU5TUE9SVD0nY2xvc2VUcmFuc3BvcnQnLFxuICAgIFBST0RVQ0U9J3Byb2R1Y2UnLCBDT05TVU1FPSdjb25zdW1lJyxcbiAgICBSRVNVTUVfQ09OU1VNRVI9J3Jlc3VtZUNvbnN1bWVyJyxQQVVTRV9DT05TVU1FUj0ncGF1c2VDb25zdW1lcicsQ0xPU0VfQ09OU1VNRVI9J2Nsb3NlQ29uc3VtZXInLFxuICAgIFJFU1VNRV9QUk9EVUNFUj0ncmVzdW1lUHJvZHVjZXInLFBBVVNFX1BST0RVQ0VSPSdwYXVzZVByb2R1Y2VyJyxDTE9TRV9QUk9EVUNFUj0nY2xvc2VQcm9kdWNlcicsXG4gICAgRklMRV9TVFJFQU1JTkc9J2ZpbGVTdHJlYW1pbmcnLCBSVE1QX1NUUkVBTUlORz0ncnRtcFN0cmVhbWluZycsIFNUT1BfRklMRV9TVFJFQU1JTkc9J3N0b3BGaWxlU3RyZWFtaW5nJyxcbiAgICBTVEFSVF9SRUNPUkRJTkc9XCJzdGFydFJlY29yZGluZ1wiLCBTVE9QX1JFQ09SRElORz1cInN0b3BSZWNvcmRpbmdcIixcbiAgICBDUkVBVEVfUElQRV9UUkFOU1BPUlQ9J2NyZWF0ZVBpcGVUcmFuc3BvcnQnLCBDT05ORUNUX1BJUEVfVFJBTlNQT1JUPSdjb25uZWN0UGlwZVRyYW5zcG9ydCcsXG4gICAgU0VUX1BSRUZFUlJFRF9MQVlFUlM9XCJzZXRQcmVmZXJyZWRMYXllcnNcIixTRVRfTUFYX0lOQ09NSU5HX0JJVFJBVEU9J3NldE1heEluY29taW5nQml0cmF0ZScsXG4gICAgUFJPRFVDRVJTX1NUQVRTPSdwcm9kdWNlcnNTdGF0cycsIENPTlNVTUVSU19TVEFUUz0nY29uc3VtZXJzU3RhdHMnLCBUUkFOU1BPUlRfU1RBVFM9J3RyYW5zcG9ydFN0YXRzJyxcbiAgICBQSVBFX1RPX1JFTU9URV9QUk9EVUNFUj0ncGlwZVRvUmVtb3RlUHJvZHVjZXInLCBQSVBFX0ZST01fUkVNT1RFX1BST0RVQ0VSPSdwaXBlRnJvbVJlbW90ZVByb2R1Y2VyJyxcbiAgICBXT1JLRVJfTE9BRD0nd29ya2VyTG9hZCcsIE5VTV9XT1JLRVJTPSdudW1Xb3JrZXJzJyxcbiAgICBSRUNPUkRFRF9TVFJFQU1TPSdyZWNvcmRlZFN0cmVhbXMnLCBTVFJFQU1fUkVDT1JESU5HUz0nc3RyZWFtUmVjb3JkaW5ncycsXG4gICAgREVMRVRFX1NUUkVBTV9SRUNPUkRJTkdTPSdkZWxldGVTdHJlYW1SZWNvcmRpbmdzJywgREVMRVRFX1JFQ09SRElORz0nZGVsZXRlUmVjb3JkaW5nJyxcbiAgICBQVVNIX1RPX1NFUlZFUl9JTlBVVFM9J3B1c2hUb1NlcnZlcklucHV0cycsIFBVTExfRlJPTV9TRVJWRVJfSU5QVVRTPSdwdWxsRnJvbVNlcnZlcklucHV0cycsXG4gICAgUFVTSF9UT19TRVJWRVJfT1BUSU9OUz0ncHVzaFRvU2VydmVyT3B0aW9ucycsIFBVU0hfVE9fU0VSVkVSPSdwdXNoVG9TZXJ2ZXInLFxuICAgIEtJTkRTX0JZX0ZJTEU9J2tpbmRzQnlGaWxlJyxSRVFVRVNUX0tFWUZSQU1FPSdyZXF1ZXN0S2V5ZnJhbWUnXG59XG5leHBvcnQgZW51bSBFUlJPUiB7VU5LTk9XTj01MDAsVU5BVVRIT1JJWkVEPTQwMSxJTlZBTElEX1RSQU5TUE9SVD01MzAsSU5WQUxJRF9QUk9EVUNFUj01MzEsSU5WQUxJRF9DT05TVU1FUj01MzIsSU5WQUxJRF9TVFJFQU09NTMzLElOVkFMSURfT1BFUkFUSU9OPTUzNCxJTlZBTElEX1dPUktFUj01MzUsSU5WQUxJRF9JTlBVVD01MzZ9XG5leHBvcnQgZW51bSBBUElfT1BFUkFUSU9OIHtTVUJTQ1JJQkUsUFVCTElTSCxSRUNPUkRJTkcsU1RSRUFNSU5HfSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/constants.ts\n");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! exports provided: ERROR, ACTION, API_OPERATION, MediasoupSocketApi, Utils, ConferenceApi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ERROR\", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__[\"ERROR\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ACTION\", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"API_OPERATION\", function() { return _constants__WEBPACK_IMPORTED_MODULE_0__[\"API_OPERATION\"]; });\n\n/* harmony import */ var _mediasoup_socket_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mediasoup-socket-api */ \"./src/mediasoup-socket-api.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MediasoupSocketApi\", function() { return _mediasoup_socket_api__WEBPACK_IMPORTED_MODULE_1__[\"MediasoupSocketApi\"]; });\n\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Utils\", function() { return _utils__WEBPACK_IMPORTED_MODULE_2__[\"Utils\"]; });\n\n/* harmony import */ var _conference_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./conference-api */ \"./src/conference-api.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ConferenceApi\", function() { return _conference_api__WEBPACK_IMPORTED_MODULE_3__[\"ConferenceApi\"]; });\n\n\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9zcmMvaW5kZXgudHM/ZmZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge0VSUk9SLEFDVElPTixBUElfT1BFUkFUSU9OfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmV4cG9ydCB7TWVkaWFzb3VwU29ja2V0QXBpfSBmcm9tICcuL21lZGlhc291cC1zb2NrZXQtYXBpJztcclxuZXhwb3J0IHtJTWVkaWFzb3VwQXBpfSBmcm9tICcuL2ktbWVkaWFzb3VwLWFwaSc7XHJcbmV4cG9ydCB7VXRpbHN9IGZyb20gJy4vdXRpbHMnO1xyXG5leHBvcnQge0NvbmZlcmVuY2VBcGl9IGZyb20gJy4vY29uZmVyZW5jZS1hcGknO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ }),

/***/ "./src/mediasoup-socket-api.ts":
/*!*************************************!*\
  !*** ./src/mediasoup-socket-api.ts ***!
  \*************************************/
/*! exports provided: MediasoupSocketApi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MediasoupSocketApi\", function() { return MediasoupSocketApi; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var rx_socket_io_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rx-socket-io.client */ \"./node_modules/rx-socket-io.client/dist/index.js\");\n/* harmony import */ var rx_socket_io_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(rx_socket_io_client__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ \"rxjs/operators\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nclass MediasoupSocketApi {\r\n    constructor(url, token, log) {\r\n        this.timeouts = [];\r\n        // this.url=url;\r\n        // this.token=token;\r\n        this.log = log || console.log;\r\n        this.socketClient = new rx_socket_io_client__WEBPACK_IMPORTED_MODULE_1__[\"RxSocketClient\"](url, {\r\n            query: `auth_token=${token}`,\r\n            transports: ['websocket'],\r\n            forceNew: true,\r\n            path: ''\r\n        });\r\n    }\r\n    initSocket() {\r\n        return this.socketClient.init()\r\n            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(() => {\r\n            return undefined;\r\n        }))\r\n            .toPromise();\r\n    }\r\n    resumeConsumer(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].RESUME_CONSUMER, json);\r\n        });\r\n    }\r\n    pauseConsumer(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].PAUSE_CONSUMER, json);\r\n        });\r\n    }\r\n    setPreferredLayers(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].SET_PREFERRED_LAYERS, json);\r\n        });\r\n    }\r\n    closeConsumer(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].CLOSE_CONSUMER, json);\r\n        });\r\n    }\r\n    resumeProducer(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].RESUME_PRODUCER, json);\r\n        });\r\n    }\r\n    pauseProducer(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].PAUSE_PRODUCER, json);\r\n        });\r\n    }\r\n    closeProducer(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].CLOSE_PRODUCER, json);\r\n        });\r\n    }\r\n    produce(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return (yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].PRODUCE, json));\r\n        });\r\n    }\r\n    consume(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return (yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].CONSUME, json));\r\n        });\r\n    }\r\n    createPipeTransport() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return (yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].CREATE_PIPE_TRANSPORT));\r\n        });\r\n    }\r\n    connectPipeTransport(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].CONNECT_PIPE_TRANSPORT, json);\r\n        });\r\n    }\r\n    closeTransport(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].CLOSE_TRANSPORT, json);\r\n        });\r\n    }\r\n    getServerConfigs() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return (yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].GET_SERVER_CONFIGS));\r\n        });\r\n    }\r\n    createTransport() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return (yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].CREATE_TRANSPORT));\r\n        });\r\n    }\r\n    connectTransport(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].CONNECT_TRANSPORT, json);\r\n        });\r\n    }\r\n    setMaxIncomingBitrate(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].SET_MAX_INCOMING_BITRATE, json);\r\n        });\r\n    }\r\n    producersStats(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return (yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].PRODUCERS_STATS, json));\r\n        });\r\n    }\r\n    consumersStats(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return (yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].CONSUMERS_STATS, json));\r\n        });\r\n    }\r\n    transportStats(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return (yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].TRANSPORT_STATS, json));\r\n        });\r\n    }\r\n    workerLoad() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return (yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].WORKER_LOAD));\r\n        });\r\n    }\r\n    numWorkers() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return (yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].NUM_WORKERS));\r\n        });\r\n    }\r\n    pipeToRemoteProducer(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].PIPE_TO_REMOTE_PRODUCER, json);\r\n        });\r\n    }\r\n    pipeFromRemoteProducer(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].PIPE_FROM_REMOTE_PRODUCER, json);\r\n        });\r\n    }\r\n    startRecording(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].START_RECORDING, json);\r\n        });\r\n    }\r\n    stopRecording(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].STOP_RECORDING, json);\r\n        });\r\n    }\r\n    fileStreaming(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].FILE_STREAMING, json);\r\n        });\r\n    }\r\n    stopFileStreaming(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].STOP_FILE_STREAMING, json);\r\n        });\r\n    }\r\n    recordedStreams() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].RECORDED_STREAMS);\r\n        });\r\n    }\r\n    streamRecordings(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].STREAM_RECORDINGS, json);\r\n        });\r\n    }\r\n    deleteStreamRecordings(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].DELETE_STREAM_RECORDINGS, json);\r\n        });\r\n    }\r\n    deleteRecording(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].DELETE_RECORDING, json);\r\n        });\r\n    }\r\n    pushToServerInputs(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].PUSH_TO_SERVER_INPUTS, json);\r\n        });\r\n    }\r\n    pushToServerOptions(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].PUSH_TO_SERVER_OPTIONS, json);\r\n        });\r\n    }\r\n    pushToServer(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].PUSH_TO_SERVER, json);\r\n        });\r\n    }\r\n    pullFromServerInputs(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].PULL_FROM_SERVER_INPUTS, json);\r\n        });\r\n    }\r\n    kindsByFile(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].KINDS_BY_FILE, json);\r\n        });\r\n    }\r\n    requestKeyframe(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].REQUEST_KEYFRAME, json);\r\n        });\r\n    }\r\n    rtmpStreaming(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.request(_constants__WEBPACK_IMPORTED_MODULE_0__[\"ACTION\"].RTMP_STREAMING, json);\r\n        });\r\n    }\r\n    clear() {\r\n        while (this.timeouts.length) {\r\n            const t = this.timeouts.shift();\r\n            if (t) {\r\n                clearTimeout(t);\r\n            }\r\n        }\r\n    }\r\n    request(action, json = {}) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.log('sent message', action, JSON.stringify(json));\r\n            try {\r\n                // const {data} =  await axios.post(`${this.url}/${PATH.MEDIASOUP}/${action}`,json,{\r\n                //     headers: { 'Content-Type': 'application/json', \"Authorization\":`Bearer ${this.token}` },\r\n                // });\r\n                //\r\n                const data = yield this.socketClient.emit(action, json).toPromise();\r\n                //\r\n                this.log('got message', action, JSON.stringify(data));\r\n                return data;\r\n            }\r\n            catch (e) {\r\n                this.log('got error', e);\r\n                if (e.response && !e.response.status && !_constants__WEBPACK_IMPORTED_MODULE_0__[\"ERROR\"][e.response.status]) {\r\n                    let timeout;\r\n                    yield new Promise(resolve => {\r\n                        timeout = setTimeout(resolve, 1000);\r\n                        this.timeouts.push(timeout);\r\n                    });\r\n                    if (!this.timeouts.includes(timeout)) {\r\n                        throw e;\r\n                    }\r\n                    return yield this.request(action, json);\r\n                }\r\n                else {\r\n                    throw { errorId: e.response.status };\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWVkaWFzb3VwLXNvY2tldC1hcGkudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9zcmMvbWVkaWFzb3VwLXNvY2tldC1hcGkudHM/ZGM4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0FDVElPTiwgRVJST1J9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHtcclxuICAgIENvbm5lY3RUcmFuc3BvcnRSZXF1ZXN0LFxyXG4gICAgQ29uc3VtZXJEYXRhLFxyXG4gICAgQ29uc3VtZVJlcXVlc3QsXHJcbiAgICBDb25zdW1lUmVzcG9uc2UsXHJcbiAgICBDb25zdW1lclByZWZlcnJlZExheWVycyxcclxuICAgIE51bVdvcmtlcnNEYXRhLFxyXG4gICAgUGlwZUZyb21SZW1vdGVQcm9kdWNlclJlcXVlc3QsXHJcbiAgICBQaXBlVG9SZW1vdGVQcm9kdWNlclJlcXVlc3QsXHJcbiAgICBQaXBlVHJhbnNwb3J0Q29ubmVjdERhdGEsXHJcbiAgICBQaXBlVHJhbnNwb3J0RGF0YSxcclxuICAgIFByb2R1Y2VyRGF0YSxcclxuICAgIFByb2R1Y2VSZXF1ZXN0LFxyXG4gICAgUHJvZHVjZVJlc3BvbnNlLFxyXG4gICAgU2VydmVyQ29uZmlncyxcclxuICAgIFJlY29yZGluZ0RhdGEsXHJcbiAgICBTdGF0c0lucHV0LFxyXG4gICAgU3RhdHNPdXRwdXQsXHJcbiAgICBTdHJlYW1GaWxlUmVxdWVzdCxcclxuICAgIFRyYW5zcG9ydEJpdHJhdGVEYXRhLFxyXG4gICAgVHJhbnNwb3J0RGF0YSxcclxuICAgIFdvcmtlckxvYWREYXRhLFxyXG4gICAgTGlzdERhdGEsXHJcbiAgICBTdHJlYW1EYXRhLFxyXG4gICAgRmlsZVBhdGhJbnB1dCxcclxuICAgIFB1c2hTdHJlYW1JbnB1dHNSZXF1ZXN0LFxyXG4gICAgUHVzaFN0cmVhbUlucHV0c1Jlc3BvbnNlLFxyXG4gICAgUHVsbFN0cmVhbUlucHV0c1JlcXVlc3QsXHJcbiAgICBQdWxsU3RyZWFtSW5wdXRzUmVzcG9uc2UsXHJcbiAgICBSZWNvcmRpbmdSZXF1ZXN0LFxyXG4gICAgU3RyZWFtS2luZHNEYXRhLFxyXG4gICAgU3RyZWFtUnRtcFJlcXVlc3QsXHJcbiAgICBLaW5kc0J5RmlsZUlucHV0LCBLaW5kc0RhdGEsIFB1c2hTdHJlYW1PcHRpb25zUmVxdWVzdCwgUHVzaFN0cmVhbU9wdGlvbnNSZXNwb25zZSwgUHVzaFN0cmVhbVJlcXVlc3RcclxufSBmcm9tICcuL2NsaWVudC1pbnRlcmZhY2VzJztcclxuaW1wb3J0IHtUcmFuc3BvcnRPcHRpb25zfSBmcm9tICdtZWRpYXNvdXAtY2xpZW50L2xpYi9UcmFuc3BvcnQnO1xyXG5pbXBvcnQge0lNZWRpYXNvdXBBcGl9IGZyb20gJy4vaS1tZWRpYXNvdXAtYXBpJztcclxuaW1wb3J0IHsgUnhTb2NrZXRDbGllbnQgfSBmcm9tICdyeC1zb2NrZXQtaW8uY2xpZW50JztcclxuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIE1lZGlhc291cFNvY2tldEFwaSBpbXBsZW1lbnRzIElNZWRpYXNvdXBBcGl7XHJcbiAgICAvLyBwcml2YXRlIHJlYWRvbmx5IHVybDpzdHJpbmc7XHJcbiAgICAvLyBwcml2YXRlIHJlYWRvbmx5IHRva2VuOnN0cmluZztcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgbG9nOnR5cGVvZiBjb25zb2xlLmxvZztcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGltZW91dHM6QXJyYXk8UmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4+ID1bXTtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgc29ja2V0Q2xpZW50OiBSeFNvY2tldENsaWVudDtcclxuICAgIGNvbnN0cnVjdG9yKHVybDpzdHJpbmcsdG9rZW46c3RyaW5nLGxvZz86dHlwZW9mIGNvbnNvbGUubG9nICl7XHJcbiAgICAgICAgLy8gdGhpcy51cmw9dXJsO1xyXG4gICAgICAgIC8vIHRoaXMudG9rZW49dG9rZW47XHJcbiAgICAgICAgdGhpcy5sb2c9bG9nfHxjb25zb2xlLmxvZztcclxuXHJcbiAgICAgICAgdGhpcy5zb2NrZXRDbGllbnQgPSBuZXcgUnhTb2NrZXRDbGllbnQoXHJcbiAgICAgICAgICB1cmwsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHF1ZXJ5OiBgYXV0aF90b2tlbj0ke3Rva2VufWAsXHJcbiAgICAgICAgICAgIHRyYW5zcG9ydHM6IFsnd2Vic29ja2V0J10sXHJcbiAgICAgICAgICAgIGZvcmNlTmV3OiB0cnVlLFxyXG4gICAgICAgICAgICBwYXRoOiAnJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpbml0U29ja2V0KCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5zb2NrZXRDbGllbnQuaW5pdCgpXHJcbiAgICAgICAgLnBpcGUobWFwKCgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgIH0pKVxyXG4gICAgICAgIC50b1Byb21pc2UoKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHJlc3VtZUNvbnN1bWVyKGpzb246Q29uc3VtZXJEYXRhKTpQcm9taXNlPHZvaWQ+e1xyXG4gICAgICAgIGF3YWl0IHRoaXMucmVxdWVzdChBQ1RJT04uUkVTVU1FX0NPTlNVTUVSLCBqc29uKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHBhdXNlQ29uc3VtZXIoanNvbjpDb25zdW1lckRhdGEpOlByb21pc2U8dm9pZD57XHJcbiAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0KEFDVElPTi5QQVVTRV9DT05TVU1FUiwganNvbik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZXRQcmVmZXJyZWRMYXllcnMoanNvbjpDb25zdW1lclByZWZlcnJlZExheWVycyk6UHJvbWlzZTx2b2lkPntcclxuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLlNFVF9QUkVGRVJSRURfTEFZRVJTLCBqc29uKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGNsb3NlQ29uc3VtZXIoanNvbjpDb25zdW1lckRhdGEpOlByb21pc2U8dm9pZD57XHJcbiAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0KEFDVElPTi5DTE9TRV9DT05TVU1FUiwganNvbik7XHJcbiAgICB9XHJcbiAgICBhc3luYyByZXN1bWVQcm9kdWNlcihqc29uOlByb2R1Y2VyRGF0YSk6UHJvbWlzZTx2b2lkPntcclxuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLlJFU1VNRV9QUk9EVUNFUiwganNvbik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBwYXVzZVByb2R1Y2VyKGpzb246UHJvZHVjZXJEYXRhKTpQcm9taXNlPHZvaWQ+e1xyXG4gICAgICAgIGF3YWl0IHRoaXMucmVxdWVzdChBQ1RJT04uUEFVU0VfUFJPRFVDRVIsIGpzb24pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgY2xvc2VQcm9kdWNlcihqc29uOlByb2R1Y2VyRGF0YSk6UHJvbWlzZTx2b2lkPntcclxuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLkNMT1NFX1BST0RVQ0VSLCBqc29uKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHByb2R1Y2UoanNvbjpQcm9kdWNlUmVxdWVzdCk6UHJvbWlzZTxQcm9kdWNlUmVzcG9uc2U+e1xyXG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5yZXF1ZXN0KEFDVElPTi5QUk9EVUNFLCBqc29uKSkgYXMgUHJvZHVjZVJlc3BvbnNlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgY29uc3VtZShqc29uOkNvbnN1bWVSZXF1ZXN0KTpQcm9taXNlPENvbnN1bWVSZXNwb25zZT57XHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLkNPTlNVTUUsIGpzb24pKSBhcyBDb25zdW1lUmVzcG9uc2U7XHJcbiAgICB9XHJcbiAgICBhc3luYyBjcmVhdGVQaXBlVHJhbnNwb3J0KCk6UHJvbWlzZTxQaXBlVHJhbnNwb3J0RGF0YT57XHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLkNSRUFURV9QSVBFX1RSQU5TUE9SVCkpIGFzIFBpcGVUcmFuc3BvcnREYXRhO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgY29ubmVjdFBpcGVUcmFuc3BvcnQoanNvbjpQaXBlVHJhbnNwb3J0Q29ubmVjdERhdGEpOlByb21pc2U8dm9pZD57XHJcbiAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0KEFDVElPTi5DT05ORUNUX1BJUEVfVFJBTlNQT1JULCBqc29uKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGNsb3NlVHJhbnNwb3J0KGpzb246VHJhbnNwb3J0RGF0YSk6UHJvbWlzZTx2b2lkPntcclxuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLkNMT1NFX1RSQU5TUE9SVCwganNvbik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRTZXJ2ZXJDb25maWdzKCk6UHJvbWlzZTxTZXJ2ZXJDb25maWdzPntcclxuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucmVxdWVzdChBQ1RJT04uR0VUX1NFUlZFUl9DT05GSUdTKSkgYXMgU2VydmVyQ29uZmlncztcclxuICAgIH1cclxuICAgIGFzeW5jIGNyZWF0ZVRyYW5zcG9ydCgpOlByb21pc2U8VHJhbnNwb3J0T3B0aW9ucz57XHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLkNSRUFURV9UUkFOU1BPUlQpKSBhcyBUcmFuc3BvcnRPcHRpb25zO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgY29ubmVjdFRyYW5zcG9ydChqc29uOkNvbm5lY3RUcmFuc3BvcnRSZXF1ZXN0KTpQcm9taXNlPHZvaWQ+e1xyXG4gICAgICAgIGF3YWl0IHRoaXMucmVxdWVzdChBQ1RJT04uQ09OTkVDVF9UUkFOU1BPUlQsanNvbik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZXRNYXhJbmNvbWluZ0JpdHJhdGUoanNvbjpUcmFuc3BvcnRCaXRyYXRlRGF0YSk6UHJvbWlzZTx2b2lkPntcclxuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLlNFVF9NQVhfSU5DT01JTkdfQklUUkFURSwganNvbik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBwcm9kdWNlcnNTdGF0cyhqc29uOlN0YXRzSW5wdXQpOlByb21pc2U8U3RhdHNPdXRwdXQ+e1xyXG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5yZXF1ZXN0KEFDVElPTi5QUk9EVUNFUlNfU1RBVFMsIGpzb24pKSBhcyBTdGF0c091dHB1dDtcclxuICAgIH1cclxuICAgIGFzeW5jIGNvbnN1bWVyc1N0YXRzKGpzb246U3RhdHNJbnB1dCk6UHJvbWlzZTxTdGF0c091dHB1dD57XHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLkNPTlNVTUVSU19TVEFUUywganNvbikpIGFzIFN0YXRzT3V0cHV0O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgdHJhbnNwb3J0U3RhdHMoanNvbjpTdGF0c0lucHV0KTpQcm9taXNlPFN0YXRzT3V0cHV0PntcclxuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucmVxdWVzdChBQ1RJT04uVFJBTlNQT1JUX1NUQVRTLCBqc29uKSkgYXMgU3RhdHNPdXRwdXQ7XHJcbiAgICB9XHJcbiAgICBhc3luYyB3b3JrZXJMb2FkKCk6UHJvbWlzZTxXb3JrZXJMb2FkRGF0YT57XHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLldPUktFUl9MT0FEKSkgYXMgV29ya2VyTG9hZERhdGE7XHJcbiAgICB9XHJcbiAgICBhc3luYyBudW1Xb3JrZXJzKCk6UHJvbWlzZTxOdW1Xb3JrZXJzRGF0YT57XHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLk5VTV9XT1JLRVJTKSkgYXMgTnVtV29ya2Vyc0RhdGE7XHJcbiAgICB9XHJcbiAgICBhc3luYyBwaXBlVG9SZW1vdGVQcm9kdWNlcihqc29uOlBpcGVUb1JlbW90ZVByb2R1Y2VyUmVxdWVzdCk6UHJvbWlzZTx2b2lkPntcclxuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLlBJUEVfVE9fUkVNT1RFX1BST0RVQ0VSLCBqc29uKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHBpcGVGcm9tUmVtb3RlUHJvZHVjZXIoanNvbjpQaXBlRnJvbVJlbW90ZVByb2R1Y2VyUmVxdWVzdCk6UHJvbWlzZTx2b2lkPntcclxuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLlBJUEVfRlJPTV9SRU1PVEVfUFJPRFVDRVIsIGpzb24pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc3RhcnRSZWNvcmRpbmcoanNvbjpSZWNvcmRpbmdSZXF1ZXN0KTpQcm9taXNlPHZvaWQ+e1xyXG4gICAgICAgIGF3YWl0IHRoaXMucmVxdWVzdChBQ1RJT04uU1RBUlRfUkVDT1JESU5HLGpzb24pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc3RvcFJlY29yZGluZyhqc29uOlJlY29yZGluZ0RhdGEpOlByb21pc2U8dm9pZD57XHJcbiAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0KEFDVElPTi5TVE9QX1JFQ09SRElORyxqc29uKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGZpbGVTdHJlYW1pbmcoanNvbjpTdHJlYW1GaWxlUmVxdWVzdCk6UHJvbWlzZTx2b2lkPntcclxuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLkZJTEVfU1RSRUFNSU5HLGpzb24pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc3RvcEZpbGVTdHJlYW1pbmcoanNvbjpTdHJlYW1LaW5kc0RhdGEpOlByb21pc2U8dm9pZD57XHJcbiAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0KEFDVElPTi5TVE9QX0ZJTEVfU1RSRUFNSU5HLGpzb24pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcmVjb3JkZWRTdHJlYW1zKCk6UHJvbWlzZTxMaXN0RGF0YT57XHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLlJFQ09SREVEX1NUUkVBTVMpIGFzIExpc3REYXRhKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHN0cmVhbVJlY29yZGluZ3MoanNvbjpTdHJlYW1EYXRhKTpQcm9taXNlPExpc3REYXRhPntcclxuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucmVxdWVzdChBQ1RJT04uU1RSRUFNX1JFQ09SRElOR1MsanNvbikgYXMgTGlzdERhdGEpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZGVsZXRlU3RyZWFtUmVjb3JkaW5ncyhqc29uOlN0cmVhbURhdGEpOlByb21pc2U8dm9pZD57XHJcbiAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0KEFDVElPTi5ERUxFVEVfU1RSRUFNX1JFQ09SRElOR1MsanNvbik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBkZWxldGVSZWNvcmRpbmcoanNvbjpGaWxlUGF0aElucHV0KTpQcm9taXNlPHZvaWQ+e1xyXG4gICAgICAgIGF3YWl0IHRoaXMucmVxdWVzdChBQ1RJT04uREVMRVRFX1JFQ09SRElORyxqc29uKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHB1c2hUb1NlcnZlcklucHV0cyhqc29uOlB1c2hTdHJlYW1JbnB1dHNSZXF1ZXN0KTpQcm9taXNlPFB1c2hTdHJlYW1JbnB1dHNSZXNwb25zZT57XHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLlBVU0hfVE9fU0VSVkVSX0lOUFVUUyxqc29uKSBhcyBQdXNoU3RyZWFtSW5wdXRzUmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcHVzaFRvU2VydmVyT3B0aW9ucyhqc29uOlB1c2hTdHJlYW1PcHRpb25zUmVxdWVzdCk6UHJvbWlzZTxQdXNoU3RyZWFtT3B0aW9uc1Jlc3BvbnNlPntcclxuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucmVxdWVzdChBQ1RJT04uUFVTSF9UT19TRVJWRVJfT1BUSU9OUyxqc29uKSBhcyBQdXNoU3RyZWFtT3B0aW9uc1Jlc3BvbnNlKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHB1c2hUb1NlcnZlcihqc29uOlB1c2hTdHJlYW1SZXF1ZXN0KTpQcm9taXNlPHZvaWQ+e1xyXG4gICAgICAgIGF3YWl0IHRoaXMucmVxdWVzdChBQ1RJT04uUFVTSF9UT19TRVJWRVIsanNvbik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBwdWxsRnJvbVNlcnZlcklucHV0cyhqc29uOlB1bGxTdHJlYW1JbnB1dHNSZXF1ZXN0KTpQcm9taXNlPFB1bGxTdHJlYW1JbnB1dHNSZXNwb25zZT57XHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLlBVTExfRlJPTV9TRVJWRVJfSU5QVVRTLGpzb24pIGFzIFB1bGxTdHJlYW1JbnB1dHNSZXNwb25zZSk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMga2luZHNCeUZpbGUoanNvbjpLaW5kc0J5RmlsZUlucHV0KTpQcm9taXNlPEtpbmRzRGF0YT57XHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLktJTkRTX0JZX0ZJTEUsanNvbikgYXMgS2luZHNEYXRhKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHJlcXVlc3RLZXlmcmFtZShqc29uOkNvbnN1bWVyRGF0YSk6UHJvbWlzZTx2b2lkPntcclxuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3QoQUNUSU9OLlJFUVVFU1RfS0VZRlJBTUUsIGpzb24pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcnRtcFN0cmVhbWluZyhqc29uOlN0cmVhbVJ0bXBSZXF1ZXN0KTpQcm9taXNlPHZvaWQ+e1xyXG4gICAgICAgIGF3YWl0IHRoaXMucmVxdWVzdChBQ1RJT04uUlRNUF9TVFJFQU1JTkcsanNvbik7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpOnZvaWR7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMudGltZW91dHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQ9dGhpcy50aW1lb3V0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpZih0KXtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByaXZhdGUgYXN5bmMgcmVxdWVzdChhY3Rpb24sanNvbj17fSk6UHJvbWlzZTxvYmplY3Q+e1xyXG4gICAgICAgIHRoaXMubG9nKCdzZW50IG1lc3NhZ2UnLCBhY3Rpb24sIEpTT04uc3RyaW5naWZ5KGpzb24pKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBjb25zdCB7ZGF0YX0gPSAgYXdhaXQgYXhpb3MucG9zdChgJHt0aGlzLnVybH0vJHtQQVRILk1FRElBU09VUH0vJHthY3Rpb259YCxqc29uLHtcclxuICAgICAgICAgICAgLy8gICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywgXCJBdXRob3JpemF0aW9uXCI6YEJlYXJlciAke3RoaXMudG9rZW59YCB9LFxyXG4gICAgICAgICAgICAvLyB9KTtcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuc29ja2V0Q2xpZW50LmVtaXQ8b2JqZWN0PihhY3Rpb24sIGpzb24pLnRvUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICB0aGlzLmxvZygnZ290IG1lc3NhZ2UnLCAgYWN0aW9uLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZygnZ290IGVycm9yJyxlKTtcclxuICAgICAgICAgICAgaWYoZS5yZXNwb25zZSAmJiAhZS5yZXNwb25zZS5zdGF0dXMgJiYgIUVSUk9SW2UucmVzcG9uc2Uuc3RhdHVzXSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGltZW91dDtcclxuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmU9PntcclxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0PXNldFRpbWVvdXQocmVzb2x2ZSwxMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRzLnB1c2godGltZW91dClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMudGltZW91dHMuaW5jbHVkZXModGltZW91dCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0KGFjdGlvbixqc29uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHtlcnJvcklkOiBlLnJlc3BvbnNlLnN0YXR1c307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBcUNBO0FBQ0E7QUFFQTtBQU1BO0FBRkE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBRUE7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/mediasoup-socket-api.ts\n");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/*! exports provided: Utils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Utils\", function() { return Utils; });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nclass Utils {\r\n    static getUserMedia(constraints, isDisplay = false) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (isDisplay) {\r\n                return yield navigator.mediaDevices.getDisplayMedia(constraints);\r\n            }\r\n            else {\r\n                return yield navigator.mediaDevices.getUserMedia(constraints);\r\n            }\r\n        });\r\n    }\r\n}\r\nUtils.isFirefox = typeof window.InstallTrigger !== 'undefined';\r\nUtils.isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\r\nUtils.isChrome = !!window.chrome && !Utils.isOpera;\r\nUtils.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvLi9zcmMvdXRpbHMudHM/N2RkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbnRlcmZhY2UgTWVkaWFEZXZpY2VzRXh0ZW5kZWQgZXh0ZW5kcyBNZWRpYURldmljZXN7XHJcbiAgICBnZXREaXNwbGF5TWVkaWE6KGNvbnN0cmFpbnRzOk1lZGlhU3RyZWFtQ29uc3RyYWludHMpPT5Qcm9taXNlPE1lZGlhU3RyZWFtPlxyXG59XHJcbmV4cG9ydCBjbGFzcyBVdGlsc3tcclxuICAgIHN0YXRpYyBhc3luYyBnZXRVc2VyTWVkaWEoY29uc3RyYWludHM6TWVkaWFTdHJlYW1Db25zdHJhaW50cyxpc0Rpc3BsYXk6Ym9vbGVhbj1mYWxzZSk6UHJvbWlzZTxNZWRpYVN0cmVhbT57XHJcbiAgICAgICAgaWYoaXNEaXNwbGF5KXtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIGFzIE1lZGlhRGV2aWNlc0V4dGVuZGVkKS5nZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzRmlyZWZveCA9IHR5cGVvZiAod2luZG93IGFzIGFueSkuSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xyXG4gICAgc3RhdGljIGlzT3BlcmEgPSAhISh3aW5kb3cgYXMgYW55KS5vcGVyYSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBPUFIvJykgPj0gMDtcclxuICAgIHN0YXRpYyBpc0Nocm9tZSA9ICEhKHdpbmRvdyBhcyBhbnkpLmNocm9tZSAmJiAhIFV0aWxzLmlzT3BlcmE7XHJcbiAgICBzdGF0aWMgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG5cclxufSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils.ts\n");

/***/ }),

/***/ "rxjs":
/*!***********************!*\
  !*** external "rxjs" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_rxjs__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnhqcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3J4X3NvY2tldGlvX2NsaWVudC9leHRlcm5hbCBcInJ4anNcIj8zMDE0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yeGpzX187Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///rxjs\n");

/***/ }),

/***/ "rxjs/operators":
/*!******************************************************************************************************************************!*\
  !*** external {"root":["rxjs","operators"],"commonjs":"rxjs/operators","commonjs2":"rxjs/operators","amd":"rxjs/operators"} ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_rxjs_operators__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnhqcy9vcGVyYXRvcnMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yeF9zb2NrZXRpb19jbGllbnQvZXh0ZXJuYWwge1wicm9vdFwiOltcInJ4anNcIixcIm9wZXJhdG9yc1wiXSxcImNvbW1vbmpzXCI6XCJyeGpzL29wZXJhdG9yc1wiLFwiY29tbW9uanMyXCI6XCJyeGpzL29wZXJhdG9yc1wiLFwiYW1kXCI6XCJyeGpzL29wZXJhdG9yc1wifT9iOTEwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yeGpzX29wZXJhdG9yc19fOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///rxjs/operators\n");

/***/ }),

/***/ "socket.io-client":
/*!********************************************************************************************************************!*\
  !*** external {"root":"io","commonjs":"socket.io-client","commonjs2":"socket.io-client","amd":"socket.io-client"} ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_socket_io_client__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ja2V0LmlvLWNsaWVudC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3J4X3NvY2tldGlvX2NsaWVudC9leHRlcm5hbCB7XCJyb290XCI6XCJpb1wiLFwiY29tbW9uanNcIjpcInNvY2tldC5pby1jbGllbnRcIixcImNvbW1vbmpzMlwiOlwic29ja2V0LmlvLWNsaWVudFwiLFwiYW1kXCI6XCJzb2NrZXQuaW8tY2xpZW50XCJ9PzdjMTciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3NvY2tldF9pb19jbGllbnRfXzsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///socket.io-client\n");

/***/ })

/******/ });
});